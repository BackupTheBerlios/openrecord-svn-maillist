<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openrecord-svn] r20 - trunk/source
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openrecord-svn/2005-April/index.html" >
   <LINK REL="made" HREF="mailto:openrecord-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-svn%5D%20r20%20-%20trunk/source&In-Reply-To=%3C200504050502.j3552AkM017208%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000013.html">
   <LINK REL="Next"  HREF="000015.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openrecord-svn] r20 - trunk/source</H1>
    <B>Brian Douglas Skinner at BerliOS</B> 
    <A HREF="mailto:openrecord-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-svn%5D%20r20%20-%20trunk/source&In-Reply-To=%3C200504050502.j3552AkM017208%40sheep.berlios.de%3E"
       TITLE="[openrecord-svn] r20 - trunk/source">skinner at sheep.berlios.de
       </A><BR>
    <I>Tue Apr  5 07:02:10 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000013.html">[openrecord-svn] r15 - trunk/source
</A></li>
        <LI>Next message: <A HREF="000015.html">[openrecord-svn] r21 - trunk/source
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: skinner
Date: 2005-04-05 07:02:08 +0200 (Tue, 05 Apr 2005)
New Revision: 20

Modified:
   trunk/source/bar_chart_layout.js
   trunk/source/base_style.css
   trunk/source/detail_layout.js
   trunk/source/item.js
   trunk/source/item_view.js
   trunk/source/outline_layout.js
   trunk/source/rectangle.js
   trunk/source/root_view.js
   trunk/source/section_view.js
   trunk/source/stevedore.js
   trunk/source/table_layout.js
   trunk/source/test_page.js
   trunk/source/text_view.js
   trunk/source/util.js
   trunk/source/view.js
Log:
Updated more view classes to inherit from View.  Worked on event handling code.

Modified: trunk/source/bar_chart_layout.js
===================================================================
--- trunk/source/bar_chart_layout.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/bar_chart_layout.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -48,13 +48,15 @@
  * A BarChartLayout displays a set of content items for a SectionView. 
  *
  * @scope    public instance constructor
+ * @extends  View
  * @param    inSectionView    The SectionView that serves as the superview for this view. 
+ * @param    inDivElement    The HTMLDivElement to display this view in. 
  * @syntax   var barChart = new BarChartLayout()
  */
-function BarChartLayout(inSectionView) {
-  Util.assert(inSectionView instanceof SectionView);
-  this.mySectionView = inSectionView;
-  this._myDivElement = null;
+BarChartLayout.prototype = new View();  // makes BarChartLayout be a subclass of View
+function BarChartLayout(inSectionView, inDivElement) {
+  this.setSuperview(inSectionView);
+  this.setDivElement(inDivElement);
 }
 
 
@@ -70,25 +72,12 @@
 
 
 /**
- * Tells the BarChartLayout what HTMLDivElement to display the bar chart in.
- *
- * @scope    public instance method
- * @param    inDivElement    The HTMLDivElement to display the bar chart in. 
- */
-BarChartLayout.prototype.setDivElement = function (inDivElement) {
-  Util.assert(inDivElement instanceof HTMLDivElement);
-  this._myDivElement = inDivElement;
-  this.display();
-};
-
-
-/**
  * Re-creates all the HTML for the BarChartLayout, and hands the HTML to the 
  * browser to be re-drawn.
  *
  * @scope    public instance method
  */
-BarChartLayout.prototype.display = function () {
+BarChartLayout.prototype.refresh = function () {
   var listOfStrings = [];
 
   var contentItem = null;
@@ -96,7 +85,8 @@
   var hashTableOfNumericValueIncidenceKeyedByAttributeUuid = {};
   
   // for each attribute, count the number of items where that attribute has a numeric value
-  var listOfContentItems = this.mySectionView.getListOfContentItems();
+  // PENDING: how do we know our superview responds to getListOfContentItems()? 
+  var listOfContentItems = this.getSuperview().getListOfContentItems();
   for (var iKey in listOfContentItems) {
     contentItem = listOfContentItems[iKey];
     var listOfAttributesForItem = contentItem.getListOfAttributeUuids();
@@ -123,7 +113,7 @@
   for (attributeUuid in hashTableOfNumericValueIncidenceKeyedByAttributeUuid) {
     var incidence = hashTableOfNumericValueIncidenceKeyedByAttributeUuid[attributeUuid];
     if (incidence &gt; maxIncidence) {
-      selectedAttribute = this.mySectionView.getStevedore().getItemFromUuid(attributeUuid);
+      selectedAttribute = this.getStevedore().getItemFromUuid(attributeUuid);
       maxIncidence = incidence;
     }
   }
@@ -144,7 +134,7 @@
   // add the table header row(s)
   listOfStrings.push(&quot;&lt;table class=\&quot;&quot; + SectionView.ELEMENT_CLASS_SIMPLE_TABLE + &quot;\&quot;&gt;&quot;);
   listOfStrings.push(&quot;&lt;tr&gt;&quot;);
-  var attributeCalledName = this.mySectionView.getStevedore().getItemFromUuid(Stevedore.UUID_FOR_ATTRIBUTE_NAME);
+  var attributeCalledName = this.getStevedore().getItemFromUuid(Stevedore.UUID_FOR_ATTRIBUTE_NAME);
   listOfStrings.push(&quot;&lt;th&gt;&quot; + attributeCalledName.getDisplayName() + &quot;&lt;/th&gt;&quot;);
   if (selectedAttribute) {
     listOfStrings.push(&quot;&lt;th&gt;&quot; + selectedAttribute.getDisplayName() + &quot;&lt;/th&gt;&quot;);
@@ -178,12 +168,21 @@
     
   // return all the new content   
   var finalString = listOfStrings.join(&quot;&quot;);
-  this._myDivElement.innerHTML = finalString;
+  this.getDivElement().innerHTML = finalString;
 };
 
 
+/**
+ * Does final clean-up.
+ *
+ * @scope    public instance method
+ */
+BarChartLayout.prototype.endOfLife = function () {
+  this.getDivElement().innerHTML = &quot;&quot;;
+};
+
+
 // -------------------------------------------------------------------
 // End of file
 // -------------------------------------------------------------------
 
-

Modified: trunk/source/base_style.css
===================================================================
--- trunk/source/base_style.css	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/base_style.css	2005-04-05 05:02:08 UTC (rev 20)
@@ -51,20 +51,22 @@
  Here are lists of the colors I use.
  
  Background colors:
-   white            --&gt;  rgb(100%,100%,100%);
-   gray background  --&gt;  rgb(90%,90%,90%);
-   green background --&gt;  rgb(80%,100%,80%);
-   red background   --&gt;  rgb(100%,80%,80%);
-   bright yellow    --&gt;  rgb(100%,100%,0%);
+   white            --&gt;  rgb(100%, 100%, 100%);
+   gray background  --&gt;  rgb(90%, 90%, 90%);
+   green background --&gt;  rgb(80%, 100%, 80%);
+   red background   --&gt;  rgb(100%, 80%, 80%);
+   bright yellow    --&gt;  rgb(100%, 100%, 0%);
+   editing yellow   --&gt;  rgb(100%, 100%, 40%);
+   hover yellow     --&gt;  rgb(100%, 100%, 70%);
    black            --&gt;  rgb(0%, 0%, 0%);
 
  Line colors
-   table line gray  --&gt;  rgb(70%,70%,70%);
+   border line gray --&gt;  rgb(70%,70%,70%);
    dark blue        --&gt;  rgb(0%, 0%, 50%);
  
  Font colors:
    black            --&gt;  rgb(0%, 0%, 0%);
-   logo gray        --&gt;  rgb(60%,60%,60%);  
+   logo gray        --&gt;  rgb(60%, 60%, 60%);  
    dark blue        --&gt;  rgb(0%, 0%, 50%);
    red              --&gt;  rgb(100%, 0%, 0%);
    teletype green   --&gt;  rgb(0%, 100%, 0%);
@@ -72,7 +74,7 @@
  Link colors:
    blue             --&gt;  #0000cc;
    maroon           --&gt;  #551a8b;
-   dark gray        --&gt;  rgb(30%,30%,30%);  
+   dark gray        --&gt;  rgb(30%, 30%, 30%);  
 
 *********************************************************************/
 
@@ -81,13 +83,13 @@
 /* Universal styles                     */
 
 html, body {
-  background: rgb(100%,100%,100%);
+  background: rgb(100%, 100%, 100%);
   color: rgb(0%,0%,0%);
   font-family: Arial, Verdana, sans-serif;
 }
 
 div.editmode {
-  background: rgb(100%,100%,100%);
+  background: rgb(100%, 100%, 100%);
 }
 
 h1 {
@@ -129,7 +131,7 @@
   text-decoration: none;
   border-bottom-style: solid;
   border-bottom-width: 1pt;
-  background: rgb(100%,100%,0%);
+  background: rgb(100%, 100%, 0%);
 }
 
 a.anchor {
@@ -152,7 +154,7 @@
   text-decoration: none;
   border-bottom-style: solid;
   border-bottom-width: 1pt;
-  background: rgb(100%,100%,0%);
+  background: rgb(100%, 100%, 0%);
 }
 
 a.more {
@@ -199,7 +201,7 @@
 }
 
 .logostart {
-  color: rgb(60%,60%,60%);  
+  color: rgb(60%, 60%, 60%);  
 }
 
 .logomiddle {
@@ -207,7 +209,7 @@
 }
 
 .logoend {
-  color: rgb(60%,60%,60%);  
+  color: rgb(60%, 60%, 60%);  
 }
 
 .logo {
@@ -271,17 +273,17 @@
 
 .menu_item a:link {
   color: rgb(0%, 0%, 50%); 
-  background-color: rgb(100%,100%,100%);
+  background-color: rgb(100%, 100%, 100%);
 }
 
 .menu_item a:visited {
   color: rgb(0%, 0%, 50%); 
-  background-color: rgb(90%,90%,90%);
+  background-color: rgb(90%, 90%, 90%);
   border-left: solid 5pt rgb(90%, 90%, 90%);
 }
 
 .menu_item a:hover {
-  background-color: rgb(100%,100%,0%);
+  background-color: rgb(100%, 100%, 0%);
   width: 100%;
   border-left: solid 5pt rgb(0%, 0%, 50%);
   border-bottom-style: none;
@@ -331,6 +333,7 @@
 
 /****************************************/
 /* Footer and copyright styles          */
+
 .footer {
   clear: both;
   border-left: solid 1pt rgb(0%, 0%, 50%);
@@ -355,12 +358,12 @@
 
 .faq dt {
   font-weight: bold;
-  color: rgb(0%,0%,50%);
+  color: rgb(0%, 0%, 50%);
   margin-top: 1.4em;
 }
 
 .faq dd {
-  color: rgb(0%,0%,0%);
+  color: rgb(0%, 0%, 0%);
 }
 
 
@@ -368,31 +371,31 @@
 /* Table styles                         */
 
 .simple_table {
-  background: rgb(70%,70%,70%);
-  border: 1pt solid rgb(70%,70%,70%);
+  background: rgb(70%, 70%, 70%);
+  border: 1pt solid rgb(70%, 70%, 70%);
   border-collapse: collapse; 
 }
 
 .simple_table th {
   padding: 0.3em;
-  color: rgb(0%,0%,50%);
-  background: rgb(90%,90%,90%);
+  color: rgb(0%, 0%, 50%);
+  background: rgb(90%, 90%, 90%);
   font-size: 0.8em;
-  border: 1pt solid rgb(70%,70%,70%);
+  border: 1pt solid rgb(70%, 70%, 70%);
 }
 
 .simple_table tr {
-  background: rgb(100%,100%,100%);
+  background: rgb(100%, 100%, 100%);
 }
 
 .viewmode .simple_table tr:hover {
-  background: rgb(100%,100%,0%);
+  background: rgb(100%, 100%, 0%);
 }
 
 .simple_table td {
   padding: 0.1em 0.3em; 
   font-size: 0.8em;
-  border: 1pt solid rgb(70%,70%,70%);
+  border: 1pt solid rgb(70%, 70%, 70%);
 }
 
 td.plain {
@@ -400,11 +403,11 @@
 }
 
 td.yup {
-  background: rgb(80%,100%,80%);
+  background: rgb(80%, 100%, 80%);
 }
 
 td.nope {
-  background: rgb(100%,80%,80%);
+  background: rgb(100%, 80%, 80%);
 }
 
 td.year {
@@ -419,7 +422,7 @@
 
 td.title {
   font-weight: bold;  
-  background: rgb(90%,90%,90%);
+  background: rgb(90%, 90%, 90%);
 }
 
 td.label {
@@ -429,38 +432,38 @@
 }
 
 td.negative {
-  color: rgb(90%,0%,0%);
+  color: rgb(90%, 0%, 0%);
 }
 
 td.total {
   font-weight: bold;  
-  background: rgb(90%,90%,90%);
+  background: rgb(90%, 90%, 90%);
 }
 
 input.text_field_in_table_cell {
   border-width: 0px;
   width: 100%;
-  background: rgb(100%,100%,0%);
+  background: rgb(100%, 100%, 40%);
 }
 
 input.text_field_in_table_cell:hover {
   border-width: 0px;
   width: 100%;
-  background: rgb(100%,100%,0%);
+  background: rgb(100%, 100%, 40%);
 }
 
 .editmode .simple_table td:hover {
-  background: rgb(100%,100%,70%);
+  background: rgb(100%, 100%, 70%);
 }
 
 td.newitem {
   /* background: rgb(100%,100%,50%); */
-  border-top: medium solid rgb(70%,70%,70%);
+  border-top: medium solid rgb(70%, 70%, 70%);
 }
 
 .editmode .simple_table td.selected {
   /* padding: 0px 0px; */
-  background: rgb(100%,100%,0%);
+  background: rgb(100%, 100%, 40%);
 }
 
 
@@ -521,9 +524,23 @@
   width: 100%;
   font-family: Arial, Verdana, sans-serif;
   color: rgb(0%, 0%, 0%);
+  background: rgb(100%, 100%, 40%);
+  border: none; 
 }
 
+div.editmode .text_block:hover {
+  background: rgb(100%, 100%, 70%);
+  border: thin solid rgb(70%, 70%, 70%);
+}
 
+div.editmode .text_block {
+  border: solid thin rgb(100%, 100%, 100%); 
+}
+
+div.viewmode .text_block {
+  border: solid thin rgb(100%, 100%, 100%); 
+}
+
 /****************************************/
 /* PENDING -- time to delete these?     */
 

Modified: trunk/source/detail_layout.js
===================================================================
--- trunk/source/detail_layout.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/detail_layout.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -47,14 +47,15 @@
  * A DetailLayout display one or more content items. 
  *
  * @scope    public instance constructor
+ * @extends  View
  * @param    inSuperView    The superview for this view. 
+ * @param    inDivElement    The HTMLDivElement to display this view in. 
  * @syntax   var detailLayout = new DetailLayout()
  */
-function DetailLayout(inSuperView) {
-  Util.assert((inSuperView instanceof SectionView) || (inSuperView instanceof ItemView));
-  
-  this.mySuperView = inSuperView;
-  this.myDivElement = null;
+DetailLayout.prototype = new View();  // makes DetailLayout be a subclass of View
+function DetailLayout(inSuperView, inDivElement) {
+  this.setSuperview(inSuperView);
+  this.setDivElement(inDivElement);  
 }
 
 
@@ -70,30 +71,17 @@
 
   
 /**
- * Tells the DetailLayout what HTMLDivElement to display itself in.
- *
- * @scope    public instance method
- * @param    inDivElement    The HTMLDivElement to display in. 
- */
-DetailLayout.prototype.setDivElement = function (inDivElement) {
-  Util.assert(inDivElement instanceof HTMLDivElement);
-  
-  this.myDivElement = inDivElement;
-  this.display();
-};
-
-
-/**
  * Re-creates all the HTML for the DetailLayout, and hands the HTML to the 
  * browser to be re-drawn.
  *
  * @scope    public instance method
  */
-DetailLayout.prototype.display = function () {
+DetailLayout.prototype.refresh = function () {
   var listOfStrings = [];
 
   // for each content item, add its HTML representation to the output
-  var listOfContentItems = this.mySuperView.getListOfContentItems();
+  // PENDING: how do we know our superview responds to getListOfContentItems()? 
+  var listOfContentItems = this.getSuperview().getListOfContentItems();
   for (var contentItemKey in listOfContentItems) {
     var contentItem = listOfContentItems[contentItemKey];
     listOfStrings.push(this.getXhtmlTableForItem(contentItem));
@@ -102,11 +90,21 @@
 
   // take all the HTML and put it together
   var finalString = listOfStrings.join(&quot;&quot;);
-  this.myDivElement.innerHTML = finalString;
+  this.getDivElement().innerHTML = finalString;
 };
 
 
 /**
+ * Does final clean-up.
+ *
+ * @scope    public instance method
+ */
+DetailLayout.prototype.endOfLife = function () {
+  this.getDivElement().innerHTML = &quot;&quot;;
+};
+
+
+/**
  * Given an item to be display, returns a string with XHTML to display
  * the item.
  *
@@ -118,7 +116,7 @@
   Util.assert(inItem instanceof Item);
   
   var listOfStrings = [];
-  var stevedore = this.mySuperView.getStevedore();
+  var stevedore = this.getStevedore();
   var attributeCalledName = stevedore.getItemFromUuid(Stevedore.UUID_FOR_ATTRIBUTE_NAME);
   
   listOfStrings.push(&quot;&lt;table class=\&quot;&quot; + SectionView.ELEMENT_CLASS_SIMPLE_TABLE + &quot;\&quot;&gt;&quot;);

Modified: trunk/source/item.js
===================================================================
--- trunk/source/item.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/item.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -116,7 +116,7 @@
   Util.assert(Util.isHashTable(this._myHashTableOfAssignmentsKeyedByAttributeUuid));
   
   var attributeUuid = this._myStevedore.getAttributeUuidFromAttributeOrUuid(inAttribute);
-  // PROBLEM: 
+  // PENDING: 
   //   If this item isn't yet fully loaded into the cache, then we might need 
   //   to ask our stevedore to get the attribute values for us.
   var valueList = this._myHashTableOfAssignmentsKeyedByAttributeUuid[attributeUuid];
@@ -153,7 +153,7 @@
   if (valueWasSet) {
     this._myStevedore.markDirty(this);
   }
-  // PROBLEM: 
+  // PENDING: 
   //   We also need to create a change object, and we need to tell 
   //   this._myStevedore about the change.
   this._notifyObservers();
@@ -180,7 +180,7 @@
     this._myStevedore.markDirty(this);
   }
   
-  // PROBLEM: 
+  // PENDING: 
   //   We also need to create a change object, and we need to tell 
   //   this._myStevedore about the change.
   this._notifyObservers();
@@ -250,11 +250,11 @@
   // is in turn in the categoery &quot;inCategory&quot;
   for (key in valueList) {
     value = valueList[key];
-    // PROBLEM: 
+    // PENDING: 
     //   This will go into an infinite loop if there is ever a cycle in the category 
     //   assignments, like: A is in category B, and B is in C, and C is in A.
     //   We need to use a non-recursive search of the graph.
-    // PROBLEM:
+    // PENDING:
     //   Do we also need to register as an observer of something, so that if we later
     //   become a member of that category in question, then we can notify whoever
     //   is observing us?

Modified: trunk/source/item_view.js
===================================================================
--- trunk/source/item_view.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/item_view.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -66,7 +66,7 @@
   this.myItem = inItem;
   // this.myDivElement = inDivElement;
   // this.myRootView = inRootView;
-  this.myLayout = new DetailLayout(this);
+  this.myLayout = null;
 }
 
 
@@ -103,7 +103,7 @@
 ItemView.prototype.refresh = function () {
   Util.assert(this.myItem instanceof Item);
   // Util.assert(this.myDivElement instanceof HTMLDivElement);
-  
+  // RootView.displayTextInDebugTextarea(&quot;ItemView.prototype.refresh&quot;); 
   var listOfStrings = [];
 
   // add an &lt;h1&gt; heading with the name of the page
@@ -116,11 +116,11 @@
   // write out all the new content 
   var finalString = listOfStrings.join(&quot;&quot;);
   this.getDivElement().innerHTML = finalString;
-  this.includeOnScreen(true);
 
   // let the detailLayout add its own content
   var detailLayoutDivElement = document.getElementById(detailDivId);
-  this.myLayout.setDivElement(detailLayoutDivElement);
+  this.myLayout = new DetailLayout(this, detailLayoutDivElement);
+  this.myLayout.refresh();
 };
 
 

Modified: trunk/source/outline_layout.js
===================================================================
--- trunk/source/outline_layout.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/outline_layout.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -46,14 +46,15 @@
  * An OutlineLayout displays a set of content items for a SectionView. 
  *
  * @scope    public instance constructor
+ * @extends  View
  * @param    inSectionView    The SectionView that serves as the superview for this view. 
+ * @param    inDivElement    The HTMLDivElement to display this view in. 
  * @syntax   var outline = new OutlineLayout()
  */
-function OutlineLayout(inSectionView) {
-  Util.assert(inSectionView instanceof SectionView);
-
-  this.mySectionView = inSectionView;
-  this.myDivElement = null;
+OutlineLayout.prototype = new View();  // makes OutlineLayout be a subclass of View
+function OutlineLayout(inSectionView, inDivElement) {
+  this.setSuperview(inSectionView);
+  this.setDivElement(inDivElement);
 }
 
 
@@ -69,43 +70,35 @@
 
   
 /**
- * Tells the OutlineLayout what HTMLDivElement to display the bar chart in.
+ * Re-creates all the HTML for the OutlineLayout, and hands the HTML to the 
+ * browser to be re-drawn.
  *
  * @scope    public instance method
- * @param    inDivElement    The HTMLDivElement to display the bar chart in. 
  */
-OutlineLayout.prototype.setDivElement = function (inDivElement) {
-  Util.assert(inDivElement instanceof HTMLDivElement);
-
-  this.myDivElement = inDivElement;
+OutlineLayout.prototype.refresh = function () {
+  var listOfContentItems = this.getSuperview().getListOfContentItems();
+  var outlineDiv = this.getDivElement();
+  var ulElement = View.createAndAppendElement(outlineDiv, &quot;ul&quot;);
+  for (var contentItemKey in listOfContentItems) {
+    var contentItem = listOfContentItems[contentItemKey];
+    var liElement = View.createAndAppendElement(ulElement, &quot;li&quot;);
+    View.createAndAppendTextNode(liElement, contentItem.getDisplayName(&quot;{no name}&quot;) + &quot; &quot;);
+    var anchorElement = View.createAndAppendElement(liElement, &quot;a&quot;, SectionView.ELEMENT_CLASS_MORE_LINK);
+    anchorElement.setAttribute(&quot;href&quot;, RootView.URL_HASH_ITEM_PREFIX + contentItem.getUuid());
+    // View.createAndAppendTextNode(anchorElement, &quot;(more &#8658;)&quot;);
+    anchorElement.innerHTML = &quot;(more &#8658;)&quot;;
+    Util.addEventListener(anchorElement, &quot;click&quot;, RootView.clickOnLocalLink);
+  }
 };
 
 
 /**
- * Re-creates all the HTML for the OutlineLayout, and hands the HTML to the 
- * browser to be re-drawn.
+ * Does final clean-up.
  *
  * @scope    public instance method
  */
-OutlineLayout.prototype.display = function () {
-  var listOfStrings = [];
-
-  var listOfContentItems = this.mySectionView.getListOfContentItems();
-  listOfStrings.push(&quot;&lt;ul&gt;&quot;);
-  // for each content item, add its HTML representation to the output
-  for (var contentItemKey in listOfContentItems) {
-    var contentItem = listOfContentItems[contentItemKey];
-    listOfStrings.push(&quot;&lt;li&gt;&quot;);
-    listOfStrings.push(contentItem.getDisplayName(&quot;{no name}&quot;));
-    // PROBLEM: Why do I have to provide an onclick handler to get these links to work?
-    listOfStrings.push(&quot; &quot; + &quot;&lt;a class=\&quot;&quot; + SectionView.ELEMENT_CLASS_MORE_LINK + &quot;\&quot; href=\&quot;&quot; + RootView.URL_HASH_ITEM_PREFIX + contentItem.getUuid() + &quot;\&quot; onclick=\&quot;RootView.clickOnLocalLink(event)\&quot;&gt;(more &#8658;)&lt;/a&gt;&quot; + &quot;&quot;);
-    listOfStrings.push(&quot;&lt;/li&gt;&quot;);
-  }
-  listOfStrings.push(&quot;&lt;/ul&gt;&quot;);
-
-  // take all the HTML and put it together
-  var finalString = listOfStrings.join(&quot;&quot;);
-  this.myDivElement.innerHTML = finalString;
+OutlineLayout.prototype.endOfLife = function () {
+  this.getDivElement().innerHTML = &quot;&quot;;
 };
 
 

Modified: trunk/source/rectangle.js
===================================================================
--- trunk/source/rectangle.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/rectangle.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -30,7 +30,7 @@
 //    + accessor methods are prefixed with &quot;get&quot; or &quot;is&quot; -- e.g. oval.getArea(), oval.isCircle()
 //       + any method that returns a value and does not change an object's state should be a &quot;get&quot; or &quot;is&quot; method
 //       + any method that does change an object's state should be a &quot;set&quot; method
-//    + problems are marked with PROBLEM
+//    + problems are marked with PENDING
 //
 // + compatiblity with other browsers and other JavaScript libraries 
 //    + use &quot;get&quot; and &quot;set&quot; accessors -- do *not* assign Mozilla &quot;getter&quot; and &quot;setter&quot; methods
@@ -54,7 +54,7 @@
 //    + instance methods are defined on the prototype -- see getArea()
 //    + accessor methods never have side-effects
 //
-// + PROBLEM
+// + PENDING
 //    + private instance properties?
 //    + private instance methods?
 //    + class methods?

Modified: trunk/source/root_view.js
===================================================================
--- trunk/source/root_view.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/root_view.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -262,10 +262,9 @@
 
   // add event handlers for the newly created control span UI elements
   var editButton = document.getElementById(this.myEditButtonId);
-  editButton.onclick = RootView.clickOnEditButton;
- 
-  // attach back-pointers to the newly created control span UI elements
-  editButton.myrootview = this;
+  var listener = this;
+  Util.addEventListener(editButton, &quot;click&quot;,
+    function(event) { listener.clickOnEditButton(event);});
 };
 
 
@@ -401,14 +400,21 @@
  * @param    inEventObject    An event object. 
  */
 RootView.clickOnLocalLink = function (inEventObject) {
-  var eventObject = inEventObject;
-  if (!eventObject) { eventObject = window.event; }
+  var eventObject = inEventObject || window.event;
   
   var startTiming = new Date();
+  
+  // &quot;wait&quot;, &quot;auto&quot;, &quot;default&quot;, &quot;crosshair&quot;, &quot;help&quot;
+  // &quot;n-resize&quot;, &quot;s-resize&quot;, &quot;e-resize&quot;, &quot;w-resize&quot;
+  // &quot;ne-resize&quot;, &quot;se-resize&quot;, &quot;nw-resize&quot;, &quot;sw-resize&quot;
+  // window.document.body.style.cursor = &quot;wait&quot;;
+
   var htmlAnchorElement = Util.getTargetFromEvent(eventObject);
   
   window.location = htmlAnchorElement.href;
   RootView.ourSingleInstance.setCurrentContentViewFromUrl();
+
+  // window.document.body.style.cursor = &quot;default&quot;;
   
   var stopTiming = new Date();
   var delayInMilliseconds = stopTiming.getTime() - startTiming.getTime();
@@ -422,27 +428,22 @@
  * Called from an HTML &quot;input type='button'&quot; element on the generated page.  
  * There is no need to call this method directly.
  *
- * @scope    public class method
+ * @scope    public instance method
  * @param    inEventObject    An event object. 
  */
-RootView.clickOnEditButton = function (inEventObject) {
-  var eventObject = inEventObject;
-  if (!eventObject) { eventObject = window.event; }
-  var editButton = Util.getTargetFromEvent(eventObject);
-  // PROBLEM: We could replace the lines above with &quot;var editButton = this;&quot;
-  // That would work fine in Firefox, but maybe it wouldn't work in other browsers?  
-
-  var rootView = editButton.myrootview;
-  var stevedore = rootView.getStevedore();
-  if (rootView.myEditMode) {
+RootView.prototype.clickOnEditButton = function (inEventObject) {
+  var stevedore = this.getStevedore();
+  if (this.myEditMode) {
     stevedore.endTransaction();
+    window.document.body.style.cursor = &quot;auto&quot;;
   } else {
     stevedore.beginTransaction();
+    window.document.body.style.cursor = &quot;crosshair&quot;;
   }
-  rootView.myEditMode = !rootView.myEditMode;
-  rootView.display();
-  // rootView.displayTextInDebugTextarea(rootView.myEditMode);
-  if (!rootView.myEditMode &amp;&amp; window.location &amp;&amp; (window.location.protocol == &quot;file:&quot;)) {
+  this.myEditMode = !this.myEditMode;
+  this.display();
+  // this.displayTextInDebugTextarea(this.myEditMode);
+  if (!this.myEditMode &amp;&amp; window.location &amp;&amp; (window.location.protocol == &quot;file:&quot;)) {
     RootView.displayTextInDebugTextarea(stevedore._getJsonStringRepresentingAllItems());
   }
 };

Modified: trunk/source/section_view.js
===================================================================
--- trunk/source/section_view.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/section_view.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -93,15 +93,15 @@
   Util.assert(inSection instanceof Item);
   
   // instance properties
-  // PROBLEM: these should all be private
+  // PENDING: these should all be private
   this.setSuperview(inPageView);
   this.setDivElement(inDivElement);
   this.mySection = inSection;
   this.mySectionNumber = inSectionNumber;
   var query = inSection.getValueListFromAttribute(Stevedore.UUID_FOR_ATTRIBUTE_QUERY)[0];
   this.myListOfContentItems = this.getStevedore().getListOfResultItemsForQuery(query); 
-  var layoutName = inSection.getValueListFromAttribute(Stevedore.UUID_FOR_ATTRIBUTE_LAYOUT_NAME)[0];
-  this.myLayout = this.getLayoutFromLayoutName(layoutName);
+
+  this._myLayout = null;
   this._myLayoutDiv = null;
   this._myHasEverBeenDisplayedFlag = false;
   this._mySectionSummaryView = null;
@@ -138,19 +138,20 @@
 /**
  * Given the name of a layout (&quot;Table&quot;, &quot;Outline&quot;, etc.), returns a newly
  * created layout object of that type, initialized to be the layout for this 
- * section
+ * SectionView.
  *
  * @scope    public instance method
  * @param    inLayoutName    A string. One of the registered layout names. 
+ * @param    inLayoutDiv    The HTMLDivElement to display the layout in. 
  * @return   A newly created layout object, initialized to be the layout for this section.
  */
-SectionView.prototype.getLayoutFromLayoutName = function (inLayoutName) {
+SectionView.prototype.getLayoutFromLayoutName = function (inLayoutName, inLayoutDiv) {
   Util.assert(Util.isString(inLayoutName));
   
   var newLayout = null;
   var layoutClass = SectionView.ourHashTableOfLayoutClassesKeyedByLayoutName[inLayoutName];
   if (layoutClass) {
-    newLayout = new layoutClass(this);
+    newLayout = new layoutClass(this, inLayoutDiv);
   }
   return newLayout;
 };
@@ -181,8 +182,7 @@
   } else {
     // refresh the &lt;h2&gt; element with the value: this.mySection.getDisplayName();  
     this._mySectionSummaryView.refresh();
-    this.myLayout.setDivElement(this._myLayoutDiv);
-    this.myLayout.display();
+    this._myLayout.refresh();
   }
 };
 
@@ -197,6 +197,7 @@
   if (!this.getDivElement()) {
     return;
   }
+  var selectedLayoutName = this.mySection.getValueListFromAttribute(Stevedore.UUID_FOR_ATTRIBUTE_LAYOUT_NAME)[0];
   var query = this.mySection.getValueListFromAttribute(Stevedore.UUID_FOR_ATTRIBUTE_QUERY)[0];
   this.myListOfContentItems = this.getStevedore().getListOfResultItemsForQuery(query); 
   if (!this.myListOfContentItems) {
@@ -216,18 +217,19 @@
   var selectElement = View.createAndAppendElement(outerDiv, &quot;select&quot;, SectionView.ELEMENT_CLASS_SECTION_LAYOUT_MENU, selectMenuId);
   selectElement.setAttribute(&quot;name&quot;, selectMenuId);
   selectElement.setAttribute(SectionView.ELEMENT_ATTRIBUTE_SECTION_NUMBER, this.mySectionNumber);
-  selectElement.mysectionview = this;
   for (var layoutName in SectionView.ourHashTableOfLayoutClassesKeyedByLayoutName) {
     var optionElement = View.createAndAppendElement(selectElement, &quot;option&quot;);
-    optionElement.selected = (this.myLayout.getLayoutName() == layoutName);
+    optionElement.selected = (selectedLayoutName == layoutName);
     optionElement.setAttribute(&quot;value&quot;, layoutName);
-    optionElement.setAttribute(&quot;onclick&quot;, &quot;SectionView.clickOnLayoutSelectionMenu(event)&quot;);
+    // Util.addEventListener(optionElement, &quot;click&quot;, SectionView.clickOnLayoutSelectionMenu);
+    var listener = this; 
+    Util.addEventListener(optionElement, &quot;click&quot;, function(event) {listener.clickOnLayoutSelectionMenu(event);});
     optionElement.innerHTML = layoutName;
   }
 
   // create a div element for the layout class to use
   this._myLayoutDiv = View.createAndAppendElement(outerDiv, &quot;div&quot;);
-  this.myLayout.setDivElement(this._myLayoutDiv);
+  this._myLayout = this.getLayoutFromLayoutName(selectedLayoutName, this._myLayoutDiv);
   this._myHasEverBeenDisplayedFlag = true;
   this.refresh();
 };
@@ -241,31 +243,27 @@
  * Called when the user clicks on any of the layout option-select controls.
  * Called from an HTML option element within an HTML select element.
  *
- * @scope    public class method
+ * @scope    public instance method
  * @param    inEventObject    An event object. 
  */
-SectionView.clickOnLayoutSelectionMenu = function (inEventObject) {
-  var eventObject = inEventObject;
-  if (!eventObject) { eventObject = window.event; }
+SectionView.prototype.clickOnLayoutSelectionMenu = function (inEventObject) {
+  var eventObject = inEventObject || window.event;
   var optionElement = Util.getTargetFromEvent(eventObject);
-  // PROBLEM: We could replace the lines above with &quot;var optionElement = this;&quot;
+  // PENDING: We could replace the lines above with &quot;var optionElement = this;&quot;
   // That would work fine in Firefox, but maybe it wouldn't work in other browsers?  
   
   var selectElement = optionElement.parentNode;
   var newChoiceName = optionElement.value;
-  
-  var sectionView = selectElement.mysectionview;
-  
-  if (sectionView.myLayout.getLayoutName() == newChoiceName) {
-    // alert(&quot;line 213&quot;);
+
+ 
+  if (this._myLayout.getLayoutName() == newChoiceName) {
     return;
   } else {
-    // alert(&quot;line 216&quot;);
-    sectionView.myLayout = sectionView.getLayoutFromLayoutName(newChoiceName);
-    sectionView.mySection.clear(Stevedore.UUID_FOR_ATTRIBUTE_LAYOUT_NAME);
-    sectionView.mySection.assign(Stevedore.UUID_FOR_ATTRIBUTE_LAYOUT_NAME, newChoiceName);
-  
-    sectionView.refresh();
+    this._myLayout.endOfLife();
+    this._myLayout = this.getLayoutFromLayoutName(newChoiceName, this._myLayoutDiv);
+    this.mySection.clear(Stevedore.UUID_FOR_ATTRIBUTE_LAYOUT_NAME);
+    this.mySection.assign(Stevedore.UUID_FOR_ATTRIBUTE_LAYOUT_NAME, newChoiceName);
+    this.refresh();
   }
 };
 

Modified: trunk/source/stevedore.js
===================================================================
--- trunk/source/stevedore.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/stevedore.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -299,7 +299,7 @@
  */
 Stevedore.prototype.beginTransaction = function () {
   this._myCountOfNestedTransactions += 1;
-  // PROBLEM:
+  // PENDING:
   //   This is just a stub method for now.  Once we start implementing
   //   support for transactions we'll have to put some real code here.
 };
@@ -313,7 +313,7 @@
 Stevedore.prototype.endTransaction = function () {
   this._myCountOfNestedTransactions -= 1;
   Util.assert(this._myCountOfNestedTransactions &gt;= 0);
-  // PROBLEM:
+  // PENDING:
   //   This is just a stub method for now.  Once we start implementing
   //   support for transactions we'll have to put some real code here.
   if (this._myCountOfNestedTransactions === 0) {
@@ -487,7 +487,7 @@
     }
   }
   
-  // PROBLEM:
+  // PENDING:
   // If we don't have a designated &quot;home page&quot; for this data set, then just
   // look through all the items and set the home page to be the first page 
   // item we come across.  This, of course, is a hack.

Modified: trunk/source/table_layout.js
===================================================================
--- trunk/source/table_layout.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/table_layout.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -54,13 +54,10 @@
  * When the TableLayout creates an HTML table, it sets up each HTML &quot;td&quot; table 
  * cell element in the table to point to a corresponding CellDelegate instance.
  *
- * PROBLEM: This CellDelegate class should be privately owned by the
- * TableLayout class.
- *
- * @scope    public instance constructor
+ * @scope    private instance constructor
  */
-function _CellDelegate(inRowDelegate, inCellElementId, inCellCount, inColumnNumber, inAttribute, inTableLayout) {
-  Util.assert(inRowDelegate instanceof _RowDelegate);
+TableLayout._CellDelegate = function (inRowDelegate, inCellElementId, inCellCount, inColumnNumber, inAttribute, inTableLayout) {
+  Util.assert(inRowDelegate instanceof TableLayout._RowDelegate);
   Util.assert(inAttribute instanceof Item);
   Util.assert(inTableLayout instanceof TableLayout);
 
@@ -77,12 +74,9 @@
  * When the TableLayout creates an HTML table, it sets up each HTML &quot;tr&quot; table
  * row element in the table to point to a corresponding RowDelegate instance.
  *
- * PROBLEM: This RowDelegate class should be privately owned by the
- * TableLayout class.
- *
- * @scope    public instance constructor
+ * @scope    private instance constructor
  */
-function _RowDelegate(inContentItem, inRowNumber) {
+TableLayout._RowDelegate = function (inContentItem, inRowNumber) {
   Util.assert((inContentItem == null) || (inContentItem instanceof Item));
 
   this.myContentItem = inContentItem;
@@ -96,13 +90,15 @@
  * HTML table.
  *
  * @scope    public instance constructor
+ * @extends  View
  * @param    inSectionView    The SectionView that this TableLayout will appears in. 
+ * @param    inDivElement    The HTMLDivElement to display this view in. 
  */
-function TableLayout(inSectionView) {
-  Util.assert(inSectionView instanceof SectionView);
+TableLayout.prototype = new View();  // makes TableLayout be a subclass of View
+function TableLayout(inSectionView, inDivElement) {
+  this.setSuperview(inSectionView);
+  this.setDivElement(inDivElement);  
 
-  this.mySectionView = inSectionView;
-  this.myDivElement = null;
   this.myNumColumns = null;
   this.myNumRows = null;
   this.myArrayOfRowDelegates = new Array();
@@ -122,27 +118,12 @@
 
   
 /**
- * Gives the TableLayout a place on the page to put HTML code, allowing
- * the TableLayout to display itself.
- *
- * @scope    public instance method
- * @param    inDivElement    The HTMLDivElement that this layout should display itself in. 
- */
-TableLayout.prototype.setDivElement = function (inDivElement) {
-  Util.assert(inDivElement instanceof HTMLDivElement);
-
-  this.myDivElement = inDivElement;
-  this.display();
-};
-
-
-/**
  * Re-creates all the HTML for the TableLayout, and hands the HTML to the 
  * browser to be re-drawn.
  *
  * @scope    public instance method
  */
-TableLayout.prototype.display = function () {
+TableLayout.prototype.refresh = function () {
   var listOfStrings = [];
   var hashTableOfAttributesKeyedByUuid = {};
   var hashTableOfCellDelegatesKeyedByElementId = {};
@@ -152,14 +133,15 @@
   var columnCount = 0;
   
   // find the union of the attribute lists of all the content items
-  var listOfContentItems = this.mySectionView.getListOfContentItems();
+  // PENDING: how do we know our superview responds to getListOfContentItems()? 
+  var listOfContentItems = this.getSuperview().getListOfContentItems();
   for (var iKey in listOfContentItems) {
     contentItem = listOfContentItems[iKey];
     var listOfAttributesForItem = contentItem.getListOfAttributeUuids();
     for (var attributeKey in listOfAttributesForItem) {
       attributeUuid = listOfAttributesForItem[attributeKey];
       if (attributeUuid != Stevedore.UUID_FOR_ATTRIBUTE_CATEGORY) {
-        hashTableOfAttributesKeyedByUuid[attributeUuid] = this.mySectionView.getStevedore().getItemFromUuid(attributeUuid);
+        hashTableOfAttributesKeyedByUuid[attributeUuid] = this.getStevedore().getItemFromUuid(attributeUuid);
       }
     }
   }
@@ -177,13 +159,13 @@
   
   // add all the table body rows
   var cellCount = 0;
-  var cellIdPrefix = SectionView.ELEMENT_ID_CELL_PREFIX + this.mySectionView.mySectionNumber + SectionView.ELEMENT_ID_CELL_MIDFIX;
+  var cellIdPrefix = SectionView.ELEMENT_ID_CELL_PREFIX + this.getSuperview().mySectionNumber + SectionView.ELEMENT_ID_CELL_MIDFIX;
   var cellId = &quot;&quot;;
   this.myNumRows = 0;
   for (var kKey in listOfContentItems) {
     contentItem = listOfContentItems[kKey];
     listOfStrings.push(&quot;&lt;tr&gt;&quot;);
-    var rowDelegate = new _RowDelegate(contentItem, this.myNumRows);
+    var rowDelegate = new TableLayout._RowDelegate(contentItem, this.myNumRows);
     this.myArrayOfRowDelegates[this.myNumRows] = rowDelegate;
     this.myNumRows += 1;
     columnCount = 0;
@@ -196,9 +178,9 @@
       if (valueList) {
         string = SectionView.getStringForValue(valueList[0]);
       }
-      if (this.mySectionView.isInEditMode()) {
-        listOfStrings.push(&quot;&lt;td class=\&quot;&quot; + SectionView.ELEMENT_CLASS_PLAIN + &quot;\&quot; id=\&quot;&quot; + cellId + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_SECTION_NUMBER + &quot;=\&quot;&quot; + this.mySectionView.mySectionNumber + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_CELL_NUMBER + &quot;=\&quot;&quot; + cellCount + &quot;\&quot; onclick=\&quot;TableLayout.clickOnCell(event)\&quot;&gt;&quot; + string + &quot;&lt;/td&gt;&quot;);
-        var cellDelegate = new _CellDelegate(rowDelegate, cellId, cellCount, columnCount, attribute, this);
+      if (this.isInEditMode()) {
+        listOfStrings.push(&quot;&lt;td class=\&quot;&quot; + SectionView.ELEMENT_CLASS_PLAIN + &quot;\&quot; id=\&quot;&quot; + cellId + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_SECTION_NUMBER + &quot;=\&quot;&quot; + this.getSuperview().mySectionNumber + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_CELL_NUMBER + &quot;=\&quot;&quot; + cellCount + &quot;\&quot; onclick=\&quot;TableLayout.clickOnCell(event)\&quot;&gt;&quot; + string + &quot;&lt;/td&gt;&quot;);
+        var cellDelegate = new TableLayout._CellDelegate(rowDelegate, cellId, cellCount, columnCount, attribute, this);
         rowDelegate.myArrayOfCellDelegates[columnCount] = cellDelegate;
         hashTableOfCellDelegatesKeyedByElementId[cellId] = cellDelegate;
       } else {
@@ -214,10 +196,10 @@
 
   // if we're in edit mode, add a row at the bottom of the table for entering new items
   var firstCell = true;
-  var lastRowDelegate = new _RowDelegate(null, this.myNumRows);
+  var lastRowDelegate = new TableLayout._RowDelegate(null, this.myNumRows);
   this.myArrayOfRowDelegates[this.myNumRows] = lastRowDelegate;
   this.myNumRows += 1;
-  if (this.mySectionView.isInEditMode()) {
+  if (this.isInEditMode()) {
     listOfStrings.push(&quot;&lt;tr&gt;&quot;);
     columnCount = 0;
     for (var mKey in hashTableOfAttributesKeyedByUuid) {
@@ -226,8 +208,8 @@
       firstCell = false;
       cellCount += 1;
       cellId = cellIdPrefix + cellCount;
-      listOfStrings.push(&quot;&lt;td class=\&quot;&quot; + SectionView.ELEMENT_CLASS_NEW_ITEM + &quot;\&quot; id=\&quot;&quot; + cellId + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_SECTION_NUMBER + &quot;=\&quot;&quot; + this.mySectionView.mySectionNumber + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_CELL_NUMBER + &quot;=\&quot;&quot; + cellCount + &quot;\&quot; onclick=\&quot;TableLayout.clickOnCell(event)\&quot;&gt;&quot; + contentString + &quot;&lt;/td&gt;&quot;);
-      var lastRowCellDelegate = new _CellDelegate(lastRowDelegate, cellId, cellCount, columnCount, attribute, this);
+      listOfStrings.push(&quot;&lt;td class=\&quot;&quot; + SectionView.ELEMENT_CLASS_NEW_ITEM + &quot;\&quot; id=\&quot;&quot; + cellId + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_SECTION_NUMBER + &quot;=\&quot;&quot; + this.getSuperview().mySectionNumber + &quot;\&quot; &quot; + SectionView.ELEMENT_ATTRIBUTE_CELL_NUMBER + &quot;=\&quot;&quot; + cellCount + &quot;\&quot; onclick=\&quot;TableLayout.clickOnCell(event)\&quot;&gt;&quot; + contentString + &quot;&lt;/td&gt;&quot;);
+      var lastRowCellDelegate = new TableLayout._CellDelegate(lastRowDelegate, cellId, cellCount, columnCount, attribute, this);
       lastRowDelegate.myArrayOfCellDelegates[columnCount] = lastRowCellDelegate;
       hashTableOfCellDelegatesKeyedByElementId[cellId] = lastRowCellDelegate;
       columnCount += 1;
@@ -240,7 +222,7 @@
   
   // write out all the new content   
   var finalString = listOfStrings.join(&quot;&quot;);
-  this.myDivElement.innerHTML = finalString;
+  this.getDivElement().innerHTML = finalString;
   
   // attach back-pointers to the newly created UI elements
   for (var elementId in hashTableOfCellDelegatesKeyedByElementId) {
@@ -252,6 +234,16 @@
   
 
 /**
+ * Does final clean-up.
+ *
+ * @scope    public instance method
+ */
+TableLayout.prototype.endOfLife = function () {
+  this.getDivElement().innerHTML = &quot;&quot;;
+};
+
+
+/**
  * Called when the user clicks on a table cell.
  * 
  * Called from an HTML &quot;td&quot; element on the generated page.  There is no need
@@ -262,10 +254,10 @@
 TableLayout.clickOnCell = function (inEventObject) {
   var eventObject = inEventObject;
   if (!eventObject) { eventObject = window.event; } 
-  // PROBLEM: try this instead: var eventObject = inEventObject || window.event;
+  // PENDING: try this instead: var eventObject = inEventObject || window.event;
   
   var htmlElement = Util.getTargetFromEvent(eventObject);
-  // PROBLEM: We could replace the two lines above with &quot;var htmlElement = this;&quot;
+  // PENDING: We could replace the two lines above with &quot;var htmlElement = this;&quot;
   // That would work fine in Firefox, but maybe it wouldn't work in other browsers?
 
   var currentEditField = document.getElementById(TableLayout.ELEMENT_ID_CURRENT_EDIT_FIELD);
@@ -308,7 +300,9 @@
   var editFieldString = &quot;&lt;input type=\&quot;text\&quot; class=\&quot;&quot; + SectionView.ELEMENT_CLASS_TEXT_FIELD_IN_TABLE_CELL + &quot;\&quot; id=\&quot;&quot; + TableLayout.ELEMENT_ID_CURRENT_EDIT_FIELD + &quot;\&quot; value=\&quot;&quot; + initialEditValue + &quot;\&quot; size=\&quot;1\&quot;&gt;&lt;/input&gt;&quot;;
   inCellElement.innerHTML = editFieldString;
   inCellElement.className = SectionView.ELEMENT_CLASS_SELECTED + &quot; &quot; + inCellElement.className;
-  
+  // var listener = this; 
+  // Util.addEventListener(editField, &quot;blur&quot;, function(event) {listener.onBlur(event);});
+      
   var newEditField = document.getElementById(TableLayout.ELEMENT_ID_CURRENT_EDIT_FIELD);
   newEditField.onkeypress = TableLayout.keyPressOnEditField;
   newEditField.select();
@@ -332,7 +326,7 @@
     // find the content item for this cell, and set the attribute to the new cell value
     var contentItem = cellDelegate.myRowDelegate.myContentItem;
     if (!contentItem) {
-      var sectionView = cellDelegate.myTableLayout.mySectionView;
+      var sectionView = cellDelegate.myTableLayout.getSuperview();
       var stevedore = sectionView.getStevedore();
       contentItem = stevedore.newItem(); 
       cellDelegate.myTableLayout.myNewItemCreatedFlag = true;
@@ -340,7 +334,7 @@
       var queryList = sectionView.mySection.getValueListFromAttribute(Stevedore.UUID_FOR_ATTRIBUTE_QUERY);
       if (queryList) {
         var query = queryList[0];
-        // PROBLEM: We should NOT get a value from the item's PRIVATE _myStevedore property
+        // PENDING: We should NOT get a value from the item's PRIVATE _myStevedore property
         contentItem._myStevedore.setItemToBeIncludedInQueryResultList(contentItem, query);
       }
     }
@@ -428,7 +422,7 @@
     if (move == MOVE_LEFT || move == MOVE_RIGHT) {
       shiftBy = (move == MOVE_LEFT) ? -1 : 1;
       var nextColumnNumber = cellDelegate.myColumnNumber + shiftBy;
-      // PROBLEM: We should be able to do this in one line, using a modulo operator
+      // PENDING: We should be able to do this in one line, using a modulo operator
       if (nextColumnNumber &lt; 0) {
         nextColumnNumber = (tableLayout.myNumColumns - 1);
       }
@@ -457,7 +451,7 @@
     TableLayout.leaveEditField();
     if (userHitReturnInLastRow &amp;&amp; tableLayout.myNewItemCreatedFlag) {
       tableLayout.myNewItemCreatedFlag = false;
-      tableLayout.display();
+      tableLayout.refresh();
       tableLayout.startEditingInCellForNewItemAtColumn(cellDelegate.myColumnNumber);
     } else {
       if (nextCell) {

Modified: trunk/source/test_page.js
===================================================================
--- trunk/source/test_page.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/test_page.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -42,11 +42,11 @@
  * @scope    global function
  */
 window.doOnloadActions = function() {  
-  Util.setTargetsForExternalLinks();
   
   var stevedore = new Stevedore();
   stevedore._loadItemsFromList(Stevedore._ourRepositoryInJsonFormat);
   window.rootView = new RootView(stevedore);
+  Util.setTargetsForExternalLinks();
 };
 
 

Modified: trunk/source/text_view.js
===================================================================
--- trunk/source/text_view.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/text_view.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -37,23 +37,31 @@
 // -------------------------------------------------------------------
 
 
+// -------------------------------------------------------------------
+// MultiLineTextView public class constants
+// -------------------------------------------------------------------
+MultiLineTextView.ELEMENT_CLASS_TEXT_BLOCK = &quot;text_block&quot;;
+
+
 /**
  * An instance of MultiLineTextView can be placed in any parent container View
  * to display and (if in edit mode) edit multi-lines of text
  *
  * @scope    public instance constructor
+ * @extends  View
  * @param    theSuperview    The view that this view is nested in. 
  * @param    theItem    The Item to be displayed and edited by this view. 
  * @param    theAttribute    The attribute of the item to be displayed.
  * @param    theDivElement    The HTMLDivElement to display the HTML in. 
  * @param    theClassType    A string that gives a class name to assign to the HTML element. 
  */
+MultiLineTextView.prototype = new View();  // makes MultiLineTextView be a subclass of View
 function MultiLineTextView(theSuperview, theDivElement, theItem, theAttribute, theClassType) {
   Util.assert(theItem instanceof Item);
-  //Util.assert(theAttribute instanceof Attribute); PROBLEM need to check that attribute is an attribute
-  //Util.assert(inDivElement instanceof HTMLDivElement);
+  //Util.assert(theAttribute instanceof Attribute); PENDING need to check that attribute is an attribute
   
-  this.mySuperview = theSuperview;
+  this.setSuperview(theSuperview);
+  this.setDivElement(theDivElement);
   this.textItem = theItem;
   this.attribute = theAttribute;
   this.editField = null;
@@ -61,41 +69,10 @@
   this.classType = theClassType;
   this.isEditing = false;
   this._myHasEverBeenDisplayedFlag = false;
-  this.setDivElement(theDivElement);
 };
 
 
 /**
- * Tells the MultiLineTextView what HTMLDivElement to display itself in.
- *
- * @scope    public instance method
- * @param    inDivElement    The HTMLDivElement to display in. 
- */
-MultiLineTextView.prototype.setDivElement = function(theDivElement) {
-  Util.assert(theDivElement instanceof HTMLDivElement);
-  this.divElement = theDivElement;
-  if (theDivElement) {
-    var listener = this;
-    theDivElement.addEventListener(&quot;click&quot;,
-      function(event) {listener.onClick(event)},
-      false);
-    this.refresh();
-  }
-};
-
-
-/**
- * Returns true if we are in Edit Mode.
- *
- * @scope    public instance method
- * @return   A boolean value. True if we are in Edit Mode.
- */
-MultiLineTextView.prototype.isInEditMode = function () {
-  return this.mySuperview.isInEditMode();
-};
-
-  
-/**
  * Updates the HTML elements in this view to reflect any changes in 
  * the item's attribute values.
  *
@@ -120,9 +97,10 @@
  * @scope    public instance method
  */
 MultiLineTextView.prototype.doInitialDisplay = function() {
-  if (!this.divElement) return;
-  Util.assert(this.divElement instanceof HTMLDivElement);
+  var divElement = this.getDivElement();
+  Util.assert(divElement instanceof HTMLDivElement);
   
+  divElement.className = MultiLineTextView.ELEMENT_CLASS_TEXT_BLOCK;
   var textList = this.textItem.getValueListFromAttribute(this.attribute);
   var textString = &quot;&quot;;
   for (var i in textList) {
@@ -130,7 +108,11 @@
   };
   
   this.textNode = document.createTextNode(textString);
-  this.divElement.appendChild(this.textNode);
+  divElement.appendChild(this.textNode);
+
+  var listener = this;
+  Util.addEventListener(divElement, &quot;click&quot;, function(event) { listener.onClick(event);});
+    
   this._myHasEverBeenDisplayedFlag = true;
 };
 
@@ -148,13 +130,11 @@
       editField.className = this.classType;
       //editField.cols=80; now using css style sheet &quot;text_view&quot;
       var listener = this; 
-      editField.addEventListener(&quot;blur&quot;,
-        function(evt) {listener.onBlur(evt)},
-        false);
+      Util.addEventListener(editField, &quot;blur&quot;, function(event) {listener.onBlur(event);});
       editField.defaultValue = this.textNode.data;
     }
-    editField.style.height = this.divElement.offsetHeight + &quot;px&quot;;
-    this.divElement.replaceChild(editField,this.textNode);
+    editField.style.height = this.getDivElement().offsetHeight + &quot;px&quot;;
+    this.getDivElement().replaceChild(editField, this.textNode);
     editField.focus();
     editField.select();
     this.isEditing = true;
@@ -175,7 +155,6 @@
  * @param    inEventObject    An event object. 
  */
 MultiLineTextView.prototype.onClick = function(inEventObject) {
-  inEventObject = inEventObject || window.event;
   if (this.isInEditMode()) {
     this.startEditing();
   }
@@ -195,9 +174,9 @@
   if (this.isEditing) {
     var newText = this.editField.value;
     this.textItem.clear(this.attribute);
-    this.textItem.assign(this.attribute,newText); //PROBLEM: need to deal with multi valued attrs
+    this.textItem.assign(this.attribute, newText); // PENDING: need to deal with multi valued attrs
     this.textNode.data = newText;
-    this.divElement.replaceChild(this.textNode,this.editField);
+    this.getDivElement().replaceChild(this.textNode, this.editField);
     this.isEditing = false;
   }
 };

Modified: trunk/source/util.js
===================================================================
--- trunk/source/util.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/util.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -43,6 +43,7 @@
  * @syntax   DO NOT CALL THIS CONSTRUCTOR
  */
 function Util() {
+  throw new Error(&quot;Util is a static class. You can't create instances of it.&quot;);
 }
 
 
@@ -254,7 +255,7 @@
  * @return   A boolean value. True if inValue is a hash table.
  */
 Util.isHashTable = function (inValue) {
-  return (inValue &amp;&amp; (typeof(inValue) == &quot;object&quot;));  // PROBLEM: we should be more restrictive!
+  return (inValue &amp;&amp; (typeof(inValue) == &quot;object&quot;));  // PENDING: we should be more restrictive!
 };
 
 
@@ -360,23 +361,26 @@
 
 
 /**
- * This function allows Views to register an event listener in an 
- * object-oriented manner, allowing a specific object's handleEvent() 
- * method to be called. 
+ * A cross-browser compatibility method for registering event listeners. 
  *
  * @scope public class method
  * @param inElement    An HTMLElement.
- * @param inEventtype    The type of event (e.g. &quot;mousedown&quot;, &quot;click&quot;).
- * @param inView    The object whose handleEvent() method is to be called.
+ * @param inEventType    The type of event (e.g. &quot;mousedown&quot;, &quot;click&quot;).
+ * @param inCallback    The function to call when the event happens.
  * @param inCaptures    True if the event should be captured by this function.
  */
-Util.registerObjectEventHandler = function(inElement, inEventtype, inView, inCaptures) {
-  inElement.addEventListener(inEventtype,
-    function(event) { inView.handleEvent(event);},
-    inCaptures);
+Util.addEventListener = function (inElement, inEventType, inCallback, inCaptures) {
+  if (inElement.addEventListener) {
+    // for DOM Level 2 browsers, like Firefox
+    inElement.addEventListener(inEventType, inCallback, inCaptures);
+  } else {
+    if (inElement.attachEvent) {
+      // for Internet Explorer
+      inElement.attachEvent(&quot;on&quot;+inEventType, inCallback, inCaptures);
+    }
+  } 
 };
 
-
 // -------------------------------------------------------------------
 // HTML document manipulation
 // -------------------------------------------------------------------
@@ -393,13 +397,10 @@
     return;
   }
   var listOfAnchorElements = window.document.getElementsByTagName(&quot;a&quot;);
+  var regExp = new RegExp(&quot;\\b&quot; + &quot;external&quot; + &quot;\\b&quot;);
   for (var i=0; i&lt;listOfAnchorElements.length; i+=1) {
     var anchor = listOfAnchorElements[i];
-    // PROBLEM: This only works if the &quot;rel&quot; attribute has a single value == &quot;external&quot;.
-    // To make it work with multi-valued rel attributes, we should do some regular
-    // expression matching to check for strings like &quot;external&quot;, &quot;foo external&quot;, 
-    // and &quot;external foo&quot;.
-    if (anchor.getAttribute(&quot;href&quot;) &amp;&amp; (anchor.getAttribute(&quot;rel&quot;) == &quot;external&quot;)) {
+    if (anchor.getAttribute(&quot;href&quot;) &amp;&amp; (anchor.getAttribute(&quot;rel&quot;)) &amp;&amp; (anchor.getAttribute(&quot;rel&quot;).search(regExp) != -1)) {
       anchor.target = &quot;_blank&quot;;
     }
   }

Modified: trunk/source/view.js
===================================================================
--- trunk/source/view.js	2005-04-03 03:53:21 UTC (rev 19)
+++ trunk/source/view.js	2005-04-05 05:02:08 UTC (rev 20)
@@ -172,6 +172,26 @@
 };
 
 
+/**
+ * Given an HTML element, we first call document.createTextNode() to 
+ * create a new text node, and then call appendChild() to add the new 
+ * text node to the given element.
+ *
+ * @scope    public class method
+ * @param    inElement    The existing element that we should append the new element to. 
+ * @param    inText    The text string to put in the text node.
+ * @return   The newly created text node.
+ */
+View.createAndAppendTextNode = function (inElement, inText) {
+  Util.assert(inElement instanceof HTMLElement);
+  Util.assert(Util.isString(inText));
+
+  var newTextNode = window.document.createTextNode(inText);
+  inElement.appendChild(newTextNode);
+  return newTextNode;
+};
+
+
 // -------------------------------------------------------------------
 // End of file
 // -------------------------------------------------------------------


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000013.html">[openrecord-svn] r15 - trunk/source
</A></li>
	<LI>Next message: <A HREF="000015.html">[openrecord-svn] r21 - trunk/source
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openrecord-svn">More information about the openrecord-svn
mailing list</a><br>
</body></html>
