<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openrecord-svn] r347 - in trunk: source source/archive source/model source/storage tests tests/archive tests/model tests/storage tests/util
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openrecord-svn/2005-October/index.html" >
   <LINK REL="made" HREF="mailto:openrecord-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-svn%5D%20r347%20-%20in%20trunk%3A%20source%20source/archive%20source/model%20source/storage%20tests%20tests/archive%20tests/model%20tests/storage%20tests/util&In-Reply-To=%3C200510040134.j941Y6sZ022189%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000329.html">
   <LINK REL="Next"  HREF="000331.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openrecord-svn] r347 - in trunk: source source/archive source/model source/storage tests tests/archive tests/model tests/storage tests/util</H1>
    <B>Brian Douglas Skinner at BerliOS</B> 
    <A HREF="mailto:openrecord-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-svn%5D%20r347%20-%20in%20trunk%3A%20source%20source/archive%20source/model%20source/storage%20tests%20tests/archive%20tests/model%20tests/storage%20tests/util&In-Reply-To=%3C200510040134.j941Y6sZ022189%40sheep.berlios.de%3E"
       TITLE="[openrecord-svn] r347 - in trunk: source source/archive source/model source/storage tests tests/archive tests/model tests/storage tests/util">skinner at berlios.de
       </A><BR>
    <I>Tue Oct  4 03:34:06 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000329.html">[openrecord-svn] r346 - trunk/documentation
</A></li>
        <LI>Next message: <A HREF="000331.html">[openrecord-svn] r348 - in trunk: source/storage tests/storage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#330">[ date ]</a>
              <a href="thread.html#330">[ thread ]</a>
              <a href="subject.html#330">[ subject ]</a>
              <a href="author.html#330">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: skinner
Date: 2005-10-04 03:33:56 +0200 (Tue, 04 Oct 2005)
New Revision: 347

Added:
   trunk/source/archive/
   trunk/source/archive/DeltaArchive.js
   trunk/source/archive/StubArchive.js
   trunk/source/storage/
   trunk/source/storage/FileStorage.js
   trunk/source/storage/HttpStorage.js
   trunk/source/storage/append_to_repository_file.php
   trunk/source/storage/write_to_repository_file.php
   trunk/tests/archive/
   trunk/tests/archive/LintTest.html
   trunk/tests/archive/LintTest.js
   trunk/tests/storage/
   trunk/tests/storage/LintTest.html
   trunk/tests/storage/LintTest.js
Removed:
   trunk/source/model/DeltaVirtualServer.js
   trunk/source/model/FileSaver.js
   trunk/source/model/HttpSaver.js
   trunk/source/model/StubVirtualServer.js
   trunk/source/model/append_to_repository_file.php
   trunk/source/model/write_to_repository_file.php
Modified:
   trunk/source/model/World.js
   trunk/tests/TestSuite.html
   trunk/tests/model/LintTest.js
   trunk/tests/model/ModelTest.js
   trunk/tests/model/RepositoryWritingTest.js
   trunk/tests/model/TestReorderingForSpecialCases.js
   trunk/tests/model/TestReorderingForTypicalOrdinals.js
   trunk/tests/util/XmlConverterMultiplePassesTest.js
   trunk/tests/util/XmlConverterTest.js
Log:
Moved a half dozen files out of the &quot;model&quot; directory and into the new &quot;storage&quot; and &quot;archive&quot; directories.  Renamed the files that got moved.  Created corresponding unit test directories.  Got all the code working again.

Copied: trunk/source/archive/DeltaArchive.js (from rev 345, trunk/source/model/DeltaVirtualServer.js)
===================================================================
--- trunk/source/model/DeltaVirtualServer.js	2005-09-28 07:24:38 UTC (rev 345)
+++ trunk/source/archive/DeltaArchive.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,498 @@
+/*****************************************************************************
+ DeltaArchive.js
+ 
+******************************************************************************
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+  
+ You can copy freely from this file.  This work may be freely reproduced, 
+ distributed, transmitted, used, modified, built upon, or otherwise exploited
+ by anyone for any purpose.
+  
+ This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
+ of any kind, either express or implied, including, without limitation, any 
+ warranties or conditions of title, non-infringement, merchantability, or 
+ fitness for a particular purpose. You are solely responsible for determining 
+ the appropriateness of using or distributing the work and assume all risks 
+ associated with use of this work, including but not limited to the risks and 
+ costs of errors, compliance with applicable laws, damage to or loss of data 
+ or equipment, and unavailability or interruption of operations.
+
+ In no event shall the authors or contributors have any liability for any 
+ direct, indirect, incidental, special, exemplary, or consequential damages,
+ however caused and on any theory of liability, whether in contract, strict 
+ liability, or tort (including negligence), arising in any way out of or in 
+ connection with the use or distribution of the work.
+*****************************************************************************/
+
+
+// -------------------------------------------------------------------
+// Provides and Requires
+// -------------------------------------------------------------------
+dojo.provide(&quot;orp.archive.DeltaArchive&quot;);
+dojo.require(&quot;orp.archive.StubArchive&quot;);
+dojo.require(&quot;orp.model.World&quot;);
+dojo.require(&quot;orp.model.Vote&quot;);
+dojo.require(&quot;orp.storage.FileStorage&quot;);
+dojo.require(&quot;orp.storage.HttpStorage&quot;);
+dojo.require(&quot;orp.lang.Lang&quot;);
+
+// -------------------------------------------------------------------
+// Dependencies, expressed in the syntax that JSLint understands:
+// 
+/*global window */
+/*global XMLHttpRequest, ActiveXObject  */
+/*global Util, DateValue  */
+/*global World, Item, Entry, Ordinal, Vote  */
+// -------------------------------------------------------------------
+
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+/**
+ * The DeltaArchive is a datastore that loads and saves
+ * an entire World of items as a single monolithic JSON string.
+ *
+ * @scope    public instance constructor
+ * @param    inJsonRepositoryString    A JSON string literal representing the world of items. 
+ */
+orp.archive.DeltaArchive = function(repositoryName, pathToTrunkDirectory, optionalDefaultOverrides) {
+  orp.archive.StubArchive.call(this, pathToTrunkDirectory, optionalDefaultOverrides);
+  this._repositoryName = repositoryName;
+  this._pathToTrunkDirectory = &quot;&quot;;
+  if (pathToTrunkDirectory) {
+    this._pathToTrunkDirectory = pathToTrunkDirectory;
+  }
+  this._hasEverFailedToSaveFlag = false;
+};
+
+dj_inherits(orp.archive.DeltaArchive, orp.archive.StubArchive);  // makes DeltaArchive be a subclass of StubArchive
+
+
+// -------------------------------------------------------------------
+// Public constants
+// -------------------------------------------------------------------
+orp.archive.DeltaArchive.PATH_TO_REPOSITORY_DIRECTORY = &quot;repositories&quot;;
+
+
+// -------------------------------------------------------------------
+// Public methods
+// -------------------------------------------------------------------
+
+/**
+ * Initializes the instance variables for a newly created DeltaArchive,
+ * and does the initial loading of at least the axiomatic items.
+ *
+ * @scope    public instance method
+ * @param    world    The world that we provide data for. 
+ */
+orp.archive.DeltaArchive.prototype.setWorldAndLoadAxiomaticItems = function(world) {
+  this._initialize(world);
+  this._loadAxiomaticItemsFromFileAtURL(this._dehydratedAxiomFileURL);
+
+  var repositoryFileName = this._repositoryName + &quot;.json&quot;;
+  var repositoryUrl = &quot;&quot;;
+  if (this._needCompletePath) {
+    repositoryUrl = this._completePathToTrunkDirectory + '/';
+  }
+  repositoryUrl += orp.archive.DeltaArchive.PATH_TO_REPOSITORY_DIRECTORY + &quot;/&quot; + repositoryFileName;
+  // var repositoryContentString = orp.util.getStringContentsOfFileAtURL(repositoryUrl);
+  var repositoryContentString = dojo.hostenv.getText(repositoryUrl);
+  repositoryContentString += &quot; ] }&quot;;
+
+  this._loadWorldFromJsonString(repositoryContentString);
+};
+
+
+// -------------------------------------------------------------------
+// Private Methods
+// -------------------------------------------------------------------
+
+/**
+ * Loads a world of items from a dehydrated JSON string.
+ *
+ * Given a world of items in JSON format, bootstraps new 
+ * instances of items corresponding to the dehydrated data.
+ * 
+ * @scope    private instance method
+ * @param    jsonRepositoryString    A JSON string literal representing the world of items. 
+ */
+orp.archive.DeltaArchive.prototype._loadWorldFromJsonString = function(jsonRepositoryString) {
+
+  // load the list of records
+  orp.lang.assertType(jsonRepositoryString, String);
+  var dehydratedRecords = null;
+  eval(&quot;dehydratedRecords = &quot; + jsonRepositoryString + &quot;;&quot;);
+  orp.lang.assertType(dehydratedRecords, Object);
+  var recordFormat = dehydratedRecords[orp.archive.StubArchive.JSON_MEMBER.FORMAT];
+  orp.lang.assert(recordFormat == orp.archive.StubArchive.JSON_FORMAT.FORMAT_2005_JUNE_CHRONOLOGICAL_LIST);
+  var listOfRecords = dehydratedRecords[orp.archive.StubArchive.JSON_MEMBER.RECORDS];
+  orp.lang.assertType(listOfRecords, Array);
+  
+  var listOfUsers = null;
+  
+  this._rehydrateRecords(listOfRecords);
+};
+
+
+/**
+ * Given a string, returns a copy of the string that is less than
+ * 80 characters long.
+ *
+ * @scope    private instance method
+ * @param    string    A string that may need truncating.
+ * @return   A string that is no longer than 80 characters long.
+ */
+orp.archive.DeltaArchive.prototype._truncateString = function(string) {
+  var maxLength = 80;
+  var ellipsis = &quot;...&quot;;
+  var returnString = &quot;&quot;;
+  if (string.length &gt; maxLength) {
+    returnString = (string.substring(0, (maxLength - ellipsis.length)) + ellipsis);
+  } else {
+    returnString = string;
+  }
+  return this.encodeText(returnString);
+};
+
+
+/**
+ * Returns a big string, containing JavaScript &quot;object literal&quot;
+ * representations of all of the records in a Transaction.
+ *
+ * @scope    private instance method
+ * @param    transaction    A transaction object.
+ * @return   A JSON string literal, representing the records in the transaction. 
+ */
+orp.archive.DeltaArchive.prototype._getJsonStringRepresentingTransaction = function(transaction) {
+  var indent = &quot;  &quot;;
+  var listOfRecords = transaction.getRecords();
+  if (!listOfRecords || listOfRecords.length === 0) {
+    return &quot;&quot;;
+  }
+  
+  if (listOfRecords.length == 1) {
+    return this._getJsonStringRepresentingRecords(listOfRecords, indent);
+  } else {
+    indent = &quot;    &quot;;
+    var listOfStrings = [];
+    listOfStrings.push(&quot;  // =======================================================================\n&quot;);
+    listOfStrings.push('  { &quot;' + orp.archive.StubArchive.JSON_MEMBER.TRANSACTION_CLASS + '&quot;: [\n');
+    var content = this._getJsonStringRepresentingRecords(transaction.getRecords(), indent);
+    listOfStrings.push(content);
+    listOfStrings.push('  ]\n');
+    listOfStrings.push('  }');
+    
+    var finalString = listOfStrings.join(&quot;&quot;);
+    return finalString;
+  }
+};
+
+
+/**
+ *
+ */
+orp.archive.DeltaArchive.prototype._getTypedDisplayStringForItem = function(item) {
+  var returnString = &quot;(&quot;;
+  if (item) {
+    if (item instanceof orp.model.Item) {
+      var category = item.getFirstCategory();
+      if (category) {
+        returnString += this._truncateString(category.getDisplayString(&quot;???&quot;)) + &quot;: &quot;;
+      }
+      returnString += this._truncateString(item.getDisplayString(&quot;???&quot;));
+    }
+    if (item instanceof orp.model.Entry) {
+      returnString += &quot;Entry&quot;;
+    }
+  }
+  returnString += &quot;)&quot;;
+  return returnString;
+};
+
+  
+/**
+ * Returns a big string, containing JavaScript &quot;object literal&quot;
+ * representations of the records.
+ *
+ * @scope    private instance method
+ * @param    listOfRecords    A list of the records to include in the JSON string.
+ * @param    indent    Optional. A string of spaces to prepend to each line.
+ * @return   A JSON string literal, representing the records. 
+ */
+orp.archive.DeltaArchive.prototype._getJsonStringRepresentingRecords = function(listOfRecords, indent) {
+  indent = indent || &quot;&quot;;
+  var i;
+  var listOfStrings = [];
+  var firstContentRecord = true;
+  var itemDisplayNameSubstring;
+  var entryDisplayNameSubstring;
+  var listOfUsers = null;
+  var commentString;
+  var generateComments = false;
+  var JSON_MEMBER = orp.archive.StubArchive.JSON_MEMBER;
+
+  if (!generateComments) {
+    indent = &quot;&quot;;
+  }
+  
+  for (i in listOfRecords) {
+    var record = listOfRecords[i];
+    if (firstContentRecord) {
+      firstContentRecord = false;
+    } else {
+      listOfStrings.push(',\n');
+    }
+    if (generateComments) {
+      listOfStrings.push(indent + '// -----------------------------------------------------------------------\n');
+    }
+    
+    if (record instanceof orp.model.Item) {
+      var item = record;
+      if (generateComments) {
+        listOfStrings.push(indent + '// ' + this._getTypedDisplayStringForItem(item) + '\n');
+        listOfStrings.push(indent + '//           by (' + this._truncateString(item.getUserstamp().getDisplayString()) + ')');
+        listOfStrings.push(' on (' + orp.util.DateValue.getStringMonthDayYear(item.getCreationDate()) + ')\n');
+      }
+      if (!this._jsonFragmentForItemPrefix) {
+        this._jsonFragmentForItemPrefix = indent + '{ &quot;' + JSON_MEMBER.ITEM_CLASS + '&quot;: ';
+        this._jsonFragmentForItemPrefix += '{ &quot;' + JSON_MEMBER.UUID + '&quot;: ';
+      }
+      listOfStrings.push(this._jsonFragmentForItemPrefix);
+      listOfStrings.push(item._getUuidInQuotes());
+      listOfStrings.push(' } }');
+      
+      if (!listOfUsers) {
+        listOfUsers = this.getUsers();
+      }
+      if (orp.util.isObjectInSet(item, listOfUsers)) {
+        var user = item;
+        var password = this._hashTableOfUserAuthenticationInfo[user.getUuid()];
+        var passwordString = &quot;null&quot;;
+        if (password) {
+          passwordString = '&quot;' + password + '&quot;';
+        }
+        listOfStrings.push(',\n');
+        if (generateComments) {
+          listOfStrings.push(indent + '// -----------------------------------------------------------------------\n');
+          listOfStrings.push(indent + '// ' + this._getTypedDisplayStringForItem(user) + '\n');
+        }
+        listOfStrings.push(indent + '{ &quot;' + JSON_MEMBER.USER_CLASS + '&quot;: ' + '{\n');
+        listOfStrings.push(indent + '         &quot;' + JSON_MEMBER.USER + '&quot;: ' + user._getUuidInQuotes() + ',\n');
+        listOfStrings.push(indent + '     &quot;' + JSON_MEMBER.PASSWORD + '&quot;: ' + passwordString + ' }\n');
+        listOfStrings.push(indent + '}');
+      }
+    }
+
+    if (record instanceof orp.model.Vote) {
+      var vote = record;
+      entryDisplayNameSubstring = this._getTypedDisplayStringForItem(vote.getContentRecord());
+      var deleteVsRetainString = vote.getRetainFlag() ? &quot;RETAIN&quot; : &quot;DELETE&quot;;
+      if (generateComments) {
+        listOfStrings.push(indent + '// vote to ' + deleteVsRetainString + &quot; &quot; + entryDisplayNameSubstring + '\n');
+      }
+      listOfStrings.push(indent + '{ &quot;' + JSON_MEMBER.VOTE_CLASS + '&quot;: ' + '{\n');
+      listOfStrings.push(indent + '         &quot;' + JSON_MEMBER.UUID + '&quot;: ' + vote._getUuidInQuotes() + ',\n');
+      listOfStrings.push(indent + '       &quot;' + JSON_MEMBER.RECORD + '&quot;: ' + vote.getContentRecord()._getUuidInQuotes() + ',\n');
+      listOfStrings.push(indent + '   &quot;' + JSON_MEMBER.RETAIN_FLAG + '&quot;: &quot;' + vote.getRetainFlag() + '&quot;');
+      listOfStrings.push('  }\n');
+      listOfStrings.push(indent + '}');
+    }
+
+    if (record instanceof orp.model.Ordinal) {
+      var ordinal = record;
+      entryDisplayNameSubstring = this._getTypedDisplayStringForItem(ordinal.getContentRecord());
+      if (generateComments) {
+        listOfStrings.push(indent + '// ordinal # ' + ordinal.getOrdinalNumber() + &quot; for &quot; + entryDisplayNameSubstring + '\n');
+      }
+      listOfStrings.push(indent + '{ &quot;' + JSON_MEMBER.ORDINAL_CLASS + '&quot;: ' + '{' + '\n');
+      listOfStrings.push(indent + '         &quot;' + JSON_MEMBER.UUID + '&quot;: ' + ordinal._getUuidInQuotes() + ',\n');
+      listOfStrings.push(indent + '       &quot;' + JSON_MEMBER.RECORD + '&quot;: ' + ordinal.getContentRecord()._getUuidInQuotes() + ',\n');
+      listOfStrings.push(indent + '        &quot;' + JSON_MEMBER.ORDINAL_NUMBER + '&quot;: &quot;' + ordinal.getOrdinalNumber() + '&quot;');
+      listOfStrings.push('  }\n');
+      listOfStrings.push(indent + '}');
+    }
+
+    if (record instanceof orp.model.Entry) {
+      var entry = record;
+      var entryType = entry.getType();
+      var typeUuid = entryType.getUuid();
+      // var entryString = &quot;&quot;;
+      if (generateComments) {
+        listOfStringsForEntry = [];
+      } else {
+        listOfStringsForEntry = listOfStrings;
+      }
+      listOfStringsForEntry.push(indent + '{ &quot;' + JSON_MEMBER.ENTRY_CLASS + '&quot;: ' + '{\n');
+      listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.UUID + '&quot;: ' + entry._getUuidInQuotes() + ',\n');
+      var previousEntry = entry.getPreviousEntry();
+      if (previousEntry) {
+        listOfStringsForEntry.push(indent + '&quot;' + JSON_MEMBER.PREVIOUS_VALUE + '&quot;: ' + previousEntry._getUuidInQuotes() + ',\n');
+      }
+      listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.TYPE + '&quot;: &quot;' + typeUuid.toString() + '&quot;,\n');
+      if (generateComments) {
+        commentString = &quot;&quot;;
+      }
+      if (typeUuid.toString() == orp.model.World.UUID.TYPE_CONNECTION) {
+        var pairOfItems = entry.getItem();
+        var firstItem = pairOfItems[0];
+        var secondItem = pairOfItems[1];
+        listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.ITEM + '&quot;: [' + firstItem._getUuidInQuotes() + ', ' + secondItem._getUuidInQuotes() + '],\n');
+        var pairOfAttributes = entry.getAttribute();
+        var firstAttribute = pairOfAttributes[0];
+        var secondAttribute = pairOfAttributes[1];
+        listOfStringsForEntry.push(indent + '    &quot;' + JSON_MEMBER.ATTRIBUTE + '&quot;: [' + firstAttribute._getUuidInQuotes() + ', ' + secondAttribute._getUuidInQuotes() + ']');
+        if (generateComments) {
+          commentString += indent + '// ' + this._getTypedDisplayStringForItem(firstItem);
+          commentString += &quot;.(&quot; + this._truncateString(firstAttribute.getDisplayString(&quot;???&quot;)) + &quot;)&quot;;
+          commentString += &quot; = &quot; + this._getTypedDisplayStringForItem(secondItem) + &quot;\n&quot;;
+          commentString += indent + '// ' + this._getTypedDisplayStringForItem(secondItem);
+          commentString += &quot;.(&quot; + this._truncateString(secondAttribute.getDisplayString(&quot;???&quot;)) + &quot;)&quot;;
+          commentString += &quot; = &quot; + this._getTypedDisplayStringForItem(firstItem) + &quot;\n&quot;;
+        }
+      } else {
+        var attribute = entry.getAttribute();
+        // if (!(attribute instanceof orp.model.Item)) {
+        //   alert(entry + &quot;\n&quot; + attribute);
+        // }
+        listOfStringsForEntry.push(indent + '    &quot;' + JSON_MEMBER.ATTRIBUTE + '&quot;: ' + attribute._getUuidInQuotes() + ',\n');
+        listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.ITEM + '&quot;: ' + entry.getItem()._getUuidInQuotes() + ',\n');
+        var contentData = entry.getValue();
+        
+        var valueString = null;
+        var valueComment = null;
+        switch (typeUuid.toString()) {
+          case orp.model.World.UUID.TYPE_NUMBER: 
+            valueString = '&quot;' + contentData + '&quot;';
+            if (generateComments) {valueComment = contentData;}
+            break;
+          case orp.model.World.UUID.TYPE_TEXT: 
+            valueString = '&quot;' + this.encodeText(contentData) + '&quot;';
+            if (generateComments) {valueComment = '&quot;' + this._truncateString(contentData) + '&quot;';}
+            break;
+          case orp.model.World.UUID.TYPE_DATE: 
+            valueString = '&quot;' + contentData.toString() + '&quot;';
+            if (generateComments) {valueComment = valueString;}
+            break;
+          case orp.model.World.UUID.TYPE_ITEM: 
+            valueString = contentData._getUuidInQuotes();
+            if (generateComments) {valueComment = this._getTypedDisplayStringForItem(contentData);}
+            break;
+          default:
+            orp.lang.assert(false, &quot;no such type: &quot; + entryType.getDisplayString());
+        }
+        listOfStringsForEntry.push(indent + '        &quot;' + JSON_MEMBER.VALUE + '&quot;: ' + valueString);
+        if (generateComments) {
+          commentString += indent + '// ' + this._getTypedDisplayStringForItem(entry.getItem());
+          commentString += &quot;.(&quot; + this._truncateString(attribute.getDisplayString(&quot;???&quot;)) + &quot;)&quot;;
+          commentString += &quot; = &quot; + valueComment + &quot;\n&quot;;
+        }
+      }
+      if (generateComments) {
+        commentString += indent + '//           by (' + this._truncateString(entry.getUserstamp().getDisplayString()) + ')';
+        commentString += ' on (' + orp.util.DateValue.getStringMonthDayYear(entry.getCreationDate()) + ')\n';
+        listOfStrings.push(commentString);
+        for (var j in listOfStringsForEntry) {
+          listOfStrings.push(listOfStringsForEntry[j]);
+        }
+      }
+      // listOfStrings.push(entryString);
+      listOfStrings.push('  }\n');
+      listOfStrings.push(indent + '}');
+    }
+  }
+  
+  var finalString = listOfStrings.join(&quot;&quot;);
+  return finalString;
+};
+
+
+/**
+ * @scope    private instance method
+ * @param    overwriteIfExists    Optional
+ * @return   success
+ */
+orp.archive.DeltaArchive.prototype._createNewRepository = function(overwriteIfExists) {
+  if (this._saverObject) {
+    alert(&quot;this._saverObject is already initialized.&quot;);
+    return false;
+  }
+  if (window.location) {
+    if (window.location.protocol == &quot;http:&quot;) {
+      this._saverObject = new orp.storage.HttpStorage(this._repositoryName, this._pathToTrunkDirectory);
+    }
+    if (window.location.protocol == &quot;file:&quot;) {
+      this._saverObject = new orp.storage.FileStorage(this._repositoryName, this._pathToTrunkDirectory);
+    }
+  }
+  if (!this._saverObject) {
+    if (!this._hasEverFailedToSaveFlag) {
+      window.alert(&quot;I can't save changes to server, because this page was loaded from a \&quot;<A HREF="file:///\">file:///\</A>&quot; location, not a real \&quot;<A HREF="http://\">http://\</A>&quot; location.  Sorry.&quot;); 
+      this._hasEverFailedToSaveFlag = true;
+    }
+    return false;
+  }
+  var text = '{ &quot;format&quot;: &quot;' + orp.archive.StubArchive.JSON_FORMAT.FORMAT_2005_JUNE_CHRONOLOGICAL_LIST + '&quot;, \n';
+  text +=    '  &quot;records&quot;: [\n';
+  text +=    '  // =======================================================================\n';
+  text +=    '  { &quot;Transaction&quot;: [ ]\n';
+  text +=    '  }';
+  return this._saverObject.writeText(text, overwriteIfExists);
+};
+
+
+/**
+ * Sends all the changes to the server, so that the server can record the
+ * changes.
+ *
+ * @scope    private instance method
+ * @param    forceSave    Optional. Forces a save if set to true. 
+ * @return   The list of changes made. 
+ */
+orp.archive.DeltaArchive.prototype._saveChangesToServer = function(forceSave) {
+  var currentTransaction = this.getCurrentTransaction();
+  var listOfChangesMade = currentTransaction.getRecords();
+  if (!forceSave &amp;&amp; listOfChangesMade.length === 0) {
+    return listOfChangesMade;
+  }
+  
+  if (!this._saverObject) {
+    if (window.location) {
+      if (window.location.protocol == &quot;http:&quot;) {
+        this._saverObject = new orp.storage.HttpStorage(this._repositoryName, this._pathToTrunkDirectory);
+      }
+      if (window.location.protocol == &quot;file:&quot;) {
+        this._saverObject = new orp.storage.FileStorage(this._repositoryName, this._pathToTrunkDirectory);
+      }
+    }
+  }
+  
+  var key;
+  var newRecord;
+  for (key in listOfChangesMade) {
+    newRecord = listOfChangesMade[key];
+    this._chronologicalListOfRecords.push(newRecord);
+  }
+
+  if (this._saverObject) {
+    var textToAppend = &quot;,\n&quot; + this._getJsonStringRepresentingTransaction(currentTransaction);
+    this._saverObject.appendText(textToAppend);
+  } else {
+    if (!this._hasEverFailedToSaveFlag) {
+      window.alert(&quot;I can't save changes to server, because this page was loaded from a \&quot;<A HREF="file:///\">file:///\</A>&quot; location, not a real \&quot;<A HREF="http://\">http://\</A>&quot; location.  Sorry.&quot;); 
+      this._hasEverFailedToSaveFlag = true;
+    }
+  }
+  
+  this._currentTransaction = null;
+  return listOfChangesMade;
+};
+
+
+// -------------------------------------------------------------------
+// End of file
+// -------------------------------------------------------------------

Copied: trunk/source/archive/StubArchive.js (from rev 345, trunk/source/model/StubVirtualServer.js)
===================================================================
--- trunk/source/model/StubVirtualServer.js	2005-09-28 07:24:38 UTC (rev 345)
+++ trunk/source/archive/StubArchive.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,1073 @@
+/*****************************************************************************
+ StubArchive.js
+ 
+******************************************************************************
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+  
+ You can copy freely from this file.  This work may be freely reproduced, 
+ distributed, transmitted, used, modified, built upon, or otherwise exploited
+ by anyone for any purpose.
+  
+ This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
+ of any kind, either express or implied, including, without limitation, any 
+ warranties or conditions of title, non-infringement, merchantability, or 
+ fitness for a particular purpose. You are solely responsible for determining 
+ the appropriateness of using or distributing the work and assume all risks 
+ associated with use of this work, including but not limited to the risks and 
+ costs of errors, compliance with applicable laws, damage to or loss of data 
+ or equipment, and unavailability or interruption of operations.
+
+ In no event shall the authors or contributors have any liability for any 
+ direct, indirect, incidental, special, exemplary, or consequential damages,
+ however caused and on any theory of liability, whether in contract, strict 
+ liability, or tort (including negligence), arising in any way out of or in 
+ connection with the use or distribution of the work.
+*****************************************************************************/
+ 
+// -------------------------------------------------------------------
+// Provides and Requires
+// -------------------------------------------------------------------
+dojo.provide(&quot;orp.archive.StubArchive&quot;);
+dojo.require(&quot;orp.model.World&quot;);
+dojo.require(&quot;orp.model.Item&quot;);
+dojo.require(&quot;orp.model.Entry&quot;);
+dojo.require(&quot;orp.model.Transaction&quot;);
+dojo.require(&quot;orp.util.TimeBasedUuid&quot;);
+dojo.require(&quot;orp.util.DateValue&quot;);
+dojo.require(&quot;orp.lang.Lang&quot;);
+
+// -------------------------------------------------------------------
+// Dependencies, expressed in the syntax that JSLint understands:
+// 
+/*global Util  */
+/*global World, Item, Entry, Ordinal, Vote, ContentRecord, Transaction  */
+// -------------------------------------------------------------------
+
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+/**
+ * The StubArchive is a dummy place-holder datastore that does
+ * a bare-minimum job of providing data to a World.
+ *
+ * @scope    public instance constructor
+ */
+orp.archive.StubArchive = function(pathToTrunkDirectory) {
+  var fileName = &quot;2005_june_axiomatic_items.json&quot;;
+  var relUrlForAxiomaticFile = &quot;source/model/&quot; + fileName;
+  if (pathToTrunkDirectory) {
+    this._needCompletePath = true;
+    var thisUrl = window.location.pathname; //e.g. /openrecord/trunk/source/model/TestRepositoryWriting.html.
+    var arrayOfPathComponents = thisUrl.split('/');
+    arrayOfPathComponents.pop();
+    var thisDirectory = arrayOfPathComponents.join('/'); //e.g. /openrecord/trunk/source/model
+    this._completePathToTrunkDirectory = thisDirectory + '/' + pathToTrunkDirectory;
+    this._dehydratedAxiomFileURL = this._completePathToTrunkDirectory + '/' + relUrlForAxiomaticFile;
+  } else {
+    this._needCompletePath = false;
+    this._dehydratedAxiomFileURL = relUrlForAxiomaticFile;    
+  }
+  
+  /*
+  if (optionalDefaultOverrides) {
+    this._processOptionalDefaultOverrides(optionalDefaultOverrides, &quot;Stub&quot;);
+  }
+  */
+};
+
+
+// -------------------------------------------------------------------
+// Public constants
+// -------------------------------------------------------------------
+orp.archive.StubArchive.JSON_FORMAT = {
+  FORMAT_2005_JUNE_CHRONOLOGICAL_LIST: &quot;2005_JUNE_CHRONOLOGICAL_LIST&quot; };
+
+orp.archive.StubArchive.JSON_MEMBER = {
+  FORMAT: &quot;format&quot;,
+  RECORDS: &quot;records&quot;,
+  TYPE: &quot;type&quot;,
+  VALUE: &quot;value&quot;,
+  UUID: &quot;uuid&quot;,
+  USER: &quot;user&quot;,
+  PASSWORD: &quot;password&quot;,
+  ITEM_CLASS: &quot;Item&quot;,
+  ENTRY_CLASS: &quot;Entry&quot;,
+  VOTE_CLASS: &quot;Vote&quot;,
+  ORDINAL_CLASS: &quot;Ordinal&quot;,
+  USER_CLASS: &quot;User&quot;,
+  TRANSACTION_CLASS: &quot;Transaction&quot;,
+  ATTRIBUTE: &quot;attribute&quot;,
+  PREVIOUS_VALUE: &quot;previousEntry&quot;,
+  RECORD: &quot;record&quot;,
+  ITEM: &quot;item&quot;,
+  RETAIN_FLAG: &quot;retainFlag&quot;,
+  ORDINAL_NUMBER: &quot;value&quot; };
+
+
+/*
+OLD?
+StubArchive.JSON_TYPE_TEXT_VALUE = &quot;TextValue&quot;;
+StubArchive.JSON_TYPE_RELATED_UUID = &quot;RelatedUuid&quot;;
+StubArchive.JSON_TYPE_NUMBER_VALUE = &quot;NumberValue&quot;;
+StubArchive.JSON_TYPE_DATE_VALUE = &quot;DateValue&quot;;
+StubArchive.JSON_TYPE_CHECKMARK_VALUE = &quot;CheckMarkValue&quot;;
+StubArchive.JSON_TYPE_URL_VALUE = &quot;UrlValue&quot;;
+StubArchive.JSON_TYPE_CONNECTION = &quot;Connection&quot;;
+*/
+
+
+// -------------------------------------------------------------------
+// Private methods
+// -------------------------------------------------------------------
+
+/**
+ * Initializes the instance variables for a newly created StubArchive.
+ *
+ * @scope    private instance method
+ * @param    world    The world that we provide data for. 
+ */
+orp.archive.StubArchive.prototype._initialize = function(world) {
+  this._world = world;
+  
+  this._countOfNestedTransactions = 0;
+  this._currentTransaction = null;
+
+  this._hashTableOfItemsKeyedByUuid = {};
+  this._hashTableOfEntriesKeyedByUuid = {};
+  this._chronologicalListOfRecords = [];
+  
+  this._listOfUsers = [];
+  this._hashTableOfUserAuthenticationInfo = {};
+  this._currentUser = null;
+};
+ 
+
+// -------------------------------------------------------------------
+// Public Methods
+// -------------------------------------------------------------------
+
+/**
+ * Initializes the instance variables for a newly created StubArchive,
+ * and does the initial loading of at least the axiomatic items.
+ *
+ * @scope    public instance method
+ * @param    world    The world that we provide data for. 
+ */
+orp.archive.StubArchive.prototype.setWorldAndLoadAxiomaticItems = function(world) {
+  this._initialize(world);
+  // this._buildTypeHashTable();
+  this._loadAxiomaticItemsFromFileAtURL(this._dehydratedAxiomFileURL);
+};
+
+
+/**
+ * Returns the World instance that this virtual server is using.
+ *
+ * @scope    public instance method
+ * @return   A World object. 
+ */
+orp.archive.StubArchive.prototype.getWorld = function() {
+  return this._world;
+};
+
+
+/**
+ * Given a text string, this method returns a copy of the text string, 
+ * with certain special characters replaced by escape sequences.
+ * 
+ * For example, given a string like this:
+ * &lt;pre&gt;
+ *    this.encodeText('The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.\n');
+ * &lt;/pre&gt;
+ * The return value will be:
+ * &lt;pre&gt;
+ *    'The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.&#10;'
+ * &lt;/pre&gt;
+ * 
+ * @scope    public instance method
+ * @param    rawText    A text string to encode. 
+ * @return   A copy of the rawText string, with the special characters escaped. 
+ */
+orp.archive.StubArchive.prototype.encodeText = function(rawText) {
+  // orp.util.assert(orp.util.isString(rawText));
+  orp.lang.assertType(rawText, String);
+
+  var returnString = rawText;
+  // Note: it's important that we do '&amp;' first, otherwise we'll accidentally
+  // replace all the &amp; characters that we add in the following lines.
+  returnString = returnString.replace(new RegExp('&amp;','g'), &quot;&amp;&quot;);
+  returnString = returnString.replace(new RegExp('&lt;','g'), &quot;&lt;&quot;);
+  returnString = returnString.replace(new RegExp('&gt;','g'), &quot;&gt;&quot;);
+  returnString = returnString.replace(new RegExp('&quot;','g'), &quot;&quot;&quot;);
+  returnString = returnString.replace(new RegExp('\n','g'), &quot;&#10;&quot;);
+  returnString = returnString.replace(new RegExp('\r','g'), &quot;&#13;&quot;);
+  return returnString;
+};
+
+
+/**
+ * Given a text string that was encoded using encodeText(), this method 
+ * returns a decoded copy of the text string, with the encoded escape 
+ * sequences now replaced by the original special characters.
+ *
+ * For example, given a string like this:
+ * &lt;pre&gt;
+ *    this.decodeText('The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.&#10;');
+ * &lt;/pre&gt;
+ * The return value will be:
+ * &lt;pre&gt;
+ *    'The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.\n'
+ * &lt;/pre&gt;
+ *
+ * @scope    public instance method
+ * @param    encodedText    A text string to decode. 
+ * @return   A copy of the encodedText string, with the escaped characters replaced by the original special characters. 
+ */
+orp.archive.StubArchive.prototype.decodeText = function(encodedText) {
+  // orp.util.assert(orp.util.isString(encodedText));
+  orp.lang.assertType(encodedText, String);
+  
+  var returnString = encodedText;
+  returnString = returnString.replace(new RegExp('&#13;','g'), &quot;\r&quot;);
+  returnString = returnString.replace(new RegExp('&#10;','g'), &quot;\n&quot;);
+  returnString = returnString.replace(new RegExp('&quot;','g'), '&quot;');
+  returnString = returnString.replace(new RegExp('&gt;','g'), &quot;&gt;&quot;);
+  returnString = returnString.replace(new RegExp('&lt;','g'), &quot;&lt;&quot;);
+  returnString = returnString.replace(new RegExp('&amp;','g'), &quot;&amp;&quot;);
+  // Note: it's important that we do '&amp;' last, otherwise we won't correctly
+  // handle a case like this:
+  //   text = this.decodeText(this.encodeText('&lt;'));
+  return returnString;
+};
+
+
+// -------------------------------------------------------------------
+// Transaction Methods
+// -------------------------------------------------------------------
+
+/**
+ * Marks the beginning of a transaction.
+ *
+ * Each time you call beginTransaction() you open a new transaction, 
+ * which you need to close later using endTransaction().  Transactions
+ * may be nested, but the beginTransaction and endTransaction calls
+ * always need to come in pairs. 
+ *
+ * @scope    public instance method
+ */
+orp.archive.StubArchive.prototype.beginTransaction = function() {
+  if (this._countOfNestedTransactions === 0) {
+    this._currentTransaction = new orp.model.Transaction();
+  }
+  this._countOfNestedTransactions += 1;
+};
+ 
+
+/**
+ * Marks the end of a transaction.
+ *
+ * @scope    public instance method
+ */
+orp.archive.StubArchive.prototype.endTransaction = function() {
+  this._countOfNestedTransactions -= 1;
+  orp.lang.assert(this._countOfNestedTransactions &gt;= 0);
+
+  if (this._countOfNestedTransactions === 0) {
+    var listOfChangesMade = this._saveChangesToServer();
+    this._currentTransaction = null;
+    if (listOfChangesMade.length &gt; 0) {
+      // alert(listOfChangesMade.length + &quot; changes made&quot;);
+      // orp.util.displayStatusBlurb(listOfChangesMade.length + &quot; changes made&quot;);
+      this._world._notifyObserversOfChanges(listOfChangesMade);
+    }
+  }
+};
+
+
+/**
+ * Returns the Transaction object for the current transaction.
+ *
+ * @scope    public instance method
+ * @return   A Transaction object, or null if there is no transaction in progress. 
+ */
+orp.archive.StubArchive.prototype.getCurrentTransaction = function() {
+  return this._currentTransaction;
+};
+
+
+// -------------------------------------------------------------------
+// Methods for creating and changing items
+// -------------------------------------------------------------------
+
+/**
+ * Returns a newly created item.
+ *
+ * @scope    public instance method
+ * @param    name    Optional. A string, which will be assigned to the name attribute of the new item. 
+ * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
+ * @return   A newly created item.
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype.newItem = function(name, observer) {
+  this._throwErrorIfNoUserIsLoggedIn();
+  var item = this._createNewItem(observer, false);
+  if (name) { 
+    var attributeCalledName = this._world.getAttributeCalledName();
+    // item.addEntryForAttribute(attributeCalledName, name);
+    item.addEntry({attribute:attributeCalledName, value:name});
+  }
+  return item;
+};
+
+
+/**
+ * Returns a newly created &quot;provisional&quot; item.  At the time this item is 
+ * created, it will only exist in local memory.  Unlike normal items, 
+ * provisional items are not saved to the repository at the time they 
+ * are created.  The provisional item is saved to the repository when 
+ * an entry is set for one of the item's attributes.
+ *
+ * @scope    public instance method
+ * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
+ * @return   A newly created provisional item.
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype.newProvisionalItem = function(observer) {
+  this._throwErrorIfNoUserIsLoggedIn();
+  var item = this._createNewItem(observer, true);
+  return item;
+};
+
+
+/**
+ * Returns a newly created item: either a provisional item or a normal item.
+ *
+ * @scope    private instance method
+ * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
+ * @param    provisionalFlag    True if the item is provisional; false if the item is normal. 
+ * @return   A newly created item.
+ */
+orp.archive.StubArchive.prototype._createNewItem = function(observer, provisionalFlag) {
+  var uuid = this._getNewUuid();
+  var item = new orp.model.Item(this._world, uuid);
+  item._initialize(observer, provisionalFlag);
+  this._hashTableOfItemsKeyedByUuid[uuid] = item;
+  if (!provisionalFlag) {
+    this._currentTransaction.addRecord(item);
+  }
+  return item;
+};
+
+
+/**
+ * Records the fact that a provisional item just became real.
+ *
+ * @scope    package instance method
+ * @param    item    The item that was provisional and just became real. 
+ */
+orp.archive.StubArchive.prototype._provisionalItemJustBecameReal = function(item) {
+  this._currentTransaction.addRecord(item);
+};
+
+
+/**
+ * Returns a newly created entry.
+ *
+ * @scope    public instance method
+ * @param    item    The item that this is an entry of. 
+ * @param    previousEntry    Optional. The old entry that this entry is replacing. 
+ * @param    attribute    The attribute that this entry is assigned to. May be null. 
+ * @param    value    The value to initialize the entry with. 
+ * @param    type    Optional. An item representing the data type of the value. 
+ * @return   A newly created entry.
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype.newEntry = function(item, previousEntry, attribute, value, type) {
+  this._throwErrorIfNoUserIsLoggedIn();
+  var uuid = this._getNewUuid();
+  var entry = new orp.model.Entry(this._world, uuid);
+  entry._initialize(item, previousEntry, attribute, value, type);
+  item._addEntryToListOfEntriesForAttribute(entry, attribute);
+  
+  this._hashTableOfEntriesKeyedByUuid[uuid] = entry;
+  this._currentTransaction.addRecord(entry);
+  return entry;
+};
+ 
+
+/**
+ * Returns a newly created entry.
+ *
+ * @scope    public instance method
+ * @param    previousEntry    The entry that this entry will replace. Can be null.
+ * @param    itemOne    One of the two items that this entry will connect. 
+ * @param    attributeOne    The attribute of itemOne that this entry will be assigned to. 
+ * @param    itemTwo    One of the two items that this entry will connect. 
+ * @param    attributeTwo    The attribute of itemTwo that this entry will be assigned to.  
+ * @return   A newly created entry.
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype.newConnectionEntry = function(previousEntry, itemOne, attributeOne, itemTwo, attributeTwo) {
+  this._throwErrorIfNoUserIsLoggedIn();
+  var uuid = this._getNewUuid();
+  var entry = new orp.model.Entry(this._world, uuid);
+  entry._initializeConnection(previousEntry, itemOne, attributeOne, itemTwo, attributeTwo);
+
+  itemOne._addEntryToListOfEntriesForAttribute(entry, attributeOne);
+  itemTwo._addEntryToListOfEntriesForAttribute(entry, attributeTwo);
+
+  this._hashTableOfEntriesKeyedByUuid[uuid] = entry;
+  this._currentTransaction.addRecord(entry);
+  return entry;
+};
+
+
+/**
+ * Returns a newly created ordinal.
+ *
+ * @scope    public instance method
+ * @param    contentRecord    The contentRecord that this is an ordinal for. 
+ * @param    ordinalNumber    The ordinal number itself. 
+ * @return   A newly created ordinal.
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype.newOrdinal = function(contentRecord, ordinalNumber) {
+  this._throwErrorIfNoUserIsLoggedIn();
+  var uuid = this._getNewUuid();
+  var ordinal = new orp.model.Ordinal(this._world, uuid, contentRecord, ordinalNumber);
+  this._currentTransaction.addRecord(ordinal);
+  return ordinal;
+};
+
+
+/**
+ * Returns a newly created vote.
+ *
+ * @scope    public instance method
+ * @param    contentRecord    The contentRecord to attach this vote to. 
+ * @param    retainFlag    True if this is a vote to retain. False if this is a vote to delete. 
+ * @return   A newly created vote.
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype.newVote = function(contentRecord, retainFlag) {
+  this._throwErrorIfNoUserIsLoggedIn();
+  var uuid = this._getNewUuid();
+  var vote = new orp.model.Vote(this._world, uuid, contentRecord, retainFlag);
+  this._currentTransaction.addRecord(vote);
+  return vote;
+};
+
+
+// -------------------------------------------------------------------
+// Methods having to do with users
+// -------------------------------------------------------------------
+
+/**
+ * Creates a new item, where the new item represents a user of this datastore.
+ *
+ * @scope    public instance method
+ * @param    name    A string, which will be assigned to the name attribute of the new item. 
+ * @param    authentication    A string which will be used as the login password for the user. 
+ * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
+ * @return   A newly created item representing a user.
+ * @throws   Throws an Error if a user is logged in.
+ */
+orp.archive.StubArchive.prototype.newUser = function(name, authentication, observer) {
+  if (this._currentUser) {
+    var error = new Error(&quot;A user is logged in.  You can't create a new user when somebody is already logged in.&quot;);
+    throw error;
+  }
+
+  var newUser = this._createNewItem(observer, false);
+  this._listOfUsers.push(newUser);
+  
+  var md5Authentication = null;
+  if (authentication) {
+    md5Authentication = orp.util.hex_md5(authentication);
+  }
+  this._hashTableOfUserAuthenticationInfo[newUser.getUuid()] = md5Authentication;
+
+  this._currentUser = newUser;
+  var categoryCalledPerson = this.getWorld().getCategoryCalledPerson();
+  newUser.assignToCategory(categoryCalledPerson); 
+  if (name) { 
+    var attributeCalledName = this.getItemFromUuid(orp.model.World.UUID.ATTRIBUTE_NAME);
+    var entry = newUser.addEntry({attribute:attributeCalledName, value:name});
+  }
+  this._currentUser = null;
+  
+  return newUser;
+};
+
+
+/**
+ * Returns an list of all the items that represent users of this datastore.
+ *
+ * @scope    public instance method
+ * @return   A list of items.
+ */
+orp.archive.StubArchive.prototype.getUsers = function() {
+  return this._listOfUsers;
+};
+
+
+/**
+ * Returns an item representing the user who is currently logged in.
+ *
+ * @scope    public instance method
+ * @return   An item representing the user who is currently logged in.
+ */
+orp.archive.StubArchive.prototype.getCurrentUser = function() {
+  return this._currentUser;
+};
+
+
+// -------------------------------------------------------------------
+// Login and logout methods
+// -------------------------------------------------------------------
+
+/**
+ * Attempts to login a user.
+ *
+ * @scope    public instance method
+ * @param    inUser    The user to be logged in. 
+ * @param    inPassword    Password supplied at login. 
+ * @return   True if we were able to log in the user. False if the login failed.
+ */
+orp.archive.StubArchive.prototype.login = function(user, password) {
+  
+  // Only one user can be logged in at once.  We consider it an error
+  // if you try to log in a new user before logging out the old one.
+  if (this._currentUser) {
+    orp.lang.assert(false);
+  }
+  
+  var isKnownUser = orp.util.isObjectInSet(user, this._listOfUsers);
+  if (!isKnownUser) {
+    return false;
+  }
+
+  if (user.getUuidString() == orp.model.World.UUID.USER_AMY) {
+    // nobody is allowed to log in as the axiomatic user
+    return false;
+  }
+  
+  var md5hashOfPassword = null;
+  if (password) {
+    md5hashOfPassword = orp.util.hex_md5(password);
+  }
+  var realAuthentication = this._getAuthenticationInfoForUser(user);
+  var successfulAuthentication = ((realAuthentication == md5hashOfPassword) || !realAuthentication);
+  
+  // PENDING: temporary hack
+  // if (!successfulAuthentication) {
+  //  successfulAuthentication = (&quot;PENDING: magic super password&quot; == authentication);
+  // }
+  
+  if (successfulAuthentication) {
+    this._currentUser = user;
+    return true;
+  } else {
+    return false;
+  }
+};
+
+
+/**
+ * Logs out the current user.
+ *
+ * @scope    public instance method
+ * @return   True if the current user was logged out. False if there was no current user logged in.
+ */
+orp.archive.StubArchive.prototype.logout = function() {
+  if (this._currentUser) {
+    this._currentUser = null;
+    return true;
+  } else {
+    return false;
+  }
+};
+
+
+// -------------------------------------------------------------------
+// Other public methods
+// -------------------------------------------------------------------
+
+/**
+ * Given a UUID, returns the item identified by that UUID.
+ *
+ * @scope    public instance method
+ * @param    uuid    The UUID of the item to be returned. 
+ * @param    observer    Optional. An object to be registered as an observer of the returned item. 
+ * @return   The item identified by the given UUID.
+ */
+orp.archive.StubArchive.prototype.getItemFromUuid = function(uuid, observer) {
+  orp.lang.assert(dojo.lang.isString(uuid) || uuid instanceof orp.util.Uuid);
+  
+  var item = this._hashTableOfItemsKeyedByUuid[uuid];
+  if (item &amp;&amp; observer) {
+    item.addObserver(observer);
+  }
+  return item;
+};
+
+
+/**
+ * Sends all the changes to the server, so that the server can record the
+ * changes.
+ *
+ * @scope    private instance method
+ */
+orp.archive.StubArchive.prototype._saveChangesToServer = function () {
+  // The StubArchive doesn't ever actually talk to a server.
+  // Other VirtualServer implementations would be expected to actually
+  // implement this method such that it saves changes to the server
+  var listOfChangesMade = this._currentTransaction.getRecords();
+  this._currentTransaction = null;
+  return listOfChangesMade;
+};
+
+
+// -------------------------------------------------------------------
+// Query methods
+// -------------------------------------------------------------------
+
+/**
+ * Given a QueryRunner object, this method returns a list of all the items that 
+ * match the query criteria.
+ *
+ * @scope    public instance method
+ * @param    queryRunner    A QueryRunner object. 
+ * @return   A list of items.
+ */
+orp.archive.StubArchive.prototype.getResultItemsForQueryRunner = function(queryRunner) {
+  var matchingAttribute = queryRunner.getMatchingAttribute();
+  var listOfMatchingValues = queryRunner.getMatchingValues();
+  var listOfQueryResultItems = [];
+  var key;
+  
+  if (!matchingAttribute || !listOfMatchingValues) {
+    return listOfQueryResultItems;
+  }
+    
+  var attributeCalledCategory = this.getWorld().getAttributeCalledCategory();
+  if (matchingAttribute == attributeCalledCategory) {
+    // If this is a query for all the item in a category,
+    // then handle that as a special case, because we can
+    // do that way faster than more general queries.
+    var attributeCalledItemsInCategory = this.getWorld().getAttributeCalledItemsInCategory();
+    for (key in listOfMatchingValues) {
+      var category = listOfMatchingValues[key];
+      var listOfEntriesForItemsInCategory = category.getEntriesForAttribute(attributeCalledItemsInCategory);
+      for (var innerKey in listOfEntriesForItemsInCategory) {
+        var entry = listOfEntriesForItemsInCategory[innerKey];
+        var itemInCategory = entry.getValue(category);
+        orp.util.addObjectToSet(itemInCategory, listOfQueryResultItems);
+      }
+    }
+  } else {
+    // General case code for any sort of query. 
+    for (var uuid in this._hashTableOfItemsKeyedByUuid) {
+      var item = this._hashTableOfItemsKeyedByUuid[uuid];
+      var includeItem = queryRunner.doesItemMatch(item);
+      if (includeItem) {
+        listOfQueryResultItems.push(item);
+      }
+    }
+  }
+  listOfQueryResultItems.sort(orp.model.ContentRecord.compareOrdinals);
+  return listOfQueryResultItems; 
+};
+
+
+/**
+ * Given an item and a query item, this method modifies the attributes 
+ * of the item so that when the query is next evaluated the item will be 
+ * included in query result list.
+ *
+ * @scope    public instance method
+ * @param    item    An item, which will be modified so that it matches the query. 
+ * @param    query    A query item. 
+ */
+orp.archive.StubArchive.prototype.setItemToBeIncludedInQueryResultList = function(item, query) {
+  orp.lang.assert(item instanceof orp.model.Item);
+  orp.lang.assert(query instanceof orp.model.Item);
+  
+  var attributeCalledQueryMatchingValue = this.getWorld().getAttributeCalledQueryMatchingValue();
+  var attributeCalledQueryMatchingAttribute = this.getWorld().getAttributeCalledQueryMatchingAttribute();
+  var attributeCalledCategory = this.getWorld().getAttributeCalledCategory();
+  var categoryCalledCategory = this.getWorld().getCategoryCalledCategory();
+  
+  var listOfMatchingEntries = query.getEntriesForAttribute(attributeCalledQueryMatchingValue);
+  var listOfMatchingAttrs = query.getEntriesForAttribute(attributeCalledQueryMatchingAttribute);
+  if (!(listOfMatchingEntries &amp;&amp; (listOfMatchingEntries.length &gt; 0))) {return;} // query not fully formed, so nothing to add
+  var matchingAttribute;
+  if (listOfMatchingAttrs.length === 0) {
+    // by default matching attribute is category
+    matchingAttribute = attributeCalledCategory;
+  }
+  else {
+    orp.lang.assert(listOfMatchingAttrs.length==1, 'more than one matching attributes');
+    matchingAttribute = listOfMatchingAttrs[0].getValue();
+  }
+
+  for (var key in listOfMatchingEntries) {
+    var matchingEntry = listOfMatchingEntries[key];
+    var match = matchingEntry.getValue();
+    if (!item.hasAttributeValue(matchingAttribute, match)) {
+      if ((matchingAttribute == attributeCalledCategory) &amp;&amp; (match instanceof orp.model.Item) &amp;&amp; (match.isInCategory(categoryCalledCategory))) {
+        item.assignToCategory(match);
+      } else {
+        // item.addEntryForAttribute(matchingAttribute, match);
+        item.addEntry({attribute:matchingAttribute, value:match});
+      }
+    }
+  }
+};
+
+
+/**
+ * Given a category, this method returns a list of all the items that have been 
+ * assigned to that category.
+ *
+ * @scope    public instance method
+ * @param    inCategory    A category item. 
+ * @return   A list of items.
+ */
+orp.archive.StubArchive.prototype.getItemsInCategory = function(category) {
+  orp.lang.assert(category instanceof orp.model.Item);
+
+  var attributeCalledItemsInCategory = this.getWorld().getAttributeCalledItemsInCategory();
+  var listOfEntries = category.getEntriesForAttribute(attributeCalledItemsInCategory);
+  var listOfItems = [];
+  for (var key in listOfEntries) {
+    var entry = listOfEntries[key];
+    var item = entry.getValue(category);
+    listOfItems.push(item);
+  }
+  listOfItems.sort(orp.model.ContentRecord.compareOrdinals);
+  return listOfItems; 
+};
+
+
+// -------------------------------------------------------------------
+// Private methods
+// -------------------------------------------------------------------
+
+/**
+ * Throws an Error if there is no user currently logged in.
+ *
+ * @scope    private instance method
+ * @throws   Throws an Error if no user is logged in.
+ */
+orp.archive.StubArchive.prototype._throwErrorIfNoUserIsLoggedIn = function() {
+  if (!this._currentUser) {
+    var error = new Error(&quot;No user is logged in.  You can't write to the repository when nobody is logged in.&quot;);
+    throw error;
+  }
+};
+
+
+/**
+ * Given a UUID, returns the item or entry identified by that UUID.
+ *
+ * @scope    private instance method
+ * @param    uuid    The UUID of the item or entry to be returned. 
+ * @return   The item or entry identified by the given UUID.
+ */
+orp.archive.StubArchive.prototype._getContentRecordFromUuid = function(uuid) {
+  var item = this.getItemFromUuid(uuid);
+  if (item) {
+    return item;
+  } else {
+    return this._hashTableOfEntriesKeyedByUuid[uuid];
+  }
+};
+
+
+/**
+ * Returns a newly created UUID.
+ *
+ * @scope    private instance method
+ * @param    node    The node value that the new UUID should have. 
+ */
+orp.archive.StubArchive.prototype._generateUuid = function(node) {
+  if (node) {
+    return new orp.util.TimeBasedUuid({'node': node});
+  } else {
+    return new orp.util.TimeBasedUuid();
+  }
+};
+
+
+/**
+ * Creates a brand new UUID to allocate to an item or entry.
+ *
+ * @scope    private instance method
+ * @return   A newly created UUID.
+ */
+orp.archive.StubArchive.prototype._getNewUuid = function() {
+  var newUuid;
+  if (this._currentUser) {
+    var uuidOfCurrentUser = this._currentUser.getUuid();
+    var nodeForCurrentUser = uuidOfCurrentUser.getNode(); // &quot;0123456789AB&quot;;
+    newUuid = this._generateUuid(nodeForCurrentUser);
+  } else {
+    newUuid = this._generateUuid();
+  }
+  return newUuid;
+};
+
+
+/**
+ * Given an item representing a user, return the authentication info
+ * associated with that user.
+ *
+ * @scope    private instance method
+ * @param    user    An item representing a user. 
+ * @return   The authentication info for the user.
+ */
+orp.archive.StubArchive.prototype._getAuthenticationInfoForUser = function(user) {
+  return this._hashTableOfUserAuthenticationInfo[user.getUuid()];
+};
+
+
+/**
+ * Given a UUID, either (a) returns the existing item identified by that UUID, 
+ * or (b) creates an new item object, set its UUID, and returns that object.
+ *
+ * @scope    private instance method
+ * @param    uuid    The UUID of the item to be returned. 
+ * @return   The item identified by the given UUID.
+ */
+orp.archive.StubArchive.prototype._getItemFromUuidOrCreateNewItem = function(uuid) {
+  var item = this.getItemFromUuid(uuid);
+  if (!item) {
+    item = new orp.model.Item(this._world, uuid);
+    item._initialize();
+    this._hashTableOfItemsKeyedByUuid[uuid] = item;
+    this._currentTransaction.addRecord(item);
+  }
+  return item;
+};
+
+
+/**
+ * Creates the basic items that needed in order to do anything else, 
+ * like the items for &quot;name&quot;, &quot;attribute&quot;, and &quot;category&quot;.
+ *
+ * @scope    private instance method
+ */
+orp.archive.StubArchive.prototype._loadAxiomaticItemsFromFileAtURL = function(url) {
+  // var fileContentString = orp.util.getStringContentsOfFileAtURL(url);
+  var fileContentString = dojo.hostenv.getText(url);
+  // orp.util.assert(orp.util.isString(fileContentString));
+  orp.lang.assertType(fileContentString, String);
+  fileContentString += &quot; ] }&quot;;
+
+  var dehydratedRecords = null;
+  eval(&quot;dehydratedRecords = &quot; + fileContentString + &quot;;&quot;);
+  // orp.util.assert(orp.util.isObject(dehydratedRecords));
+  orp.lang.assertType(dehydratedRecords, Object);
+  var recordFormat = dehydratedRecords[orp.archive.StubArchive.JSON_MEMBER.FORMAT];
+  orp.lang.assert(recordFormat == orp.archive.StubArchive.JSON_FORMAT.FORMAT_2005_JUNE_CHRONOLOGICAL_LIST);
+  var listOfRecords = dehydratedRecords[orp.archive.StubArchive.JSON_MEMBER.RECORDS];
+  // orp.util.assert(orp.util.isArray(listOfRecords));
+  orp.lang.assertType(listOfRecords, Array);
+  
+  this._rehydrateRecords(listOfRecords);
+};
+
+
+/**
+ * Given a UUID, either (a) returns the existing item identified by that UUID, 
+ * or (b) creates an new item object, set its UUID, and returns that object.
+ *
+ * @scope    private instance method
+ * @param    inUuid    The UUID of the item to be returned. 
+ * @return   The item identified by the given UUID.
+ */
+orp.archive.StubArchive.prototype._getItemFromUuidOrBootstrapItem = function(uuid) {
+  var item = this.getItemFromUuid(uuid);
+  if (!item) {
+    item = new orp.model.Item(this.getWorld(), uuid);
+    this._hashTableOfItemsKeyedByUuid[uuid] = item;
+  }
+  return item;
+};
+
+/**
+ * Given a UUID, returns the existing entry identified by that UUID. 
+ * 
+ * @scope    private instance method
+ * @param    uuid    The UUID of the entry to be returned. 
+ * @return   The entry identified by the given UUID.
+ */
+orp.archive.StubArchive.prototype._getEntryFromUuid = function(uuid) {
+  return this._hashTableOfEntriesKeyedByUuid[uuid];
+};
+
+/**
+ * Given a UUID, either (a) returns the existing entry identified by that UUID, 
+ * or (b) creates an new entry object, set its UUID, and returns that object.
+ *
+ * @scope    private instance method
+ * @param    uuid    The UUID of the entry to be returned. 
+ * @return   The entry identified by the given UUID.
+ */
+orp.archive.StubArchive.prototype._getEntryFromUuidOrBootstrapEntry = function(uuid) {
+  var entry = this._hashTableOfEntriesKeyedByUuid[uuid];
+  if (!entry) {
+    entry = new orp.model.Entry(this.getWorld(), uuid);
+    this._hashTableOfEntriesKeyedByUuid[uuid] = entry;
+  }
+  return entry;
+};
+
+
+/**
+ * Given a dehydrated list of records, rehydrates each of the records.
+ *
+ * @scope    private instance method
+ * @param    listOfDehydratedRecords    A list of dehydrated records. 
+ */
+orp.archive.StubArchive.prototype._rehydrateRecords = function(listOfDehydratedRecords) {
+  var key;
+  var itemUuid;
+  var item;
+  var contentRecordUuid;
+  var contentRecord;
+  var JSON_MEMBER = orp.archive.StubArchive.JSON_MEMBER;
+
+  for (key in listOfDehydratedRecords) {
+    var dehydratedRecord = listOfDehydratedRecords[key];
+
+    var dehydratedTransaction = dehydratedRecord[JSON_MEMBER.TRANSACTION_CLASS];
+    if (dehydratedTransaction) {
+      var listOfRecordsInTransaction = dehydratedTransaction;
+      this._rehydrateRecords(listOfRecordsInTransaction);
+    } else {
+      var dehydratedItem = dehydratedRecord[JSON_MEMBER.ITEM_CLASS];
+      var dehydratedUser = dehydratedRecord[JSON_MEMBER.USER_CLASS];
+      var dehydratedVote = dehydratedRecord[JSON_MEMBER.VOTE_CLASS];
+      var dehydratedOrdinal = dehydratedRecord[JSON_MEMBER.ORDINAL_CLASS];
+      var dehydratedEntry = dehydratedRecord[JSON_MEMBER.ENTRY_CLASS];
+        
+      if (dehydratedItem) {
+        itemUuid = dehydratedItem[JSON_MEMBER.UUID];
+        item = this._getItemFromUuidOrBootstrapItem(itemUuid);
+        this._chronologicalListOfRecords.push(item);
+      }
+      
+      if (dehydratedUser) {
+        var userUuid = dehydratedUser[JSON_MEMBER.USER];
+        var userPasswordHash = dehydratedUser[JSON_MEMBER.PASSWORD];
+        var user = this._getItemFromUuidOrBootstrapItem(userUuid);
+        this._listOfUsers.push(user);
+        this._hashTableOfUserAuthenticationInfo[user.getUuid()] = userPasswordHash;
+      }
+      
+      if (dehydratedVote) {
+        var voteUuid = dehydratedVote[JSON_MEMBER.UUID];
+        var retainFlagString = dehydratedVote[JSON_MEMBER.RETAIN_FLAG];
+        var retainFlag = null;
+        if (retainFlagString == &quot;true&quot;) {
+          retainFlag = true;
+        }
+        if (retainFlagString == &quot;false&quot;) {
+          retainFlag = false;
+        }
+        orp.lang.assert(retainFlag !== null);
+        contentRecordUuid = dehydratedVote[JSON_MEMBER.RECORD];
+        contentRecord = this._getContentRecordFromUuid(contentRecordUuid);
+        var vote = new orp.model.Vote(this.getWorld(), voteUuid, contentRecord, retainFlag);
+        this._chronologicalListOfRecords.push(vote);
+      }
+      
+      if (dehydratedOrdinal) {
+        var ordinalUuid = dehydratedOrdinal[JSON_MEMBER.UUID];
+        var ordinalNumber = dehydratedOrdinal[JSON_MEMBER.ORDINAL_NUMBER];
+        contentRecordUuid = dehydratedOrdinal[JSON_MEMBER.RECORD];
+        contentRecord = this._getContentRecordFromUuid(contentRecordUuid);
+        var ordinal = new orp.model.Ordinal(this.getWorld(), ordinalUuid, contentRecord, ordinalNumber);
+        this._chronologicalListOfRecords.push(ordinal);
+      }
+      
+      if (dehydratedEntry) {
+        var entryUuid = dehydratedEntry[JSON_MEMBER.UUID];
+        var entry = this._getEntryFromUuidOrBootstrapEntry(entryUuid);
+        var previousEntryUuid = dehydratedEntry[JSON_MEMBER.PREVIOUS_VALUE];
+        var previousEntry = null;
+        if (previousEntryUuid) {
+          previousEntry = this._getEntryFromUuidOrBootstrapEntry(previousEntryUuid);
+        }
+ 
+        var dataTypeUuid = dehydratedEntry[JSON_MEMBER.TYPE];
+        var dataType = this._getItemFromUuidOrBootstrapItem(dataTypeUuid);
+        
+        if (dataTypeUuid == orp.model.World.UUID.TYPE_CONNECTION) {
+          var listOfItemUuids = dehydratedEntry[JSON_MEMBER.ITEM];
+          var firstItemUuid = listOfItemUuids[0];
+          var secondItemUuid = listOfItemUuids[1];
+          var firstItem = this._getItemFromUuidOrBootstrapItem(firstItemUuid);
+          var secondItem = this._getItemFromUuidOrBootstrapItem(secondItemUuid);
+
+          var listOfAttributeUuids = dehydratedEntry[JSON_MEMBER.ATTRIBUTE];
+          var firstAttributeUuid = listOfAttributeUuids[0];
+          var secondAttributeUuid = listOfAttributeUuids[1];
+          var firstAttribute = this._getItemFromUuidOrBootstrapItem(firstAttributeUuid);
+          var secondAttribute = this._getItemFromUuidOrBootstrapItem(secondAttributeUuid);
+          
+          var pairOfItems = [firstItem, secondItem];
+          var pairOfAttributes = [firstAttribute, secondAttribute];
+          entry._rehydrate(pairOfItems, pairOfAttributes, null, previousEntry, dataType);
+        } else {
+          itemUuid = dehydratedEntry[JSON_MEMBER.ITEM];
+          item = this._getItemFromUuidOrBootstrapItem(itemUuid);
+          var attributeUuid = dehydratedEntry[JSON_MEMBER.ATTRIBUTE];
+          var attribute = null;
+          if (attributeUuid) {
+            attribute = this._getItemFromUuidOrBootstrapItem(attributeUuid);
+          } else {
+            orp.lang.assert(false); // the attributeUuid should always be there
+          }
+          var rawData = dehydratedEntry[JSON_MEMBER.VALUE];
+          var finalData = null;
+          switch (dataTypeUuid) {
+            case orp.model.World.UUID.TYPE_ITEM:
+              finalData = this._getItemFromUuidOrBootstrapItem(rawData);
+              break;
+            case orp.model.World.UUID.TYPE_TEXT:
+              finalData = this.decodeText(rawData);
+              break;
+            case orp.model.World.UUID.TYPE_NUMBER:
+              finalData = parseFloat(rawData);
+              break;
+            case orp.model.World.UUID.TYPE_DATE:
+              finalData = new orp.util.DateValue(rawData);
+              // if (!finalData.isValid()) {
+              //   alert(rawData + &quot; &quot; + finalData);
+              // }
+              orp.lang.assert(finalData.isValid());
+              break;
+            default:
+              orp.lang.assert(false, 'Unknown data type while _rehydrating()');
+          }
+          entry._rehydrate(item, attribute, finalData, previousEntry, dataType);
+        }
+        this._chronologicalListOfRecords.push(entry);
+      }
+      
+    }
+  }
+};
+
+
+// -------------------------------------------------------------------
+// End of file
+// -------------------------------------------------------------------

Deleted: trunk/source/model/DeltaVirtualServer.js
===================================================================
--- trunk/source/model/DeltaVirtualServer.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/DeltaVirtualServer.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -1,498 +0,0 @@
-/*****************************************************************************
- DeltaVirtualServer.js
- 
-******************************************************************************
- Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
-  
- Copyright rights relinquished under the Creative Commons  
- Public Domain Dedication:
-    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
-  
- You can copy freely from this file.  This work may be freely reproduced, 
- distributed, transmitted, used, modified, built upon, or otherwise exploited
- by anyone for any purpose.
-  
- This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
- of any kind, either express or implied, including, without limitation, any 
- warranties or conditions of title, non-infringement, merchantability, or 
- fitness for a particular purpose. You are solely responsible for determining 
- the appropriateness of using or distributing the work and assume all risks 
- associated with use of this work, including but not limited to the risks and 
- costs of errors, compliance with applicable laws, damage to or loss of data 
- or equipment, and unavailability or interruption of operations.
-
- In no event shall the authors or contributors have any liability for any 
- direct, indirect, incidental, special, exemplary, or consequential damages,
- however caused and on any theory of liability, whether in contract, strict 
- liability, or tort (including negligence), arising in any way out of or in 
- connection with the use or distribution of the work.
-*****************************************************************************/
-
-
-// -------------------------------------------------------------------
-// Provides and Requires
-// -------------------------------------------------------------------
-dojo.provide(&quot;orp.model.DeltaVirtualServer&quot;);
-dojo.require(&quot;orp.model.StubVirtualServer&quot;);
-dojo.require(&quot;orp.model.World&quot;);
-dojo.require(&quot;orp.model.Vote&quot;);
-dojo.require(&quot;orp.model.FileSaver&quot;);
-dojo.require(&quot;orp.model.HttpSaver&quot;);
-dojo.require(&quot;orp.lang.Lang&quot;);
-
-// -------------------------------------------------------------------
-// Dependencies, expressed in the syntax that JSLint understands:
-// 
-/*global window */
-/*global XMLHttpRequest, ActiveXObject  */
-/*global Util, DateValue  */
-/*global World, Item, Entry, Ordinal, Vote  */
-// -------------------------------------------------------------------
-
-
-// -------------------------------------------------------------------
-// Constructor
-// -------------------------------------------------------------------
-/**
- * The DeltaVirtualServer is a datastore that loads and saves
- * an entire World of items as a single monolithic JSON string.
- *
- * @scope    public instance constructor
- * @param    inJsonRepositoryString    A JSON string literal representing the world of items. 
- */
-orp.model.DeltaVirtualServer = function(repositoryName, pathToTrunkDirectory, optionalDefaultOverrides) {
-  orp.model.StubVirtualServer.call(this, pathToTrunkDirectory, optionalDefaultOverrides);
-  this._repositoryName = repositoryName;
-  this._pathToTrunkDirectory = &quot;&quot;;
-  if (pathToTrunkDirectory) {
-    this._pathToTrunkDirectory = pathToTrunkDirectory;
-  }
-  this._hasEverFailedToSaveFlag = false;
-};
-
-dj_inherits(orp.model.DeltaVirtualServer, orp.model.StubVirtualServer);  // makes DeltaVirtualServer be a subclass of StubVirtualServer
-
-
-// -------------------------------------------------------------------
-// Public constants
-// -------------------------------------------------------------------
-orp.model.DeltaVirtualServer.PATH_TO_REPOSITORY_DIRECTORY = &quot;repositories&quot;;
-
-
-// -------------------------------------------------------------------
-// Public methods
-// -------------------------------------------------------------------
-
-/**
- * Initializes the instance variables for a newly created DeltaVirtualServer,
- * and does the initial loading of at least the axiomatic items.
- *
- * @scope    public instance method
- * @param    world    The world that we provide data for. 
- */
-orp.model.DeltaVirtualServer.prototype.setWorldAndLoadAxiomaticItems = function(world) {
-  this._initialize(world);
-  this._loadAxiomaticItemsFromFileAtURL(this._dehydratedAxiomFileURL);
-
-  var repositoryFileName = this._repositoryName + &quot;.json&quot;;
-  var repositoryUrl = &quot;&quot;;
-  if (this._needCompletePath) {
-    repositoryUrl = this._completePathToTrunkDirectory + '/';
-  }
-  repositoryUrl += orp.model.DeltaVirtualServer.PATH_TO_REPOSITORY_DIRECTORY + &quot;/&quot; + repositoryFileName;
-  // var repositoryContentString = orp.util.getStringContentsOfFileAtURL(repositoryUrl);
-  var repositoryContentString = dojo.hostenv.getText(repositoryUrl);
-  repositoryContentString += &quot; ] }&quot;;
-
-  this._loadWorldFromJsonString(repositoryContentString);
-};
-
-
-// -------------------------------------------------------------------
-// Private Methods
-// -------------------------------------------------------------------
-
-/**
- * Loads a world of items from a dehydrated JSON string.
- *
- * Given a world of items in JSON format, bootstraps new 
- * instances of items corresponding to the dehydrated data.
- * 
- * @scope    private instance method
- * @param    jsonRepositoryString    A JSON string literal representing the world of items. 
- */
-orp.model.DeltaVirtualServer.prototype._loadWorldFromJsonString = function(jsonRepositoryString) {
-
-  // load the list of records
-  orp.lang.assertType(jsonRepositoryString, String);
-  var dehydratedRecords = null;
-  eval(&quot;dehydratedRecords = &quot; + jsonRepositoryString + &quot;;&quot;);
-  orp.lang.assertType(dehydratedRecords, Object);
-  var recordFormat = dehydratedRecords[orp.model.StubVirtualServer.JSON_MEMBER.FORMAT];
-  orp.lang.assert(recordFormat == orp.model.StubVirtualServer.JSON_FORMAT.FORMAT_2005_JUNE_CHRONOLOGICAL_LIST);
-  var listOfRecords = dehydratedRecords[orp.model.StubVirtualServer.JSON_MEMBER.RECORDS];
-  orp.lang.assertType(listOfRecords, Array);
-  
-  var listOfUsers = null;
-  
-  this._rehydrateRecords(listOfRecords);
-};
-
-
-/**
- * Given a string, returns a copy of the string that is less than
- * 80 characters long.
- *
- * @scope    private instance method
- * @param    string    A string that may need truncating.
- * @return   A string that is no longer than 80 characters long.
- */
-orp.model.DeltaVirtualServer.prototype._truncateString = function(string) {
-  var maxLength = 80;
-  var ellipsis = &quot;...&quot;;
-  var returnString = &quot;&quot;;
-  if (string.length &gt; maxLength) {
-    returnString = (string.substring(0, (maxLength - ellipsis.length)) + ellipsis);
-  } else {
-    returnString = string;
-  }
-  return this.encodeText(returnString);
-};
-
-
-/**
- * Returns a big string, containing JavaScript &quot;object literal&quot;
- * representations of all of the records in a Transaction.
- *
- * @scope    private instance method
- * @param    transaction    A transaction object.
- * @return   A JSON string literal, representing the records in the transaction. 
- */
-orp.model.DeltaVirtualServer.prototype._getJsonStringRepresentingTransaction = function(transaction) {
-  var indent = &quot;  &quot;;
-  var listOfRecords = transaction.getRecords();
-  if (!listOfRecords || listOfRecords.length === 0) {
-    return &quot;&quot;;
-  }
-  
-  if (listOfRecords.length == 1) {
-    return this._getJsonStringRepresentingRecords(listOfRecords, indent);
-  } else {
-    indent = &quot;    &quot;;
-    var listOfStrings = [];
-    listOfStrings.push(&quot;  // =======================================================================\n&quot;);
-    listOfStrings.push('  { &quot;' + orp.model.StubVirtualServer.JSON_MEMBER.TRANSACTION_CLASS + '&quot;: [\n');
-    var content = this._getJsonStringRepresentingRecords(transaction.getRecords(), indent);
-    listOfStrings.push(content);
-    listOfStrings.push('  ]\n');
-    listOfStrings.push('  }');
-    
-    var finalString = listOfStrings.join(&quot;&quot;);
-    return finalString;
-  }
-};
-
-
-/**
- *
- */
-orp.model.DeltaVirtualServer.prototype._getTypedDisplayStringForItem = function(item) {
-  var returnString = &quot;(&quot;;
-  if (item) {
-    if (item instanceof orp.model.Item) {
-      var category = item.getFirstCategory();
-      if (category) {
-        returnString += this._truncateString(category.getDisplayString(&quot;???&quot;)) + &quot;: &quot;;
-      }
-      returnString += this._truncateString(item.getDisplayString(&quot;???&quot;));
-    }
-    if (item instanceof orp.model.Entry) {
-      returnString += &quot;Entry&quot;;
-    }
-  }
-  returnString += &quot;)&quot;;
-  return returnString;
-};
-
-  
-/**
- * Returns a big string, containing JavaScript &quot;object literal&quot;
- * representations of the records.
- *
- * @scope    private instance method
- * @param    listOfRecords    A list of the records to include in the JSON string.
- * @param    indent    Optional. A string of spaces to prepend to each line.
- * @return   A JSON string literal, representing the records. 
- */
-orp.model.DeltaVirtualServer.prototype._getJsonStringRepresentingRecords = function(listOfRecords, indent) {
-  indent = indent || &quot;&quot;;
-  var i;
-  var listOfStrings = [];
-  var firstContentRecord = true;
-  var itemDisplayNameSubstring;
-  var entryDisplayNameSubstring;
-  var listOfUsers = null;
-  var commentString;
-  var generateComments = false;
-  var JSON_MEMBER = orp.model.StubVirtualServer.JSON_MEMBER;
-
-  if (!generateComments) {
-    indent = &quot;&quot;;
-  }
-  
-  for (i in listOfRecords) {
-    var record = listOfRecords[i];
-    if (firstContentRecord) {
-      firstContentRecord = false;
-    } else {
-      listOfStrings.push(',\n');
-    }
-    if (generateComments) {
-      listOfStrings.push(indent + '// -----------------------------------------------------------------------\n');
-    }
-    
-    if (record instanceof orp.model.Item) {
-      var item = record;
-      if (generateComments) {
-        listOfStrings.push(indent + '// ' + this._getTypedDisplayStringForItem(item) + '\n');
-        listOfStrings.push(indent + '//           by (' + this._truncateString(item.getUserstamp().getDisplayString()) + ')');
-        listOfStrings.push(' on (' + orp.util.DateValue.getStringMonthDayYear(item.getCreationDate()) + ')\n');
-      }
-      if (!this._jsonFragmentForItemPrefix) {
-        this._jsonFragmentForItemPrefix = indent + '{ &quot;' + JSON_MEMBER.ITEM_CLASS + '&quot;: ';
-        this._jsonFragmentForItemPrefix += '{ &quot;' + JSON_MEMBER.UUID + '&quot;: ';
-      }
-      listOfStrings.push(this._jsonFragmentForItemPrefix);
-      listOfStrings.push(item._getUuidInQuotes());
-      listOfStrings.push(' } }');
-      
-      if (!listOfUsers) {
-        listOfUsers = this.getUsers();
-      }
-      if (orp.util.isObjectInSet(item, listOfUsers)) {
-        var user = item;
-        var password = this._hashTableOfUserAuthenticationInfo[user.getUuid()];
-        var passwordString = &quot;null&quot;;
-        if (password) {
-          passwordString = '&quot;' + password + '&quot;';
-        }
-        listOfStrings.push(',\n');
-        if (generateComments) {
-          listOfStrings.push(indent + '// -----------------------------------------------------------------------\n');
-          listOfStrings.push(indent + '// ' + this._getTypedDisplayStringForItem(user) + '\n');
-        }
-        listOfStrings.push(indent + '{ &quot;' + JSON_MEMBER.USER_CLASS + '&quot;: ' + '{\n');
-        listOfStrings.push(indent + '         &quot;' + JSON_MEMBER.USER + '&quot;: ' + user._getUuidInQuotes() + ',\n');
-        listOfStrings.push(indent + '     &quot;' + JSON_MEMBER.PASSWORD + '&quot;: ' + passwordString + ' }\n');
-        listOfStrings.push(indent + '}');
-      }
-    }
-
-    if (record instanceof orp.model.Vote) {
-      var vote = record;
-      entryDisplayNameSubstring = this._getTypedDisplayStringForItem(vote.getContentRecord());
-      var deleteVsRetainString = vote.getRetainFlag() ? &quot;RETAIN&quot; : &quot;DELETE&quot;;
-      if (generateComments) {
-        listOfStrings.push(indent + '// vote to ' + deleteVsRetainString + &quot; &quot; + entryDisplayNameSubstring + '\n');
-      }
-      listOfStrings.push(indent + '{ &quot;' + JSON_MEMBER.VOTE_CLASS + '&quot;: ' + '{\n');
-      listOfStrings.push(indent + '         &quot;' + JSON_MEMBER.UUID + '&quot;: ' + vote._getUuidInQuotes() + ',\n');
-      listOfStrings.push(indent + '       &quot;' + JSON_MEMBER.RECORD + '&quot;: ' + vote.getContentRecord()._getUuidInQuotes() + ',\n');
-      listOfStrings.push(indent + '   &quot;' + JSON_MEMBER.RETAIN_FLAG + '&quot;: &quot;' + vote.getRetainFlag() + '&quot;');
-      listOfStrings.push('  }\n');
-      listOfStrings.push(indent + '}');
-    }
-
-    if (record instanceof orp.model.Ordinal) {
-      var ordinal = record;
-      entryDisplayNameSubstring = this._getTypedDisplayStringForItem(ordinal.getContentRecord());
-      if (generateComments) {
-        listOfStrings.push(indent + '// ordinal # ' + ordinal.getOrdinalNumber() + &quot; for &quot; + entryDisplayNameSubstring + '\n');
-      }
-      listOfStrings.push(indent + '{ &quot;' + JSON_MEMBER.ORDINAL_CLASS + '&quot;: ' + '{' + '\n');
-      listOfStrings.push(indent + '         &quot;' + JSON_MEMBER.UUID + '&quot;: ' + ordinal._getUuidInQuotes() + ',\n');
-      listOfStrings.push(indent + '       &quot;' + JSON_MEMBER.RECORD + '&quot;: ' + ordinal.getContentRecord()._getUuidInQuotes() + ',\n');
-      listOfStrings.push(indent + '        &quot;' + JSON_MEMBER.ORDINAL_NUMBER + '&quot;: &quot;' + ordinal.getOrdinalNumber() + '&quot;');
-      listOfStrings.push('  }\n');
-      listOfStrings.push(indent + '}');
-    }
-
-    if (record instanceof orp.model.Entry) {
-      var entry = record;
-      var entryType = entry.getType();
-      var typeUuid = entryType.getUuid();
-      // var entryString = &quot;&quot;;
-      if (generateComments) {
-        listOfStringsForEntry = [];
-      } else {
-        listOfStringsForEntry = listOfStrings;
-      }
-      listOfStringsForEntry.push(indent + '{ &quot;' + JSON_MEMBER.ENTRY_CLASS + '&quot;: ' + '{\n');
-      listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.UUID + '&quot;: ' + entry._getUuidInQuotes() + ',\n');
-      var previousEntry = entry.getPreviousEntry();
-      if (previousEntry) {
-        listOfStringsForEntry.push(indent + '&quot;' + JSON_MEMBER.PREVIOUS_VALUE + '&quot;: ' + previousEntry._getUuidInQuotes() + ',\n');
-      }
-      listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.TYPE + '&quot;: &quot;' + typeUuid.toString() + '&quot;,\n');
-      if (generateComments) {
-        commentString = &quot;&quot;;
-      }
-      if (typeUuid.toString() == orp.model.World.UUID.TYPE_CONNECTION) {
-        var pairOfItems = entry.getItem();
-        var firstItem = pairOfItems[0];
-        var secondItem = pairOfItems[1];
-        listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.ITEM + '&quot;: [' + firstItem._getUuidInQuotes() + ', ' + secondItem._getUuidInQuotes() + '],\n');
-        var pairOfAttributes = entry.getAttribute();
-        var firstAttribute = pairOfAttributes[0];
-        var secondAttribute = pairOfAttributes[1];
-        listOfStringsForEntry.push(indent + '    &quot;' + JSON_MEMBER.ATTRIBUTE + '&quot;: [' + firstAttribute._getUuidInQuotes() + ', ' + secondAttribute._getUuidInQuotes() + ']');
-        if (generateComments) {
-          commentString += indent + '// ' + this._getTypedDisplayStringForItem(firstItem);
-          commentString += &quot;.(&quot; + this._truncateString(firstAttribute.getDisplayString(&quot;???&quot;)) + &quot;)&quot;;
-          commentString += &quot; = &quot; + this._getTypedDisplayStringForItem(secondItem) + &quot;\n&quot;;
-          commentString += indent + '// ' + this._getTypedDisplayStringForItem(secondItem);
-          commentString += &quot;.(&quot; + this._truncateString(secondAttribute.getDisplayString(&quot;???&quot;)) + &quot;)&quot;;
-          commentString += &quot; = &quot; + this._getTypedDisplayStringForItem(firstItem) + &quot;\n&quot;;
-        }
-      } else {
-        var attribute = entry.getAttribute();
-        // if (!(attribute instanceof orp.model.Item)) {
-        //   alert(entry + &quot;\n&quot; + attribute);
-        // }
-        listOfStringsForEntry.push(indent + '    &quot;' + JSON_MEMBER.ATTRIBUTE + '&quot;: ' + attribute._getUuidInQuotes() + ',\n');
-        listOfStringsForEntry.push(indent + '         &quot;' + JSON_MEMBER.ITEM + '&quot;: ' + entry.getItem()._getUuidInQuotes() + ',\n');
-        var contentData = entry.getValue();
-        
-        var valueString = null;
-        var valueComment = null;
-        switch (typeUuid.toString()) {
-          case orp.model.World.UUID.TYPE_NUMBER: 
-            valueString = '&quot;' + contentData + '&quot;';
-            if (generateComments) {valueComment = contentData;}
-            break;
-          case orp.model.World.UUID.TYPE_TEXT: 
-            valueString = '&quot;' + this.encodeText(contentData) + '&quot;';
-            if (generateComments) {valueComment = '&quot;' + this._truncateString(contentData) + '&quot;';}
-            break;
-          case orp.model.World.UUID.TYPE_DATE: 
-            valueString = '&quot;' + contentData.toString() + '&quot;';
-            if (generateComments) {valueComment = valueString;}
-            break;
-          case orp.model.World.UUID.TYPE_ITEM: 
-            valueString = contentData._getUuidInQuotes();
-            if (generateComments) {valueComment = this._getTypedDisplayStringForItem(contentData);}
-            break;
-          default:
-            orp.lang.assert(false, &quot;no such type: &quot; + entryType.getDisplayString());
-        }
-        listOfStringsForEntry.push(indent + '        &quot;' + JSON_MEMBER.VALUE + '&quot;: ' + valueString);
-        if (generateComments) {
-          commentString += indent + '// ' + this._getTypedDisplayStringForItem(entry.getItem());
-          commentString += &quot;.(&quot; + this._truncateString(attribute.getDisplayString(&quot;???&quot;)) + &quot;)&quot;;
-          commentString += &quot; = &quot; + valueComment + &quot;\n&quot;;
-        }
-      }
-      if (generateComments) {
-        commentString += indent + '//           by (' + this._truncateString(entry.getUserstamp().getDisplayString()) + ')';
-        commentString += ' on (' + orp.util.DateValue.getStringMonthDayYear(entry.getCreationDate()) + ')\n';
-        listOfStrings.push(commentString);
-        for (var j in listOfStringsForEntry) {
-          listOfStrings.push(listOfStringsForEntry[j]);
-        }
-      }
-      // listOfStrings.push(entryString);
-      listOfStrings.push('  }\n');
-      listOfStrings.push(indent + '}');
-    }
-  }
-  
-  var finalString = listOfStrings.join(&quot;&quot;);
-  return finalString;
-};
-
-
-/**
- * @scope    private instance method
- * @param    overwriteIfExists    Optional
- * @return   success
- */
-orp.model.DeltaVirtualServer.prototype._createNewRepository = function(overwriteIfExists) {
-  if (this._saverObject) {
-    alert(&quot;this._saverObject is already initialized.&quot;);
-    return false;
-  }
-  if (window.location) {
-    if (window.location.protocol == &quot;http:&quot;) {
-      this._saverObject = new orp.model.HttpSaver(this._repositoryName, this._pathToTrunkDirectory);
-    }
-    if (window.location.protocol == &quot;file:&quot;) {
-      this._saverObject = new orp.model.FileSaver(this._repositoryName, this._pathToTrunkDirectory);
-    }
-  }
-  if (!this._saverObject) {
-    if (!this._hasEverFailedToSaveFlag) {
-      window.alert(&quot;I can't save changes to server, because this page was loaded from a \&quot;<A HREF="file:///\">file:///\</A>&quot; location, not a real \&quot;<A HREF="http://\">http://\</A>&quot; location.  Sorry.&quot;); 
-      this._hasEverFailedToSaveFlag = true;
-    }
-    return false;
-  }
-  var text = '{ &quot;format&quot;: &quot;' + orp.model.StubVirtualServer.JSON_FORMAT.FORMAT_2005_JUNE_CHRONOLOGICAL_LIST + '&quot;, \n';
-  text +=    '  &quot;records&quot;: [\n';
-  text +=    '  // =======================================================================\n';
-  text +=    '  { &quot;Transaction&quot;: [ ]\n';
-  text +=    '  }';
-  return this._saverObject.writeText(text, overwriteIfExists);
-};
-
-
-/**
- * Sends all the changes to the server, so that the server can record the
- * changes.
- *
- * @scope    private instance method
- * @param    forceSave    Optional. Forces a save if set to true. 
- * @return   The list of changes made. 
- */
-orp.model.DeltaVirtualServer.prototype._saveChangesToServer = function(forceSave) {
-  var currentTransaction = this.getCurrentTransaction();
-  var listOfChangesMade = currentTransaction.getRecords();
-  if (!forceSave &amp;&amp; listOfChangesMade.length === 0) {
-    return listOfChangesMade;
-  }
-  
-  if (!this._saverObject) {
-    if (window.location) {
-      if (window.location.protocol == &quot;http:&quot;) {
-        this._saverObject = new orp.model.HttpSaver(this._repositoryName, this._pathToTrunkDirectory);
-      }
-      if (window.location.protocol == &quot;file:&quot;) {
-        this._saverObject = new orp.model.FileSaver(this._repositoryName, this._pathToTrunkDirectory);
-      }
-    }
-  }
-  
-  var key;
-  var newRecord;
-  for (key in listOfChangesMade) {
-    newRecord = listOfChangesMade[key];
-    this._chronologicalListOfRecords.push(newRecord);
-  }
-
-  if (this._saverObject) {
-    var textToAppend = &quot;,\n&quot; + this._getJsonStringRepresentingTransaction(currentTransaction);
-    this._saverObject.appendText(textToAppend);
-  } else {
-    if (!this._hasEverFailedToSaveFlag) {
-      window.alert(&quot;I can't save changes to server, because this page was loaded from a \&quot;<A HREF="file:///\">file:///\</A>&quot; location, not a real \&quot;<A HREF="http://\">http://\</A>&quot; location.  Sorry.&quot;); 
-      this._hasEverFailedToSaveFlag = true;
-    }
-  }
-  
-  this._currentTransaction = null;
-  return listOfChangesMade;
-};
-
-
-// -------------------------------------------------------------------
-// End of file
-// -------------------------------------------------------------------

Deleted: trunk/source/model/FileSaver.js
===================================================================
--- trunk/source/model/FileSaver.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/FileSaver.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -1,289 +0,0 @@
-/*****************************************************************************
- FileSaver.js
- 
-******************************************************************************
- The code in this file is a heavily modified version of code that was copied
- from the TiddlyWiki and GTDTiddlyWiki code base.
- 
- The original code is Copyright (c) Osmosoft Limited.  The original copyright 
- notice is included below, along with the license conditions and disclaimer.  
- 
- OpenRecord modifications by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
-
- For the OpenRecord modifications, the Copyright rights are relinquished under  
- the Creative Commons Public Domain Dedication:
-    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
-
-******************************************************************************
-TiddlyWiki 1.2.6 by Jeremy Ruston, (jeremy [at] osmosoft [dot] com)
-Incorporating improvements by Isao Sonobe, <A HREF="http://www-gauge.scphys.kyoto-u.ac.jp/~sonobe/OgreKit/OgreKitWiki.html">http://www-gauge.scphys.kyoto-u.ac.jp/~sonobe/OgreKit/OgreKitWiki.html</A>
-GTDTiddlyWiki modification by Nathan Bowers, (wiki [at] snapgrid [dot] com)
-Safari Compatability by Jonathan Paisley at <A HREF="http://www.dcs.gla.ac.uk/~jp/">http://www.dcs.gla.ac.uk/~jp/</A>
-
-Copyright (c) Osmosoft Limited, 14 April 2005
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-Redistributions of source code must retain the above copyright notice, this
-list of conditions and the following disclaimer.
-
-Redistributions in binary form must reproduce the above copyright notice, this
-list of conditions and the following disclaimer in the documentation and/or other
-materials provided with the distribution.
-
-Neither the name of the Osmosoft Limited nor the names of its contributors may be
-used to endorse or promote products derived from this software without specific
-prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
-EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
-*****************************************************************************/
-
-
-// -------------------------------------------------------------------
-// Provides and Requires
-// -------------------------------------------------------------------
-dojo.provide(&quot;orp.model.FileSaver&quot;);
-dojo.require(&quot;orp.model.DeltaVirtualServer&quot;);
-dojo.require(&quot;orp.lang.Lang&quot;);
-
-/**
- * The FileSaver class knows how to save text to a local file.
- *
- * @param    repositoryName                 // e.g. demo_page
- * @param    pathToTrunkDirectory           // Not needed if window.location.pathname is in the trunk directory.
- * @scope    public instance constructor
- */
-orp.model.FileSaver = function(repositoryName, pathToTrunkDirectory) {
-  this._repositoryName = repositoryName;
-  
-  // Step 1: Build the fileUrl
-  // 
-  // Our saveTextToFile() method needs a fileUrl that looks like this:
-  //   fileUrl = &quot;K:\\www\\htdocs\\openrecord\\demo\\current\\trunk\\repositories\\demo_page.json&quot;;
-  // 
-  // We start with a value in this._repositoryName that looks like this:
-  //   this._repositoryName == &quot;demo_page&quot;
-
-  // URLs like these don't work:
-  //   fileUrl = &quot;repositories/demo_page.json&quot;;
-  //   fileUrl = &quot;repositories\\demo_page.json&quot;;
-  //   fileUrl = &quot;\\repositories\\demo_page.json&quot;;
-  //   fileUrl = &quot;K:/www/htdocs/openrecord/demo/current/trunk/repositories/demo_page.json&quot;;
-
-  var listOfAdditions = [];
-  if (pathToTrunkDirectory &amp;&amp; pathToTrunkDirectory !== &quot;&quot;) {
-    listOfAdditions.push(pathToTrunkDirectory);
-  }
-  listOfAdditions.push(orp.model.DeltaVirtualServer.PATH_TO_REPOSITORY_DIRECTORY);
-  listOfAdditions.push(this._repositoryName + &quot;.json&quot;);
-  this._fileUrl = this._getLocalPathFromWindowLocation(listOfAdditions);
-};
-
-
-/**
- * Appends text to a file.
- *
- * @scope    public instance method
- */
-orp.model.FileSaver.prototype.appendText = function(textToAppend) {
-  var append = true;
-  this._saveTextToFile(textToAppend, this._fileUrl, append);
-};
-
-orp.model.FileSaver.prototype.writeText = function(textToWrite, overwriteIfExists) {
-  var append = false;
-  this._saveTextToFile(textToWrite, this._fileUrl, append);
-};
-
-/**
- * Save the text to the file at the given URL.
- *
- * @scope    private instance method
- * @return   Returns true if the text was saved.
- */
-orp.model.FileSaver.prototype._saveTextToFile = function(text, fileUrl, append) {
-  // Make sure we were loaded from a &quot;file:&quot; URL
-  if (window.location.protocol != &quot;file:&quot;) {
-    orp.lang.assert(false, 'FileSaver.js can only be used for pages loaded from a &quot;<A HREF="file:///">file:///</A>&quot; location');
-  }
-
-  var success = this._mozillaSaveToFile(text, fileUrl, append);
-  if (!success) {
-    success = this._ieSaveToFile(text, fileUrl, append);
-  }
-  return(success);
-};
-
-
-/**
- * Save the text to the file at the given filePath.
- *
- * @scope    private instance method
- * @return   Returns true if the text was saved, false if there was an error, or null if we couldn't even try.
- */
-orp.model.FileSaver.prototype._mozillaSaveToFile = function(text, filePath, append) {
-  if (window.Components) {
-    try {
-      netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;);
-      var file = Components.classes[&quot;@mozilla.org/file/local;1&quot;].createInstance(Components.interfaces.nsILocalFile);
-      file.initWithPath(filePath);
-      if (!file.exists()) {
-        // Not all JavaScript implementations  support octal literals,
-        // so it's not safe to use '0664' here:
-        //   file.create(0, 0664);
-        //   file.permissions = 0664; // Because create ignores the permissions argument, at least on Mignon's Mac.
-        file.create(0, 0x1B4);
-        file.permissions = 0x1B4; // Because create ignores the permissions argument, at least on Mignon's Mac.
-      }
-      var outputStream = Components.classes[&quot;@mozilla.org/network/file-output-stream;1&quot;].createInstance(Components.interfaces.nsIFileOutputStream);
-      if (append) {
-        outputStream.init(file, 0x10 | 0x02, 0x0004, null);
-      } else {
-        outputStream.init(file, 0x20 | 0x02, 0x0004, null);
-      }
-      outputStream.write(text, text.length);
-      outputStream.flush();
-      outputStream.close();
-      return true;
-    }
-    catch(exception) {
-      alert(&quot;Exception while attempting to save\n\n&quot; + exception);
-      return false;
-    }
-  } else {
-    alert(&quot;window.Components == null&quot;);
-  }
-  return null;
-};
-
-
-/**
- * Save the text to the file at the given filePath.
- *
- * @scope    private instance method
- * @return   Returns true if the text was saved, or false if there was an error.
- */
-orp.model.FileSaver.prototype._ieSaveToFile = function(text, filePath, append) {
-  try {
-    var fileSystemObject = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);
-  }
-  catch(exception) {
-    alert(&quot;Exception while attempting to save\n\n&quot; + exception.toString());
-    return false;
-  }
-  if (append) {
-    orp.lang.assert(false, &quot;PENDING: still need to write code for this&quot;);
-  } else {
-    var file = fileSystemObject.OpenTextFile(filePath, 2, -1, 0);
-  }
-  file.Write(text);
-  file.Close();
-  return true;
-};
-
-
-/**
- * This method looks at the URL value in the window.location property,
- * strips the filename off the end, appends any given path elements,
- * converts the whole thing to a format that is compatible with the 
- * local file system, and returns the new local path.
- *
- * @scope    private instance method
- * @return   Returns a full local pathname.
- */
-orp.model.FileSaver.prototype._getLocalPathFromWindowLocation = function(listOfAdditions) {
-  // Example location:
-  //   location.href     == <A HREF="file:///D:/amy/openrecord/foo.html#bar">file:///D:/amy/openrecord/foo.html#bar</A>
-  //   location.protocol == file:
-  //   location.pathname ==        /D:/amy/openrecord/foo.html
-  //   location.hash     ==                                   #bar
-
-  // Get the URL of the document
-  var pathname = window.location.pathname;
-  
-  
-  // Step 1: Make the requested additions to the pathname
-  var arrayOfParts = pathname.split('/');
-  arrayOfParts.pop();  // get rid of the final &quot;/foo.html&quot; part
-  for (var i in listOfAdditions) {
-    var additionalPart = listOfAdditions[i];
-    arrayOfParts.push(additionalPart);
-  }
-  pathname = arrayOfParts.join('/');
-
-  
-  // Step 2: Figure out what type of URL we're working with
-  // Constants
-  var PathType = {
-    LOCAL_PC:        &quot;LOCAL_PC&quot;,          // &quot;<A HREF="file:///x:/path/path...">file:///x:/path/path...</A>&quot; 
-    LOCAL_UNIX_MAC:  &quot;LOCAL_UNIX_MAC&quot;,    // &quot;<A HREF="file:///path/path...">file:///path/path...</A>&quot;
-    NETWORK_PC:      &quot;NETWORK_PC&quot;,        // &quot;<A HREF="file://server/share/path/path...">file://server/share/path/path...</A>&quot;
-    NETWORK_FIREFOX: &quot;NETWORK_FIREFOX&quot; }; // &quot;<A HREF="file://///server/share/path/path...">file://///server/share/path/path...</A>&quot;
-  // &quot;<A HREF="file:///x:/path/path...">file:///x:/path/path...</A>&quot;             == PathType.LOCAL_PC        --&gt; &quot;x:\path\path...&quot;
-  // &quot;<A HREF="file:///path/path...">file:///path/path...</A>&quot;                == PathType.LOCAL_UNIX_MAC  --&gt; &quot;/path/path...&quot;
-  // &quot;<A HREF="file://server/share/path/path...">file://server/share/path/path...</A>&quot;    == PathType.NETWORK_PC      --&gt; &quot;\\server\share\path\path...&quot;
-  // &quot;<A HREF="file://///server/share/path/path...">file://///server/share/path/path...</A>&quot; == PathType.NETWORK_FIREFOX --&gt; &quot;\\server\share\path\path...&quot;
-
-  var pathType = null;
-  if (pathname.charAt(2) == &quot;:&quot;) {
-    pathType = PathType.LOCAL_PC;
-  } else if (pathname.indexOf(&quot;///&quot;) === 0) {
-    pathType = PathType.NETWORK_FIREFOX;
-  } else if (pathname.indexOf(&quot;/&quot;) === 0) {
-    pathType = PathType.LOCAL_UNIX_MAC;
-  } else {
-    pathType = PathType.NETWORK_PC;
-  }
-
-
-  // Step 3: Convert the URL to a file path
-  var localPath = pathname;
-  switch (pathType) {
-    case PathType.LOCAL_PC:
-      // example: &quot;/x:/path/path...&quot;
-      localPath = localPath.substring(1);  // get rid of initial '/'
-      localPath = unescape(localPath);
-      localPath = localPath.replace(new RegExp(&quot;/&quot;,&quot;g&quot;),&quot;\\&quot;);
-      // result: &quot;x:\path\path...&quot;
-      break;
-    case PathType.LOCAL_UNIX_MAC:         
-    // example: &quot;/path/path...&quot;
-      localPath = unescape(localPath);
-      // result: &quot;/path/path...&quot;
-      break;
-    case PathType.NETWORK_FIREFOX:
-      // example: &quot;///server/share/path/path...&quot;
-      localPath = localPath.substring(3);  // get rid of initial '///'
-      localPath = unescape(localPath);
-      localPath = localPath.replace(new RegExp(&quot;/&quot;,&quot;g&quot;),&quot;\\&quot;);
-      localPath = &quot;\\\\&quot; + localPath;      
-      // result: &quot;\\server\share\path\path...&quot;
-      break;
-    case PathType.NETWORK_PC:
-      // example: &quot;server/share/path/path...&quot;
-      localPath = unescape(localPath);
-      localPath = localPath.replace(new RegExp(&quot;/&quot;,&quot;g&quot;),&quot;\\&quot;);
-      localPath = &quot;\\\\&quot; + localPath;      
-      // result: &quot;\\server\share\path\path...&quot;
-      break;
-  }
-
-  return localPath;
-};
-
-
-// -------------------------------------------------------------------
-// End of file
-// -------------------------------------------------------------------

Deleted: trunk/source/model/HttpSaver.js
===================================================================
--- trunk/source/model/HttpSaver.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/HttpSaver.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -1,140 +0,0 @@
-/*****************************************************************************
- HttpSaver.js
-  
-******************************************************************************
- Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
-  
- Copyright rights relinquished under the Creative Commons  
- Public Domain Dedication:
-    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
-  
- You can copy freely from this file.  This work may be freely reproduced, 
- distributed, transmitted, used, modified, built upon, or otherwise exploited
- by anyone for any purpose.
-  
- This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
- of any kind, either express or implied, including, without limitation, any 
- warranties or conditions of title, non-infringement, merchantability, or 
- fitness for a particular purpose. You are solely responsible for determining 
- the appropriateness of using or distributing the work and assume all risks 
- associated with use of this work, including but not limited to the risks and 
- costs of errors, compliance with applicable laws, damage to or loss of data 
- or equipment, and unavailability or interruption of operations.
-
- In no event shall the authors or contributors have any liability for any 
- direct, indirect, incidental, special, exemplary, or consequential damages,
- however caused and on any theory of liability, whether in contract, strict 
- liability, or tort (including negligence), arising in any way out of or in 
- connection with the use or distribution of the work.
-*****************************************************************************/
-
-
-// -------------------------------------------------------------------
-// Provides and Requires
-// -------------------------------------------------------------------
-dojo.provide(&quot;orp.model.HttpSaver&quot;);
-
-
-// -------------------------------------------------------------------
-// Constructor
-// -------------------------------------------------------------------
-/**
- * The HttpSaver class knows how to save content to a server by using
- * XMLHttpRequest to call a PHP script.
- *
- * @param    repositoryName                         // e.g. demo_page
- * @param    pathToTrunkDirectoryFromWindowLocation // Not needed if window location is at the root of the trunk directory.
- * @scope    public instance constructor
- */
-orp.model.HttpSaver = function(repositoryName, pathToTrunkDirectoryFromWindowLocation) {
-  this._repositoryName = repositoryName;
-  var thisUrl = window.location.pathname; //e.g. /openrecord/trunk/demo_page.html or /openrecord/trunk/source/model/TestRepositoryWriting.html.
-  var arrayOfPathComponents = thisUrl.split('/');
-  arrayOfPathComponents.pop();
-  var thisDirectory = arrayOfPathComponents.join('/'); //e.g. /openrecord/trunk or /openrecord/trunk/source/model
-  if (pathToTrunkDirectoryFromWindowLocation) {
-    this._completePathToTrunkDirectory = thisDirectory + '/' + pathToTrunkDirectoryFromWindowLocation;
-  } else {
-    this._completePathToTrunkDirectory = thisDirectory;
-  }
-};
-
-
-// -------------------------------------------------------------------
-// Public methods
-// -------------------------------------------------------------------
-
-/**
- */
-orp.model.HttpSaver.prototype.appendText = function(textToAppend) {
-  var url = this._completePathToTrunkDirectory;
-  url += &quot;/source/model/append_to_repository_file.php?file=&quot; + this._repositoryName;
-  
-  // PENDING: 
-  // It might be more efficient to re-use the XMLHttpRequestObject,
-  // rather than creating a new one for new request.  But re-using 
-  // them is complicated, because the requests are asynchronous, so
-  // we need to check to see if the last request is done before we 
-  // can start a new request.
-  var newXMLHttpRequestObject = this._newXMLHttpRequestObject();
-  var asynchronous = true;
-  newXMLHttpRequestObject.open(&quot;POST&quot;, url, asynchronous);
-  newXMLHttpRequestObject.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
-  newXMLHttpRequestObject.send(textToAppend);
-};
-
-
-/**
- */
-orp.model.HttpSaver.prototype.writeText = function(textToWrite, overwriteIfExists) {
-  var url = this._completePathToTrunkDirectory;
-  url += &quot;/source/model/write_to_repository_file.php?file=&quot; + this._repositoryName;
-  if (overwriteIfExists) {
-    url += &quot;&amp;overwrite=T&quot;;
-  }
-  var newXMLHttpRequestObject = this._newXMLHttpRequestObject();
-  var asynchronous = true;
-  newXMLHttpRequestObject.open(&quot;POST&quot;, url, asynchronous);
-  newXMLHttpRequestObject.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
-  newXMLHttpRequestObject.send(textToWrite);
-};
-
-
-// -------------------------------------------------------------------
-// Private methods
-// -------------------------------------------------------------------
-
-/**
- * Returns a newly created XMLHttpRequest object.
- *
- * @scope    private instance method
- * @return   A newly created XMLHttpRequest object. 
- */
-orp.model.HttpSaver.prototype._newXMLHttpRequestObject = function() {
-  var newXMLHttpRequestObject = null;
-  if (window.XMLHttpRequest) {
-    newXMLHttpRequestObject = new XMLHttpRequest();
-  } else {
-    if (window.ActiveXObject) {
-      newXMLHttpRequestObject = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
-    }
-  }
-  if (newXMLHttpRequestObject) {
-    newXMLHttpRequestObject.onreadystatechange = function() {
-      var statusText = newXMLHttpRequestObject.statusText;
-      if (statusText != &quot;OK&quot;) {
-        window.alert(&quot;onreadystatechange:\n&quot; +
-          &quot;readyState: &quot; + newXMLHttpRequestObject.readyState + &quot;\n&quot; +
-          &quot;status: &quot; + newXMLHttpRequestObject.status + &quot;\n&quot; +
-          &quot;statusText: &quot; + newXMLHttpRequestObject.statusText + &quot;\n&quot; +
-          &quot;responseText: &quot; + newXMLHttpRequestObject.responseText + &quot;\n&quot;);
-      }
-    };
-  }
-  return newXMLHttpRequestObject;
-};
-
-
-// -------------------------------------------------------------------
-// End of file
-// -------------------------------------------------------------------

Deleted: trunk/source/model/StubVirtualServer.js
===================================================================
--- trunk/source/model/StubVirtualServer.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/StubVirtualServer.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -1,1073 +0,0 @@
-/*****************************************************************************
- StubVirtualServer.js
- 
-******************************************************************************
- Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
-  
- Copyright rights relinquished under the Creative Commons  
- Public Domain Dedication:
-    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
-  
- You can copy freely from this file.  This work may be freely reproduced, 
- distributed, transmitted, used, modified, built upon, or otherwise exploited
- by anyone for any purpose.
-  
- This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
- of any kind, either express or implied, including, without limitation, any 
- warranties or conditions of title, non-infringement, merchantability, or 
- fitness for a particular purpose. You are solely responsible for determining 
- the appropriateness of using or distributing the work and assume all risks 
- associated with use of this work, including but not limited to the risks and 
- costs of errors, compliance with applicable laws, damage to or loss of data 
- or equipment, and unavailability or interruption of operations.
-
- In no event shall the authors or contributors have any liability for any 
- direct, indirect, incidental, special, exemplary, or consequential damages,
- however caused and on any theory of liability, whether in contract, strict 
- liability, or tort (including negligence), arising in any way out of or in 
- connection with the use or distribution of the work.
-*****************************************************************************/
- 
-// -------------------------------------------------------------------
-// Provides and Requires
-// -------------------------------------------------------------------
-dojo.provide(&quot;orp.model.StubVirtualServer&quot;);
-dojo.require(&quot;orp.model.World&quot;);
-dojo.require(&quot;orp.model.Item&quot;);
-dojo.require(&quot;orp.model.Entry&quot;);
-dojo.require(&quot;orp.model.Transaction&quot;);
-dojo.require(&quot;orp.util.TimeBasedUuid&quot;);
-dojo.require(&quot;orp.util.DateValue&quot;);
-dojo.require(&quot;orp.lang.Lang&quot;);
-
-// -------------------------------------------------------------------
-// Dependencies, expressed in the syntax that JSLint understands:
-// 
-/*global Util  */
-/*global World, Item, Entry, Ordinal, Vote, ContentRecord, Transaction  */
-// -------------------------------------------------------------------
-
-
-// -------------------------------------------------------------------
-// Constructor
-// -------------------------------------------------------------------
-/**
- * The StubVirtualServer is a dummy place-holder datastore that does
- * a bare-minimum job of providing data to a World.
- *
- * @scope    public instance constructor
- */
-orp.model.StubVirtualServer = function(pathToTrunkDirectory) {
-  var fileName = &quot;2005_june_axiomatic_items.json&quot;;
-  var relUrlForAxiomaticFile = &quot;source/model/&quot; + fileName;
-  if (pathToTrunkDirectory) {
-    this._needCompletePath = true;
-    var thisUrl = window.location.pathname; //e.g. /openrecord/trunk/source/model/TestRepositoryWriting.html.
-    var arrayOfPathComponents = thisUrl.split('/');
-    arrayOfPathComponents.pop();
-    var thisDirectory = arrayOfPathComponents.join('/'); //e.g. /openrecord/trunk/source/model
-    this._completePathToTrunkDirectory = thisDirectory + '/' + pathToTrunkDirectory;
-    this._dehydratedAxiomFileURL = this._completePathToTrunkDirectory + '/' + relUrlForAxiomaticFile;
-  } else {
-    this._needCompletePath = false;
-    this._dehydratedAxiomFileURL = relUrlForAxiomaticFile;    
-  }
-  
-  /*
-  if (optionalDefaultOverrides) {
-    this._processOptionalDefaultOverrides(optionalDefaultOverrides, &quot;Stub&quot;);
-  }
-  */
-};
-
-
-// -------------------------------------------------------------------
-// Public constants
-// -------------------------------------------------------------------
-orp.model.StubVirtualServer.JSON_FORMAT = {
-  FORMAT_2005_JUNE_CHRONOLOGICAL_LIST: &quot;2005_JUNE_CHRONOLOGICAL_LIST&quot; };
-
-orp.model.StubVirtualServer.JSON_MEMBER = {
-  FORMAT: &quot;format&quot;,
-  RECORDS: &quot;records&quot;,
-  TYPE: &quot;type&quot;,
-  VALUE: &quot;value&quot;,
-  UUID: &quot;uuid&quot;,
-  USER: &quot;user&quot;,
-  PASSWORD: &quot;password&quot;,
-  ITEM_CLASS: &quot;Item&quot;,
-  ENTRY_CLASS: &quot;Entry&quot;,
-  VOTE_CLASS: &quot;Vote&quot;,
-  ORDINAL_CLASS: &quot;Ordinal&quot;,
-  USER_CLASS: &quot;User&quot;,
-  TRANSACTION_CLASS: &quot;Transaction&quot;,
-  ATTRIBUTE: &quot;attribute&quot;,
-  PREVIOUS_VALUE: &quot;previousEntry&quot;,
-  RECORD: &quot;record&quot;,
-  ITEM: &quot;item&quot;,
-  RETAIN_FLAG: &quot;retainFlag&quot;,
-  ORDINAL_NUMBER: &quot;value&quot; };
-
-
-/*
-OLD?
-StubVirtualServer.JSON_TYPE_TEXT_VALUE = &quot;TextValue&quot;;
-StubVirtualServer.JSON_TYPE_RELATED_UUID = &quot;RelatedUuid&quot;;
-StubVirtualServer.JSON_TYPE_NUMBER_VALUE = &quot;NumberValue&quot;;
-StubVirtualServer.JSON_TYPE_DATE_VALUE = &quot;DateValue&quot;;
-StubVirtualServer.JSON_TYPE_CHECKMARK_VALUE = &quot;CheckMarkValue&quot;;
-StubVirtualServer.JSON_TYPE_URL_VALUE = &quot;UrlValue&quot;;
-StubVirtualServer.JSON_TYPE_CONNECTION = &quot;Connection&quot;;
-*/
-
-
-// -------------------------------------------------------------------
-// Private methods
-// -------------------------------------------------------------------
-
-/**
- * Initializes the instance variables for a newly created StubVirtualServer.
- *
- * @scope    private instance method
- * @param    world    The world that we provide data for. 
- */
-orp.model.StubVirtualServer.prototype._initialize = function(world) {
-  this._world = world;
-  
-  this._countOfNestedTransactions = 0;
-  this._currentTransaction = null;
-
-  this._hashTableOfItemsKeyedByUuid = {};
-  this._hashTableOfEntriesKeyedByUuid = {};
-  this._chronologicalListOfRecords = [];
-  
-  this._listOfUsers = [];
-  this._hashTableOfUserAuthenticationInfo = {};
-  this._currentUser = null;
-};
- 
-
-// -------------------------------------------------------------------
-// Public Methods
-// -------------------------------------------------------------------
-
-/**
- * Initializes the instance variables for a newly created StubVirtualServer,
- * and does the initial loading of at least the axiomatic items.
- *
- * @scope    public instance method
- * @param    world    The world that we provide data for. 
- */
-orp.model.StubVirtualServer.prototype.setWorldAndLoadAxiomaticItems = function(world) {
-  this._initialize(world);
-  // this._buildTypeHashTable();
-  this._loadAxiomaticItemsFromFileAtURL(this._dehydratedAxiomFileURL);
-};
-
-
-/**
- * Returns the World instance that this virtual server is using.
- *
- * @scope    public instance method
- * @return   A World object. 
- */
-orp.model.StubVirtualServer.prototype.getWorld = function() {
-  return this._world;
-};
-
-
-/**
- * Given a text string, this method returns a copy of the text string, 
- * with certain special characters replaced by escape sequences.
- * 
- * For example, given a string like this:
- * &lt;pre&gt;
- *    this.encodeText('The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.\n');
- * &lt;/pre&gt;
- * The return value will be:
- * &lt;pre&gt;
- *    'The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.&#10;'
- * &lt;/pre&gt;
- * 
- * @scope    public instance method
- * @param    rawText    A text string to encode. 
- * @return   A copy of the rawText string, with the special characters escaped. 
- */
-orp.model.StubVirtualServer.prototype.encodeText = function(rawText) {
-  // orp.util.assert(orp.util.isString(rawText));
-  orp.lang.assertType(rawText, String);
-
-  var returnString = rawText;
-  // Note: it's important that we do '&amp;' first, otherwise we'll accidentally
-  // replace all the &amp; characters that we add in the following lines.
-  returnString = returnString.replace(new RegExp('&amp;','g'), &quot;&amp;&quot;);
-  returnString = returnString.replace(new RegExp('&lt;','g'), &quot;&lt;&quot;);
-  returnString = returnString.replace(new RegExp('&gt;','g'), &quot;&gt;&quot;);
-  returnString = returnString.replace(new RegExp('&quot;','g'), &quot;&quot;&quot;);
-  returnString = returnString.replace(new RegExp('\n','g'), &quot;&#10;&quot;);
-  returnString = returnString.replace(new RegExp('\r','g'), &quot;&#13;&quot;);
-  return returnString;
-};
-
-
-/**
- * Given a text string that was encoded using encodeText(), this method 
- * returns a decoded copy of the text string, with the encoded escape 
- * sequences now replaced by the original special characters.
- *
- * For example, given a string like this:
- * &lt;pre&gt;
- *    this.decodeText('The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.&#10;');
- * &lt;/pre&gt;
- * The return value will be:
- * &lt;pre&gt;
- *    'The quick &lt;brown&gt; fox &amp; the &quot;lazy&quot; hare.\n'
- * &lt;/pre&gt;
- *
- * @scope    public instance method
- * @param    encodedText    A text string to decode. 
- * @return   A copy of the encodedText string, with the escaped characters replaced by the original special characters. 
- */
-orp.model.StubVirtualServer.prototype.decodeText = function(encodedText) {
-  // orp.util.assert(orp.util.isString(encodedText));
-  orp.lang.assertType(encodedText, String);
-  
-  var returnString = encodedText;
-  returnString = returnString.replace(new RegExp('&#13;','g'), &quot;\r&quot;);
-  returnString = returnString.replace(new RegExp('&#10;','g'), &quot;\n&quot;);
-  returnString = returnString.replace(new RegExp('&quot;','g'), '&quot;');
-  returnString = returnString.replace(new RegExp('&gt;','g'), &quot;&gt;&quot;);
-  returnString = returnString.replace(new RegExp('&lt;','g'), &quot;&lt;&quot;);
-  returnString = returnString.replace(new RegExp('&amp;','g'), &quot;&amp;&quot;);
-  // Note: it's important that we do '&amp;' last, otherwise we won't correctly
-  // handle a case like this:
-  //   text = this.decodeText(this.encodeText('&lt;'));
-  return returnString;
-};
-
-
-// -------------------------------------------------------------------
-// Transaction Methods
-// -------------------------------------------------------------------
-
-/**
- * Marks the beginning of a transaction.
- *
- * Each time you call beginTransaction() you open a new transaction, 
- * which you need to close later using endTransaction().  Transactions
- * may be nested, but the beginTransaction and endTransaction calls
- * always need to come in pairs. 
- *
- * @scope    public instance method
- */
-orp.model.StubVirtualServer.prototype.beginTransaction = function() {
-  if (this._countOfNestedTransactions === 0) {
-    this._currentTransaction = new orp.model.Transaction();
-  }
-  this._countOfNestedTransactions += 1;
-};
- 
-
-/**
- * Marks the end of a transaction.
- *
- * @scope    public instance method
- */
-orp.model.StubVirtualServer.prototype.endTransaction = function() {
-  this._countOfNestedTransactions -= 1;
-  orp.lang.assert(this._countOfNestedTransactions &gt;= 0);
-
-  if (this._countOfNestedTransactions === 0) {
-    var listOfChangesMade = this._saveChangesToServer();
-    this._currentTransaction = null;
-    if (listOfChangesMade.length &gt; 0) {
-      // alert(listOfChangesMade.length + &quot; changes made&quot;);
-      // orp.util.displayStatusBlurb(listOfChangesMade.length + &quot; changes made&quot;);
-      this._world._notifyObserversOfChanges(listOfChangesMade);
-    }
-  }
-};
-
-
-/**
- * Returns the Transaction object for the current transaction.
- *
- * @scope    public instance method
- * @return   A Transaction object, or null if there is no transaction in progress. 
- */
-orp.model.StubVirtualServer.prototype.getCurrentTransaction = function() {
-  return this._currentTransaction;
-};
-
-
-// -------------------------------------------------------------------
-// Methods for creating and changing items
-// -------------------------------------------------------------------
-
-/**
- * Returns a newly created item.
- *
- * @scope    public instance method
- * @param    name    Optional. A string, which will be assigned to the name attribute of the new item. 
- * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
- * @return   A newly created item.
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newItem = function(name, observer) {
-  this._throwErrorIfNoUserIsLoggedIn();
-  var item = this._createNewItem(observer, false);
-  if (name) { 
-    var attributeCalledName = this._world.getAttributeCalledName();
-    // item.addEntryForAttribute(attributeCalledName, name);
-    item.addEntry({attribute:attributeCalledName, value:name});
-  }
-  return item;
-};
-
-
-/**
- * Returns a newly created &quot;provisional&quot; item.  At the time this item is 
- * created, it will only exist in local memory.  Unlike normal items, 
- * provisional items are not saved to the repository at the time they 
- * are created.  The provisional item is saved to the repository when 
- * an entry is set for one of the item's attributes.
- *
- * @scope    public instance method
- * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
- * @return   A newly created provisional item.
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newProvisionalItem = function(observer) {
-  this._throwErrorIfNoUserIsLoggedIn();
-  var item = this._createNewItem(observer, true);
-  return item;
-};
-
-
-/**
- * Returns a newly created item: either a provisional item or a normal item.
- *
- * @scope    private instance method
- * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
- * @param    provisionalFlag    True if the item is provisional; false if the item is normal. 
- * @return   A newly created item.
- */
-orp.model.StubVirtualServer.prototype._createNewItem = function(observer, provisionalFlag) {
-  var uuid = this._getNewUuid();
-  var item = new orp.model.Item(this._world, uuid);
-  item._initialize(observer, provisionalFlag);
-  this._hashTableOfItemsKeyedByUuid[uuid] = item;
-  if (!provisionalFlag) {
-    this._currentTransaction.addRecord(item);
-  }
-  return item;
-};
-
-
-/**
- * Records the fact that a provisional item just became real.
- *
- * @scope    package instance method
- * @param    item    The item that was provisional and just became real. 
- */
-orp.model.StubVirtualServer.prototype._provisionalItemJustBecameReal = function(item) {
-  this._currentTransaction.addRecord(item);
-};
-
-
-/**
- * Returns a newly created entry.
- *
- * @scope    public instance method
- * @param    item    The item that this is an entry of. 
- * @param    previousEntry    Optional. The old entry that this entry is replacing. 
- * @param    attribute    The attribute that this entry is assigned to. May be null. 
- * @param    value    The value to initialize the entry with. 
- * @param    type    Optional. An item representing the data type of the value. 
- * @return   A newly created entry.
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newEntry = function(item, previousEntry, attribute, value, type) {
-  this._throwErrorIfNoUserIsLoggedIn();
-  var uuid = this._getNewUuid();
-  var entry = new orp.model.Entry(this._world, uuid);
-  entry._initialize(item, previousEntry, attribute, value, type);
-  item._addEntryToListOfEntriesForAttribute(entry, attribute);
-  
-  this._hashTableOfEntriesKeyedByUuid[uuid] = entry;
-  this._currentTransaction.addRecord(entry);
-  return entry;
-};
- 
-
-/**
- * Returns a newly created entry.
- *
- * @scope    public instance method
- * @param    previousEntry    The entry that this entry will replace. Can be null.
- * @param    itemOne    One of the two items that this entry will connect. 
- * @param    attributeOne    The attribute of itemOne that this entry will be assigned to. 
- * @param    itemTwo    One of the two items that this entry will connect. 
- * @param    attributeTwo    The attribute of itemTwo that this entry will be assigned to.  
- * @return   A newly created entry.
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newConnectionEntry = function(previousEntry, itemOne, attributeOne, itemTwo, attributeTwo) {
-  this._throwErrorIfNoUserIsLoggedIn();
-  var uuid = this._getNewUuid();
-  var entry = new orp.model.Entry(this._world, uuid);
-  entry._initializeConnection(previousEntry, itemOne, attributeOne, itemTwo, attributeTwo);
-
-  itemOne._addEntryToListOfEntriesForAttribute(entry, attributeOne);
-  itemTwo._addEntryToListOfEntriesForAttribute(entry, attributeTwo);
-
-  this._hashTableOfEntriesKeyedByUuid[uuid] = entry;
-  this._currentTransaction.addRecord(entry);
-  return entry;
-};
-
-
-/**
- * Returns a newly created ordinal.
- *
- * @scope    public instance method
- * @param    contentRecord    The contentRecord that this is an ordinal for. 
- * @param    ordinalNumber    The ordinal number itself. 
- * @return   A newly created ordinal.
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newOrdinal = function(contentRecord, ordinalNumber) {
-  this._throwErrorIfNoUserIsLoggedIn();
-  var uuid = this._getNewUuid();
-  var ordinal = new orp.model.Ordinal(this._world, uuid, contentRecord, ordinalNumber);
-  this._currentTransaction.addRecord(ordinal);
-  return ordinal;
-};
-
-
-/**
- * Returns a newly created vote.
- *
- * @scope    public instance method
- * @param    contentRecord    The contentRecord to attach this vote to. 
- * @param    retainFlag    True if this is a vote to retain. False if this is a vote to delete. 
- * @return   A newly created vote.
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newVote = function(contentRecord, retainFlag) {
-  this._throwErrorIfNoUserIsLoggedIn();
-  var uuid = this._getNewUuid();
-  var vote = new orp.model.Vote(this._world, uuid, contentRecord, retainFlag);
-  this._currentTransaction.addRecord(vote);
-  return vote;
-};
-
-
-// -------------------------------------------------------------------
-// Methods having to do with users
-// -------------------------------------------------------------------
-
-/**
- * Creates a new item, where the new item represents a user of this datastore.
- *
- * @scope    public instance method
- * @param    name    A string, which will be assigned to the name attribute of the new item. 
- * @param    authentication    A string which will be used as the login password for the user. 
- * @param    observer    Optional. An object or method to be registered as an observer of the returned item. 
- * @return   A newly created item representing a user.
- * @throws   Throws an Error if a user is logged in.
- */
-orp.model.StubVirtualServer.prototype.newUser = function(name, authentication, observer) {
-  if (this._currentUser) {
-    var error = new Error(&quot;A user is logged in.  You can't create a new user when somebody is already logged in.&quot;);
-    throw error;
-  }
-
-  var newUser = this._createNewItem(observer, false);
-  this._listOfUsers.push(newUser);
-  
-  var md5Authentication = null;
-  if (authentication) {
-    md5Authentication = orp.util.hex_md5(authentication);
-  }
-  this._hashTableOfUserAuthenticationInfo[newUser.getUuid()] = md5Authentication;
-
-  this._currentUser = newUser;
-  var categoryCalledPerson = this.getWorld().getCategoryCalledPerson();
-  newUser.assignToCategory(categoryCalledPerson); 
-  if (name) { 
-    var attributeCalledName = this.getItemFromUuid(orp.model.World.UUID.ATTRIBUTE_NAME);
-    var entry = newUser.addEntry({attribute:attributeCalledName, value:name});
-  }
-  this._currentUser = null;
-  
-  return newUser;
-};
-
-
-/**
- * Returns an list of all the items that represent users of this datastore.
- *
- * @scope    public instance method
- * @return   A list of items.
- */
-orp.model.StubVirtualServer.prototype.getUsers = function() {
-  return this._listOfUsers;
-};
-
-
-/**
- * Returns an item representing the user who is currently logged in.
- *
- * @scope    public instance method
- * @return   An item representing the user who is currently logged in.
- */
-orp.model.StubVirtualServer.prototype.getCurrentUser = function() {
-  return this._currentUser;
-};
-
-
-// -------------------------------------------------------------------
-// Login and logout methods
-// -------------------------------------------------------------------
-
-/**
- * Attempts to login a user.
- *
- * @scope    public instance method
- * @param    inUser    The user to be logged in. 
- * @param    inPassword    Password supplied at login. 
- * @return   True if we were able to log in the user. False if the login failed.
- */
-orp.model.StubVirtualServer.prototype.login = function(user, password) {
-  
-  // Only one user can be logged in at once.  We consider it an error
-  // if you try to log in a new user before logging out the old one.
-  if (this._currentUser) {
-    orp.lang.assert(false);
-  }
-  
-  var isKnownUser = orp.util.isObjectInSet(user, this._listOfUsers);
-  if (!isKnownUser) {
-    return false;
-  }
-
-  if (user.getUuidString() == orp.model.World.UUID.USER_AMY) {
-    // nobody is allowed to log in as the axiomatic user
-    return false;
-  }
-  
-  var md5hashOfPassword = null;
-  if (password) {
-    md5hashOfPassword = orp.util.hex_md5(password);
-  }
-  var realAuthentication = this._getAuthenticationInfoForUser(user);
-  var successfulAuthentication = ((realAuthentication == md5hashOfPassword) || !realAuthentication);
-  
-  // PENDING: temporary hack
-  // if (!successfulAuthentication) {
-  //  successfulAuthentication = (&quot;PENDING: magic super password&quot; == authentication);
-  // }
-  
-  if (successfulAuthentication) {
-    this._currentUser = user;
-    return true;
-  } else {
-    return false;
-  }
-};
-
-
-/**
- * Logs out the current user.
- *
- * @scope    public instance method
- * @return   True if the current user was logged out. False if there was no current user logged in.
- */
-orp.model.StubVirtualServer.prototype.logout = function() {
-  if (this._currentUser) {
-    this._currentUser = null;
-    return true;
-  } else {
-    return false;
-  }
-};
-
-
-// -------------------------------------------------------------------
-// Other public methods
-// -------------------------------------------------------------------
-
-/**
- * Given a UUID, returns the item identified by that UUID.
- *
- * @scope    public instance method
- * @param    uuid    The UUID of the item to be returned. 
- * @param    observer    Optional. An object to be registered as an observer of the returned item. 
- * @return   The item identified by the given UUID.
- */
-orp.model.StubVirtualServer.prototype.getItemFromUuid = function(uuid, observer) {
-  orp.lang.assert(dojo.lang.isString(uuid) || uuid instanceof orp.util.Uuid);
-  
-  var item = this._hashTableOfItemsKeyedByUuid[uuid];
-  if (item &amp;&amp; observer) {
-    item.addObserver(observer);
-  }
-  return item;
-};
-
-
-/**
- * Sends all the changes to the server, so that the server can record the
- * changes.
- *
- * @scope    private instance method
- */
-orp.model.StubVirtualServer.prototype._saveChangesToServer = function () {
-  // The StubVirtualServer doesn't ever actually talk to a server.
-  // Other VirtualServer implementations would be expected to actually
-  // implement this method such that it saves changes to the server
-  var listOfChangesMade = this._currentTransaction.getRecords();
-  this._currentTransaction = null;
-  return listOfChangesMade;
-};
-
-
-// -------------------------------------------------------------------
-// Query methods
-// -------------------------------------------------------------------
-
-/**
- * Given a QueryRunner object, this method returns a list of all the items that 
- * match the query criteria.
- *
- * @scope    public instance method
- * @param    queryRunner    A QueryRunner object. 
- * @return   A list of items.
- */
-orp.model.StubVirtualServer.prototype.getResultItemsForQueryRunner = function(queryRunner) {
-  var matchingAttribute = queryRunner.getMatchingAttribute();
-  var listOfMatchingValues = queryRunner.getMatchingValues();
-  var listOfQueryResultItems = [];
-  var key;
-  
-  if (!matchingAttribute || !listOfMatchingValues) {
-    return listOfQueryResultItems;
-  }
-    
-  var attributeCalledCategory = this.getWorld().getAttributeCalledCategory();
-  if (matchingAttribute == attributeCalledCategory) {
-    // If this is a query for all the item in a category,
-    // then handle that as a special case, because we can
-    // do that way faster than more general queries.
-    var attributeCalledItemsInCategory = this.getWorld().getAttributeCalledItemsInCategory();
-    for (key in listOfMatchingValues) {
-      var category = listOfMatchingValues[key];
-      var listOfEntriesForItemsInCategory = category.getEntriesForAttribute(attributeCalledItemsInCategory);
-      for (var innerKey in listOfEntriesForItemsInCategory) {
-        var entry = listOfEntriesForItemsInCategory[innerKey];
-        var itemInCategory = entry.getValue(category);
-        orp.util.addObjectToSet(itemInCategory, listOfQueryResultItems);
-      }
-    }
-  } else {
-    // General case code for any sort of query. 
-    for (var uuid in this._hashTableOfItemsKeyedByUuid) {
-      var item = this._hashTableOfItemsKeyedByUuid[uuid];
-      var includeItem = queryRunner.doesItemMatch(item);
-      if (includeItem) {
-        listOfQueryResultItems.push(item);
-      }
-    }
-  }
-  listOfQueryResultItems.sort(orp.model.ContentRecord.compareOrdinals);
-  return listOfQueryResultItems; 
-};
-
-
-/**
- * Given an item and a query item, this method modifies the attributes 
- * of the item so that when the query is next evaluated the item will be 
- * included in query result list.
- *
- * @scope    public instance method
- * @param    item    An item, which will be modified so that it matches the query. 
- * @param    query    A query item. 
- */
-orp.model.StubVirtualServer.prototype.setItemToBeIncludedInQueryResultList = function(item, query) {
-  orp.lang.assert(item instanceof orp.model.Item);
-  orp.lang.assert(query instanceof orp.model.Item);
-  
-  var attributeCalledQueryMatchingValue = this.getWorld().getAttributeCalledQueryMatchingValue();
-  var attributeCalledQueryMatchingAttribute = this.getWorld().getAttributeCalledQueryMatchingAttribute();
-  var attributeCalledCategory = this.getWorld().getAttributeCalledCategory();
-  var categoryCalledCategory = this.getWorld().getCategoryCalledCategory();
-  
-  var listOfMatchingEntries = query.getEntriesForAttribute(attributeCalledQueryMatchingValue);
-  var listOfMatchingAttrs = query.getEntriesForAttribute(attributeCalledQueryMatchingAttribute);
-  if (!(listOfMatchingEntries &amp;&amp; (listOfMatchingEntries.length &gt; 0))) {return;} // query not fully formed, so nothing to add
-  var matchingAttribute;
-  if (listOfMatchingAttrs.length === 0) {
-    // by default matching attribute is category
-    matchingAttribute = attributeCalledCategory;
-  }
-  else {
-    orp.lang.assert(listOfMatchingAttrs.length==1, 'more than one matching attributes');
-    matchingAttribute = listOfMatchingAttrs[0].getValue();
-  }
-
-  for (var key in listOfMatchingEntries) {
-    var matchingEntry = listOfMatchingEntries[key];
-    var match = matchingEntry.getValue();
-    if (!item.hasAttributeValue(matchingAttribute, match)) {
-      if ((matchingAttribute == attributeCalledCategory) &amp;&amp; (match instanceof orp.model.Item) &amp;&amp; (match.isInCategory(categoryCalledCategory))) {
-        item.assignToCategory(match);
-      } else {
-        // item.addEntryForAttribute(matchingAttribute, match);
-        item.addEntry({attribute:matchingAttribute, value:match});
-      }
-    }
-  }
-};
-
-
-/**
- * Given a category, this method returns a list of all the items that have been 
- * assigned to that category.
- *
- * @scope    public instance method
- * @param    inCategory    A category item. 
- * @return   A list of items.
- */
-orp.model.StubVirtualServer.prototype.getItemsInCategory = function(category) {
-  orp.lang.assert(category instanceof orp.model.Item);
-
-  var attributeCalledItemsInCategory = this.getWorld().getAttributeCalledItemsInCategory();
-  var listOfEntries = category.getEntriesForAttribute(attributeCalledItemsInCategory);
-  var listOfItems = [];
-  for (var key in listOfEntries) {
-    var entry = listOfEntries[key];
-    var item = entry.getValue(category);
-    listOfItems.push(item);
-  }
-  listOfItems.sort(orp.model.ContentRecord.compareOrdinals);
-  return listOfItems; 
-};
-
-
-// -------------------------------------------------------------------
-// Private methods
-// -------------------------------------------------------------------
-
-/**
- * Throws an Error if there is no user currently logged in.
- *
- * @scope    private instance method
- * @throws   Throws an Error if no user is logged in.
- */
-orp.model.StubVirtualServer.prototype._throwErrorIfNoUserIsLoggedIn = function() {
-  if (!this._currentUser) {
-    var error = new Error(&quot;No user is logged in.  You can't write to the repository when nobody is logged in.&quot;);
-    throw error;
-  }
-};
-
-
-/**
- * Given a UUID, returns the item or entry identified by that UUID.
- *
- * @scope    private instance method
- * @param    uuid    The UUID of the item or entry to be returned. 
- * @return   The item or entry identified by the given UUID.
- */
-orp.model.StubVirtualServer.prototype._getContentRecordFromUuid = function(uuid) {
-  var item = this.getItemFromUuid(uuid);
-  if (item) {
-    return item;
-  } else {
-    return this._hashTableOfEntriesKeyedByUuid[uuid];
-  }
-};
-
-
-/**
- * Returns a newly created UUID.
- *
- * @scope    private instance method
- * @param    node    The node value that the new UUID should have. 
- */
-orp.model.StubVirtualServer.prototype._generateUuid = function(node) {
-  if (node) {
-    return new orp.util.TimeBasedUuid({'node': node});
-  } else {
-    return new orp.util.TimeBasedUuid();
-  }
-};
-
-
-/**
- * Creates a brand new UUID to allocate to an item or entry.
- *
- * @scope    private instance method
- * @return   A newly created UUID.
- */
-orp.model.StubVirtualServer.prototype._getNewUuid = function() {
-  var newUuid;
-  if (this._currentUser) {
-    var uuidOfCurrentUser = this._currentUser.getUuid();
-    var nodeForCurrentUser = uuidOfCurrentUser.getNode(); // &quot;0123456789AB&quot;;
-    newUuid = this._generateUuid(nodeForCurrentUser);
-  } else {
-    newUuid = this._generateUuid();
-  }
-  return newUuid;
-};
-
-
-/**
- * Given an item representing a user, return the authentication info
- * associated with that user.
- *
- * @scope    private instance method
- * @param    user    An item representing a user. 
- * @return   The authentication info for the user.
- */
-orp.model.StubVirtualServer.prototype._getAuthenticationInfoForUser = function(user) {
-  return this._hashTableOfUserAuthenticationInfo[user.getUuid()];
-};
-
-
-/**
- * Given a UUID, either (a) returns the existing item identified by that UUID, 
- * or (b) creates an new item object, set its UUID, and returns that object.
- *
- * @scope    private instance method
- * @param    uuid    The UUID of the item to be returned. 
- * @return   The item identified by the given UUID.
- */
-orp.model.StubVirtualServer.prototype._getItemFromUuidOrCreateNewItem = function(uuid) {
-  var item = this.getItemFromUuid(uuid);
-  if (!item) {
-    item = new orp.model.Item(this._world, uuid);
-    item._initialize();
-    this._hashTableOfItemsKeyedByUuid[uuid] = item;
-    this._currentTransaction.addRecord(item);
-  }
-  return item;
-};
-
-
-/**
- * Creates the basic items that needed in order to do anything else, 
- * like the items for &quot;name&quot;, &quot;attribute&quot;, and &quot;category&quot;.
- *
- * @scope    private instance method
- */
-orp.model.StubVirtualServer.prototype._loadAxiomaticItemsFromFileAtURL = function(url) {
-  // var fileContentString = orp.util.getStringContentsOfFileAtURL(url);
-  var fileContentString = dojo.hostenv.getText(url);
-  // orp.util.assert(orp.util.isString(fileContentString));
-  orp.lang.assertType(fileContentString, String);
-  fileContentString += &quot; ] }&quot;;
-
-  var dehydratedRecords = null;
-  eval(&quot;dehydratedRecords = &quot; + fileContentString + &quot;;&quot;);
-  // orp.util.assert(orp.util.isObject(dehydratedRecords));
-  orp.lang.assertType(dehydratedRecords, Object);
-  var recordFormat = dehydratedRecords[orp.model.StubVirtualServer.JSON_MEMBER.FORMAT];
-  orp.lang.assert(recordFormat == orp.model.StubVirtualServer.JSON_FORMAT.FORMAT_2005_JUNE_CHRONOLOGICAL_LIST);
-  var listOfRecords = dehydratedRecords[orp.model.StubVirtualServer.JSON_MEMBER.RECORDS];
-  // orp.util.assert(orp.util.isArray(listOfRecords));
-  orp.lang.assertType(listOfRecords, Array);
-  
-  this._rehydrateRecords(listOfRecords);
-};
-
-
-/**
- * Given a UUID, either (a) returns the existing item identified by that UUID, 
- * or (b) creates an new item object, set its UUID, and returns that object.
- *
- * @scope    private instance method
- * @param    inUuid    The UUID of the item to be returned. 
- * @return   The item identified by the given UUID.
- */
-orp.model.StubVirtualServer.prototype._getItemFromUuidOrBootstrapItem = function(uuid) {
-  var item = this.getItemFromUuid(uuid);
-  if (!item) {
-    item = new orp.model.Item(this.getWorld(), uuid);
-    this._hashTableOfItemsKeyedByUuid[uuid] = item;
-  }
-  return item;
-};
-
-/**
- * Given a UUID, returns the existing entry identified by that UUID. 
- * 
- * @scope    private instance method
- * @param    uuid    The UUID of the entry to be returned. 
- * @return   The entry identified by the given UUID.
- */
-orp.model.StubVirtualServer.prototype._getEntryFromUuid = function(uuid) {
-  return this._hashTableOfEntriesKeyedByUuid[uuid];
-};
-
-/**
- * Given a UUID, either (a) returns the existing entry identified by that UUID, 
- * or (b) creates an new entry object, set its UUID, and returns that object.
- *
- * @scope    private instance method
- * @param    uuid    The UUID of the entry to be returned. 
- * @return   The entry identified by the given UUID.
- */
-orp.model.StubVirtualServer.prototype._getEntryFromUuidOrBootstrapEntry = function(uuid) {
-  var entry = this._hashTableOfEntriesKeyedByUuid[uuid];
-  if (!entry) {
-    entry = new orp.model.Entry(this.getWorld(), uuid);
-    this._hashTableOfEntriesKeyedByUuid[uuid] = entry;
-  }
-  return entry;
-};
-
-
-/**
- * Given a dehydrated list of records, rehydrates each of the records.
- *
- * @scope    private instance method
- * @param    listOfDehydratedRecords    A list of dehydrated records. 
- */
-orp.model.StubVirtualServer.prototype._rehydrateRecords = function(listOfDehydratedRecords) {
-  var key;
-  var itemUuid;
-  var item;
-  var contentRecordUuid;
-  var contentRecord;
-  var JSON_MEMBER = orp.model.StubVirtualServer.JSON_MEMBER;
-
-  for (key in listOfDehydratedRecords) {
-    var dehydratedRecord = listOfDehydratedRecords[key];
-
-    var dehydratedTransaction = dehydratedRecord[JSON_MEMBER.TRANSACTION_CLASS];
-    if (dehydratedTransaction) {
-      var listOfRecordsInTransaction = dehydratedTransaction;
-      this._rehydrateRecords(listOfRecordsInTransaction);
-    } else {
-      var dehydratedItem = dehydratedRecord[JSON_MEMBER.ITEM_CLASS];
-      var dehydratedUser = dehydratedRecord[JSON_MEMBER.USER_CLASS];
-      var dehydratedVote = dehydratedRecord[JSON_MEMBER.VOTE_CLASS];
-      var dehydratedOrdinal = dehydratedRecord[JSON_MEMBER.ORDINAL_CLASS];
-      var dehydratedEntry = dehydratedRecord[JSON_MEMBER.ENTRY_CLASS];
-        
-      if (dehydratedItem) {
-        itemUuid = dehydratedItem[JSON_MEMBER.UUID];
-        item = this._getItemFromUuidOrBootstrapItem(itemUuid);
-        this._chronologicalListOfRecords.push(item);
-      }
-      
-      if (dehydratedUser) {
-        var userUuid = dehydratedUser[JSON_MEMBER.USER];
-        var userPasswordHash = dehydratedUser[JSON_MEMBER.PASSWORD];
-        var user = this._getItemFromUuidOrBootstrapItem(userUuid);
-        this._listOfUsers.push(user);
-        this._hashTableOfUserAuthenticationInfo[user.getUuid()] = userPasswordHash;
-      }
-      
-      if (dehydratedVote) {
-        var voteUuid = dehydratedVote[JSON_MEMBER.UUID];
-        var retainFlagString = dehydratedVote[JSON_MEMBER.RETAIN_FLAG];
-        var retainFlag = null;
-        if (retainFlagString == &quot;true&quot;) {
-          retainFlag = true;
-        }
-        if (retainFlagString == &quot;false&quot;) {
-          retainFlag = false;
-        }
-        orp.lang.assert(retainFlag !== null);
-        contentRecordUuid = dehydratedVote[JSON_MEMBER.RECORD];
-        contentRecord = this._getContentRecordFromUuid(contentRecordUuid);
-        var vote = new orp.model.Vote(this.getWorld(), voteUuid, contentRecord, retainFlag);
-        this._chronologicalListOfRecords.push(vote);
-      }
-      
-      if (dehydratedOrdinal) {
-        var ordinalUuid = dehydratedOrdinal[JSON_MEMBER.UUID];
-        var ordinalNumber = dehydratedOrdinal[JSON_MEMBER.ORDINAL_NUMBER];
-        contentRecordUuid = dehydratedOrdinal[JSON_MEMBER.RECORD];
-        contentRecord = this._getContentRecordFromUuid(contentRecordUuid);
-        var ordinal = new orp.model.Ordinal(this.getWorld(), ordinalUuid, contentRecord, ordinalNumber);
-        this._chronologicalListOfRecords.push(ordinal);
-      }
-      
-      if (dehydratedEntry) {
-        var entryUuid = dehydratedEntry[JSON_MEMBER.UUID];
-        var entry = this._getEntryFromUuidOrBootstrapEntry(entryUuid);
-        var previousEntryUuid = dehydratedEntry[JSON_MEMBER.PREVIOUS_VALUE];
-        var previousEntry = null;
-        if (previousEntryUuid) {
-          previousEntry = this._getEntryFromUuidOrBootstrapEntry(previousEntryUuid);
-        }
- 
-        var dataTypeUuid = dehydratedEntry[JSON_MEMBER.TYPE];
-        var dataType = this._getItemFromUuidOrBootstrapItem(dataTypeUuid);
-        
-        if (dataTypeUuid == orp.model.World.UUID.TYPE_CONNECTION) {
-          var listOfItemUuids = dehydratedEntry[JSON_MEMBER.ITEM];
-          var firstItemUuid = listOfItemUuids[0];
-          var secondItemUuid = listOfItemUuids[1];
-          var firstItem = this._getItemFromUuidOrBootstrapItem(firstItemUuid);
-          var secondItem = this._getItemFromUuidOrBootstrapItem(secondItemUuid);
-
-          var listOfAttributeUuids = dehydratedEntry[JSON_MEMBER.ATTRIBUTE];
-          var firstAttributeUuid = listOfAttributeUuids[0];
-          var secondAttributeUuid = listOfAttributeUuids[1];
-          var firstAttribute = this._getItemFromUuidOrBootstrapItem(firstAttributeUuid);
-          var secondAttribute = this._getItemFromUuidOrBootstrapItem(secondAttributeUuid);
-          
-          var pairOfItems = [firstItem, secondItem];
-          var pairOfAttributes = [firstAttribute, secondAttribute];
-          entry._rehydrate(pairOfItems, pairOfAttributes, null, previousEntry, dataType);
-        } else {
-          itemUuid = dehydratedEntry[JSON_MEMBER.ITEM];
-          item = this._getItemFromUuidOrBootstrapItem(itemUuid);
-          var attributeUuid = dehydratedEntry[JSON_MEMBER.ATTRIBUTE];
-          var attribute = null;
-          if (attributeUuid) {
-            attribute = this._getItemFromUuidOrBootstrapItem(attributeUuid);
-          } else {
-            orp.lang.assert(false); // the attributeUuid should always be there
-          }
-          var rawData = dehydratedEntry[JSON_MEMBER.VALUE];
-          var finalData = null;
-          switch (dataTypeUuid) {
-            case orp.model.World.UUID.TYPE_ITEM:
-              finalData = this._getItemFromUuidOrBootstrapItem(rawData);
-              break;
-            case orp.model.World.UUID.TYPE_TEXT:
-              finalData = this.decodeText(rawData);
-              break;
-            case orp.model.World.UUID.TYPE_NUMBER:
-              finalData = parseFloat(rawData);
-              break;
-            case orp.model.World.UUID.TYPE_DATE:
-              finalData = new orp.util.DateValue(rawData);
-              // if (!finalData.isValid()) {
-              //   alert(rawData + &quot; &quot; + finalData);
-              // }
-              orp.lang.assert(finalData.isValid());
-              break;
-            default:
-              orp.lang.assert(false, 'Unknown data type while _rehydrating()');
-          }
-          entry._rehydrate(item, attribute, finalData, previousEntry, dataType);
-        }
-        this._chronologicalListOfRecords.push(entry);
-      }
-      
-    }
-  }
-};
-
-
-// -------------------------------------------------------------------
-// End of file
-// -------------------------------------------------------------------

Modified: trunk/source/model/World.js
===================================================================
--- trunk/source/model/World.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/World.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -33,7 +33,7 @@
 // Provides and Requires
 // -------------------------------------------------------------------
 dojo.provide(&quot;orp.model.World&quot;);
-dojo.require(&quot;orp.model.DeltaVirtualServer&quot;);
+dojo.require(&quot;orp.archive.DeltaArchive&quot;);
 dojo.require(&quot;orp.model.QueryRunner&quot;);
 dojo.require(&quot;orp.model.Vote&quot;);
 dojo.require(&quot;orp.model.Ordinal&quot;);
@@ -47,7 +47,7 @@
 /*global Util  */
 /*global Item, Entry, Ordinal, Vote, ContentRecord  */
 /*global QueryRunner  */ 
-/*global DeltaVirtualServer  */
+/*global DeltaArchive  */
 // -------------------------------------------------------------------
 
 
@@ -81,7 +81,7 @@
     var arrayWithFilenameAndExtension = lastSegment.split('.');
     var filename = arrayWithFilenameAndExtension[0];
     var repositoryName = filename;
-    server = new orp.model.DeltaVirtualServer(repositoryName);
+    server = new orp.archive.DeltaArchive(repositoryName);
   }
   this._virtualServer = server;
   server.setWorldAndLoadAxiomaticItems(this);

Deleted: trunk/source/model/append_to_repository_file.php
===================================================================
--- trunk/source/model/append_to_repository_file.php	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/append_to_repository_file.php	2005-10-04 01:33:56 UTC (rev 347)
@@ -1,34 +0,0 @@
-&lt;?php
-$contentToWrite = &quot;&quot; . $HTTP_RAW_POST_DATA . &quot;&quot;;
-
-$url_of_this_php_script = $_SERVER['REQUEST_URI'];
-$array_of_url_parts = explode(&quot;?&quot;, $url_of_this_php_script);
-$search_part = $array_of_url_parts[1];
-$array_of_search_parts = explode(&quot;=&quot;, $search_part);
-$file_name_parameter = $array_of_search_parts[1];
-$array_of_file_name_parameter_parts = explode(&quot;/&quot;, $file_name_parameter);
-$safe_file_name_with_no_path_exploits = $array_of_file_name_parameter_parts[0];
-
-$file_path = &quot;../../repositories/&quot;;
-$file_suffix = &quot;.json&quot;;
-$repository_file_name = $file_path . $safe_file_name_with_no_path_exploits . $file_suffix;
-
-if (is_writable($repository_file_name)) {
-  echo &quot;$repository_file_name is writable.&quot;;
-  if ($fileHandle = fopen($repository_file_name, &quot;ab&quot;)) { /* ab == append in binary mode */
-    if (fwrite($fileHandle, $contentToWrite)) {
-      fclose($fileHandle);
-      echo &quot;Appended to file ($repository_file_name)&quot;;
-    } else {
-      echo &quot;Unable to write to file ($repository_file_name)&quot;;
-      exit;
-    }
-  } else {
-    echo &quot;Unable to open file: $repository_file_name&quot;;
-    exit(&quot;Unable to open file.&quot;); 
-  }
-} else {
-  echo &quot;The file $repository_file_name is not writable.&quot;;
-}
-?&gt;
-

Deleted: trunk/source/model/write_to_repository_file.php
===================================================================
--- trunk/source/model/write_to_repository_file.php	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/source/model/write_to_repository_file.php	2005-10-04 01:33:56 UTC (rev 347)
@@ -1,37 +0,0 @@
-&lt;?php
-$contentToWrite = &quot;&quot; . $HTTP_RAW_POST_DATA . &quot;&quot;;
-
-$url_of_this_php_script = $_SERVER['REQUEST_URI'];
-$file_name_parameter = $_GET['file'];
-$array_of_file_name_parameter_parts = explode(&quot;/&quot;, $file_name_parameter);
-$safe_file_name_with_no_path_exploits = $array_of_file_name_parameter_parts[0];
-$overwrite_parameter = $_GET['overwrite'];
-
-$file_path = &quot;../../repositories/&quot;; /* relative to this php file */
-$file_suffix = &quot;.json&quot;;
-$repository_file_name = $file_path . $safe_file_name_with_no_path_exploits . $file_suffix;
-
-if ($overwrite_parameter != 'T') {
-  if (file_exists($repository_file_name)) {
-    exit(&quot;File $repository_file_name already exists.&quot;); 
-  }
-}
-if ($fileHandle = fopen($repository_file_name, &quot;wb&quot;)) { /* wb == write in binary mode */
-  /* It would be nice if this could be 0664, but then it won't be openable with 'file:' protocol,
-     unless the user is the same as the user of httpd (typically 'nobody').  I'm assuming chmod is 
-     ignored on non-unix systems, and that this note is relevant only on unix systems.  
-     Even if the user is in the same group as nobody, nsIFileOutputStream (called by 
-     FileSaver._mozillaSaveToFile) still won't open the file, at least on Mignon's Mac. */
-  chmod($repository_file_name, 0666);
-  if (fwrite($fileHandle, $contentToWrite)) {
-    fclose($fileHandle);
-    exit(&quot;Wrote to file ($repository_file_name)&quot;);
-  } else {
-    fclose($fileHandle);
-    exit(&quot;Unable to write to file ($repository_file_name)&quot;);
-  }
-} else {
-  exit(&quot;Unable to open file: $repository_file_name&quot;); 
-}
-?&gt;
-

Copied: trunk/source/storage/FileStorage.js (from rev 345, trunk/source/model/FileSaver.js)
===================================================================
--- trunk/source/model/FileSaver.js	2005-09-28 07:24:38 UTC (rev 345)
+++ trunk/source/storage/FileStorage.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,289 @@
+/*****************************************************************************
+ FileStorage.js
+ 
+******************************************************************************
+ The code in this file is a heavily modified version of code that was copied
+ from the TiddlyWiki and GTDTiddlyWiki code base.
+ 
+ The original code is Copyright (c) Osmosoft Limited.  The original copyright 
+ notice is included below, along with the license conditions and disclaimer.  
+ 
+ OpenRecord modifications by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+
+ For the OpenRecord modifications, the Copyright rights are relinquished under  
+ the Creative Commons Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+
+******************************************************************************
+TiddlyWiki 1.2.6 by Jeremy Ruston, (jeremy [at] osmosoft [dot] com)
+Incorporating improvements by Isao Sonobe, <A HREF="http://www-gauge.scphys.kyoto-u.ac.jp/~sonobe/OgreKit/OgreKitWiki.html">http://www-gauge.scphys.kyoto-u.ac.jp/~sonobe/OgreKit/OgreKitWiki.html</A>
+GTDTiddlyWiki modification by Nathan Bowers, (wiki [at] snapgrid [dot] com)
+Safari Compatability by Jonathan Paisley at <A HREF="http://www.dcs.gla.ac.uk/~jp/">http://www.dcs.gla.ac.uk/~jp/</A>
+
+Copyright (c) Osmosoft Limited, 14 April 2005
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+
+Redistributions in binary form must reproduce the above copyright notice, this
+list of conditions and the following disclaimer in the documentation and/or other
+materials provided with the distribution.
+
+Neither the name of the Osmosoft Limited nor the names of its contributors may be
+used to endorse or promote products derived from this software without specific
+prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+*****************************************************************************/
+
+
+// -------------------------------------------------------------------
+// Provides and Requires
+// -------------------------------------------------------------------
+dojo.provide(&quot;orp.storage.FileStorage&quot;);
+dojo.require(&quot;orp.archive.DeltaArchive&quot;);
+dojo.require(&quot;orp.lang.Lang&quot;);
+
+/**
+ * The FileStorage class knows how to save text to a local file.
+ *
+ * @param    repositoryName                 // e.g. demo_page
+ * @param    pathToTrunkDirectory           // Not needed if window.location.pathname is in the trunk directory.
+ * @scope    public instance constructor
+ */
+orp.storage.FileStorage = function(repositoryName, pathToTrunkDirectory) {
+  this._repositoryName = repositoryName;
+  
+  // Step 1: Build the fileUrl
+  // 
+  // Our saveTextToFile() method needs a fileUrl that looks like this:
+  //   fileUrl = &quot;K:\\www\\htdocs\\openrecord\\demo\\current\\trunk\\repositories\\demo_page.json&quot;;
+  // 
+  // We start with a value in this._repositoryName that looks like this:
+  //   this._repositoryName == &quot;demo_page&quot;
+
+  // URLs like these don't work:
+  //   fileUrl = &quot;repositories/demo_page.json&quot;;
+  //   fileUrl = &quot;repositories\\demo_page.json&quot;;
+  //   fileUrl = &quot;\\repositories\\demo_page.json&quot;;
+  //   fileUrl = &quot;K:/www/htdocs/openrecord/demo/current/trunk/repositories/demo_page.json&quot;;
+
+  var listOfAdditions = [];
+  if (pathToTrunkDirectory &amp;&amp; pathToTrunkDirectory !== &quot;&quot;) {
+    listOfAdditions.push(pathToTrunkDirectory);
+  }
+  listOfAdditions.push(orp.archive.DeltaArchive.PATH_TO_REPOSITORY_DIRECTORY);
+  listOfAdditions.push(this._repositoryName + &quot;.json&quot;);
+  this._fileUrl = this._getLocalPathFromWindowLocation(listOfAdditions);
+};
+
+
+/**
+ * Appends text to a file.
+ *
+ * @scope    public instance method
+ */
+orp.storage.FileStorage.prototype.appendText = function(textToAppend) {
+  var append = true;
+  this._saveTextToFile(textToAppend, this._fileUrl, append);
+};
+
+orp.storage.FileStorage.prototype.writeText = function(textToWrite, overwriteIfExists) {
+  var append = false;
+  this._saveTextToFile(textToWrite, this._fileUrl, append);
+};
+
+/**
+ * Save the text to the file at the given URL.
+ *
+ * @scope    private instance method
+ * @return   Returns true if the text was saved.
+ */
+orp.storage.FileStorage.prototype._saveTextToFile = function(text, fileUrl, append) {
+  // Make sure we were loaded from a &quot;file:&quot; URL
+  if (window.location.protocol != &quot;file:&quot;) {
+    orp.lang.assert(false, 'FileStorage.js can only be used for pages loaded from a &quot;<A HREF="file:///">file:///</A>&quot; location');
+  }
+
+  var success = this._mozillaSaveToFile(text, fileUrl, append);
+  if (!success) {
+    success = this._ieSaveToFile(text, fileUrl, append);
+  }
+  return(success);
+};
+
+
+/**
+ * Save the text to the file at the given filePath.
+ *
+ * @scope    private instance method
+ * @return   Returns true if the text was saved, false if there was an error, or null if we couldn't even try.
+ */
+orp.storage.FileStorage.prototype._mozillaSaveToFile = function(text, filePath, append) {
+  if (window.Components) {
+    try {
+      netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;);
+      var file = Components.classes[&quot;@mozilla.org/file/local;1&quot;].createInstance(Components.interfaces.nsILocalFile);
+      file.initWithPath(filePath);
+      if (!file.exists()) {
+        // Not all JavaScript implementations  support octal literals,
+        // so it's not safe to use '0664' here:
+        //   file.create(0, 0664);
+        //   file.permissions = 0664; // Because create ignores the permissions argument, at least on Mignon's Mac.
+        file.create(0, 0x1B4);
+        file.permissions = 0x1B4; // Because create ignores the permissions argument, at least on Mignon's Mac.
+      }
+      var outputStream = Components.classes[&quot;@mozilla.org/network/file-output-stream;1&quot;].createInstance(Components.interfaces.nsIFileOutputStream);
+      if (append) {
+        outputStream.init(file, 0x10 | 0x02, 0x0004, null);
+      } else {
+        outputStream.init(file, 0x20 | 0x02, 0x0004, null);
+      }
+      outputStream.write(text, text.length);
+      outputStream.flush();
+      outputStream.close();
+      return true;
+    }
+    catch(exception) {
+      alert(&quot;Exception while attempting to save\n\n&quot; + exception);
+      return false;
+    }
+  } else {
+    alert(&quot;window.Components == null&quot;);
+  }
+  return null;
+};
+
+
+/**
+ * Save the text to the file at the given filePath.
+ *
+ * @scope    private instance method
+ * @return   Returns true if the text was saved, or false if there was an error.
+ */
+orp.storage.FileStorage.prototype._ieSaveToFile = function(text, filePath, append) {
+  try {
+    var fileSystemObject = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);
+  }
+  catch(exception) {
+    alert(&quot;Exception while attempting to save\n\n&quot; + exception.toString());
+    return false;
+  }
+  if (append) {
+    orp.lang.assert(false, &quot;PENDING: still need to write code for this&quot;);
+  } else {
+    var file = fileSystemObject.OpenTextFile(filePath, 2, -1, 0);
+  }
+  file.Write(text);
+  file.Close();
+  return true;
+};
+
+
+/**
+ * This method looks at the URL value in the window.location property,
+ * strips the filename off the end, appends any given path elements,
+ * converts the whole thing to a format that is compatible with the 
+ * local file system, and returns the new local path.
+ *
+ * @scope    private instance method
+ * @return   Returns a full local pathname.
+ */
+orp.storage.FileStorage.prototype._getLocalPathFromWindowLocation = function(listOfAdditions) {
+  // Example location:
+  //   location.href     == <A HREF="file:///D:/amy/openrecord/foo.html#bar">file:///D:/amy/openrecord/foo.html#bar</A>
+  //   location.protocol == file:
+  //   location.pathname ==        /D:/amy/openrecord/foo.html
+  //   location.hash     ==                                   #bar
+
+  // Get the URL of the document
+  var pathname = window.location.pathname;
+  
+  
+  // Step 1: Make the requested additions to the pathname
+  var arrayOfParts = pathname.split('/');
+  arrayOfParts.pop();  // get rid of the final &quot;/foo.html&quot; part
+  for (var i in listOfAdditions) {
+    var additionalPart = listOfAdditions[i];
+    arrayOfParts.push(additionalPart);
+  }
+  pathname = arrayOfParts.join('/');
+
+  
+  // Step 2: Figure out what type of URL we're working with
+  // Constants
+  var PathType = {
+    LOCAL_PC:        &quot;LOCAL_PC&quot;,          // &quot;<A HREF="file:///x:/path/path...">file:///x:/path/path...</A>&quot; 
+    LOCAL_UNIX_MAC:  &quot;LOCAL_UNIX_MAC&quot;,    // &quot;<A HREF="file:///path/path...">file:///path/path...</A>&quot;
+    NETWORK_PC:      &quot;NETWORK_PC&quot;,        // &quot;<A HREF="file://server/share/path/path...">file://server/share/path/path...</A>&quot;
+    NETWORK_FIREFOX: &quot;NETWORK_FIREFOX&quot; }; // &quot;<A HREF="file://///server/share/path/path...">file://///server/share/path/path...</A>&quot;
+  // &quot;<A HREF="file:///x:/path/path...">file:///x:/path/path...</A>&quot;             == PathType.LOCAL_PC        --&gt; &quot;x:\path\path...&quot;
+  // &quot;<A HREF="file:///path/path...">file:///path/path...</A>&quot;                == PathType.LOCAL_UNIX_MAC  --&gt; &quot;/path/path...&quot;
+  // &quot;<A HREF="file://server/share/path/path...">file://server/share/path/path...</A>&quot;    == PathType.NETWORK_PC      --&gt; &quot;\\server\share\path\path...&quot;
+  // &quot;<A HREF="file://///server/share/path/path...">file://///server/share/path/path...</A>&quot; == PathType.NETWORK_FIREFOX --&gt; &quot;\\server\share\path\path...&quot;
+
+  var pathType = null;
+  if (pathname.charAt(2) == &quot;:&quot;) {
+    pathType = PathType.LOCAL_PC;
+  } else if (pathname.indexOf(&quot;///&quot;) === 0) {
+    pathType = PathType.NETWORK_FIREFOX;
+  } else if (pathname.indexOf(&quot;/&quot;) === 0) {
+    pathType = PathType.LOCAL_UNIX_MAC;
+  } else {
+    pathType = PathType.NETWORK_PC;
+  }
+
+
+  // Step 3: Convert the URL to a file path
+  var localPath = pathname;
+  switch (pathType) {
+    case PathType.LOCAL_PC:
+      // example: &quot;/x:/path/path...&quot;
+      localPath = localPath.substring(1);  // get rid of initial '/'
+      localPath = unescape(localPath);
+      localPath = localPath.replace(new RegExp(&quot;/&quot;,&quot;g&quot;),&quot;\\&quot;);
+      // result: &quot;x:\path\path...&quot;
+      break;
+    case PathType.LOCAL_UNIX_MAC:         
+    // example: &quot;/path/path...&quot;
+      localPath = unescape(localPath);
+      // result: &quot;/path/path...&quot;
+      break;
+    case PathType.NETWORK_FIREFOX:
+      // example: &quot;///server/share/path/path...&quot;
+      localPath = localPath.substring(3);  // get rid of initial '///'
+      localPath = unescape(localPath);
+      localPath = localPath.replace(new RegExp(&quot;/&quot;,&quot;g&quot;),&quot;\\&quot;);
+      localPath = &quot;\\\\&quot; + localPath;      
+      // result: &quot;\\server\share\path\path...&quot;
+      break;
+    case PathType.NETWORK_PC:
+      // example: &quot;server/share/path/path...&quot;
+      localPath = unescape(localPath);
+      localPath = localPath.replace(new RegExp(&quot;/&quot;,&quot;g&quot;),&quot;\\&quot;);
+      localPath = &quot;\\\\&quot; + localPath;      
+      // result: &quot;\\server\share\path\path...&quot;
+      break;
+  }
+
+  return localPath;
+};
+
+
+// -------------------------------------------------------------------
+// End of file
+// -------------------------------------------------------------------

Copied: trunk/source/storage/HttpStorage.js (from rev 345, trunk/source/model/HttpSaver.js)
===================================================================
--- trunk/source/model/HttpSaver.js	2005-09-28 07:24:38 UTC (rev 345)
+++ trunk/source/storage/HttpStorage.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,140 @@
+/*****************************************************************************
+ HttpStorage.js
+  
+******************************************************************************
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+  
+ You can copy freely from this file.  This work may be freely reproduced, 
+ distributed, transmitted, used, modified, built upon, or otherwise exploited
+ by anyone for any purpose.
+  
+ This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
+ of any kind, either express or implied, including, without limitation, any 
+ warranties or conditions of title, non-infringement, merchantability, or 
+ fitness for a particular purpose. You are solely responsible for determining 
+ the appropriateness of using or distributing the work and assume all risks 
+ associated with use of this work, including but not limited to the risks and 
+ costs of errors, compliance with applicable laws, damage to or loss of data 
+ or equipment, and unavailability or interruption of operations.
+
+ In no event shall the authors or contributors have any liability for any 
+ direct, indirect, incidental, special, exemplary, or consequential damages,
+ however caused and on any theory of liability, whether in contract, strict 
+ liability, or tort (including negligence), arising in any way out of or in 
+ connection with the use or distribution of the work.
+*****************************************************************************/
+
+
+// -------------------------------------------------------------------
+// Provides and Requires
+// -------------------------------------------------------------------
+dojo.provide(&quot;orp.storage.HttpStorage&quot;);
+
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+/**
+ * The HttpStorage class knows how to save content to a server by using
+ * XMLHttpRequest to call a PHP script.
+ *
+ * @param    repositoryName                         // e.g. demo_page
+ * @param    pathToTrunkDirectoryFromWindowLocation // Not needed if window location is at the root of the trunk directory.
+ * @scope    public instance constructor
+ */
+orp.storage.HttpStorage = function(repositoryName, pathToTrunkDirectoryFromWindowLocation) {
+  this._repositoryName = repositoryName;
+  var thisUrl = window.location.pathname; //e.g. /openrecord/trunk/demo_page.html or /openrecord/trunk/source/model/TestRepositoryWriting.html.
+  var arrayOfPathComponents = thisUrl.split('/');
+  arrayOfPathComponents.pop();
+  var thisDirectory = arrayOfPathComponents.join('/'); //e.g. /openrecord/trunk or /openrecord/trunk/source/model
+  if (pathToTrunkDirectoryFromWindowLocation) {
+    this._completePathToTrunkDirectory = thisDirectory + '/' + pathToTrunkDirectoryFromWindowLocation;
+  } else {
+    this._completePathToTrunkDirectory = thisDirectory;
+  }
+};
+
+
+// -------------------------------------------------------------------
+// Public methods
+// -------------------------------------------------------------------
+
+/**
+ */
+orp.storage.HttpStorage.prototype.appendText = function(textToAppend) {
+  var url = this._completePathToTrunkDirectory;
+  url += &quot;/source/model/append_to_repository_file.php?file=&quot; + this._repositoryName;
+  
+  // PENDING: 
+  // It might be more efficient to re-use the XMLHttpRequestObject,
+  // rather than creating a new one for new request.  But re-using 
+  // them is complicated, because the requests are asynchronous, so
+  // we need to check to see if the last request is done before we 
+  // can start a new request.
+  var newXMLHttpRequestObject = this._newXMLHttpRequestObject();
+  var asynchronous = true;
+  newXMLHttpRequestObject.open(&quot;POST&quot;, url, asynchronous);
+  newXMLHttpRequestObject.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
+  newXMLHttpRequestObject.send(textToAppend);
+};
+
+
+/**
+ */
+orp.storage.HttpStorage.prototype.writeText = function(textToWrite, overwriteIfExists) {
+  var url = this._completePathToTrunkDirectory;
+  url += &quot;/source/model/write_to_repository_file.php?file=&quot; + this._repositoryName;
+  if (overwriteIfExists) {
+    url += &quot;&amp;overwrite=T&quot;;
+  }
+  var newXMLHttpRequestObject = this._newXMLHttpRequestObject();
+  var asynchronous = true;
+  newXMLHttpRequestObject.open(&quot;POST&quot;, url, asynchronous);
+  newXMLHttpRequestObject.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
+  newXMLHttpRequestObject.send(textToWrite);
+};
+
+
+// -------------------------------------------------------------------
+// Private methods
+// -------------------------------------------------------------------
+
+/**
+ * Returns a newly created XMLHttpRequest object.
+ *
+ * @scope    private instance method
+ * @return   A newly created XMLHttpRequest object. 
+ */
+orp.storage.HttpStorage.prototype._newXMLHttpRequestObject = function() {
+  var newXMLHttpRequestObject = null;
+  if (window.XMLHttpRequest) {
+    newXMLHttpRequestObject = new XMLHttpRequest();
+  } else {
+    if (window.ActiveXObject) {
+      newXMLHttpRequestObject = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
+    }
+  }
+  if (newXMLHttpRequestObject) {
+    newXMLHttpRequestObject.onreadystatechange = function() {
+      var statusText = newXMLHttpRequestObject.statusText;
+      if (statusText != &quot;OK&quot;) {
+        window.alert(&quot;onreadystatechange:\n&quot; +
+          &quot;readyState: &quot; + newXMLHttpRequestObject.readyState + &quot;\n&quot; +
+          &quot;status: &quot; + newXMLHttpRequestObject.status + &quot;\n&quot; +
+          &quot;statusText: &quot; + newXMLHttpRequestObject.statusText + &quot;\n&quot; +
+          &quot;responseText: &quot; + newXMLHttpRequestObject.responseText + &quot;\n&quot;);
+      }
+    };
+  }
+  return newXMLHttpRequestObject;
+};
+
+
+// -------------------------------------------------------------------
+// End of file
+// -------------------------------------------------------------------

Copied: trunk/source/storage/append_to_repository_file.php (from rev 345, trunk/source/model/append_to_repository_file.php)

Copied: trunk/source/storage/write_to_repository_file.php (from rev 345, trunk/source/model/write_to_repository_file.php)

Modified: trunk/tests/TestSuite.html
===================================================================
--- trunk/tests/TestSuite.html	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/TestSuite.html	2005-10-04 01:33:56 UTC (rev 347)
@@ -28,6 +28,8 @@
         testSuite.addTestPage(&quot;../../../tests/lang/LangTest.html&quot;);
         testSuite.addTestPage(&quot;../../../tests/util/TestSuite.html&quot;);
         testSuite.addTestPage(&quot;../../../tests/model/TestSuite.html&quot;);
+        testSuite.addTestPage(&quot;../../../tests/archive/LintTest.html&quot;);
+        testSuite.addTestPage(&quot;../../../tests/storage/LintTest.html&quot;);
         testSuite.addTestPage(&quot;../../../tests/view/LintTest.html&quot;);
         testSuite.addTestPage(&quot;../../../tests/LintTest.html&quot;);
         return testSuite;

Added: trunk/tests/archive/LintTest.html
===================================================================
--- trunk/tests/archive/LintTest.html	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/archive/LintTest.html	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,77 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;<A HREF="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</A>&quot;&gt;
+&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot; xml:lang=&quot;en&quot; &gt;
+
+&lt;!-- 
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+--&gt;
+
+  &lt;head&gt;
+    &lt;title&gt;Unit tests using jslint&lt;/title&gt;
+
+    &lt;script type=&quot;text/javascript&quot; src=&quot;../../third_party/jsunit/jsunit2_1/app/jsUnitCore.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;../../third_party/dojo/dojo-0.1.0/dojo.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;../../third_party/jslint/fulljslint.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;LintTest.js&quot;&gt;&lt;/script&gt;
+  &lt;/head&gt;
+  
+  &lt;body&gt;
+    &lt;h1&gt;Unit tests using jslint&lt;/h1&gt;
+
+    &lt;p&gt;This page is used to run unit tests for the JavaScript code in the 
+    OpenRecord project.&lt;/p&gt;
+    
+    &lt;p&gt;&nbsp;&lt;/p&gt;
+    &lt;hr/&gt;
+    &lt;p&gt;You should be able to run these unit tests by going to
+    &lt;a href=&quot;../../third_party/jsunit/jsunit2_1/testRunner.html?testpage=&quot; 
+    onclick=&quot;href+=window.location.href;&quot; rel=&quot;external&quot;&gt;the local testRunner 
+    page&lt;/a&gt;, and hitting the &lt;b&gt;Run&lt;/b&gt; button.&lt;/p&gt;
+
+    &lt;p&gt;To see the tests, open this .html file in a text editor. Or, within a  
+    web browser, you should be able see the source for this file by using 
+    some menu like &lt;b&gt;View&lt;/b&gt; followed by &lt;b&gt;Page Source&lt;/b&gt;. The tests 
+    may be in this file, or they may be in a separate file that has the
+    same name as this one, except with a .js extension instead of a .html
+    extension.&lt;/p&gt;
+ 
+    &lt;p&gt;The unit tests are set up to run in the
+    &lt;a href=&quot;<A HREF="http://www.edwardh.com/jsunit/">http://www.edwardh.com/jsunit/</A>&quot; rel=&quot;external&quot;&gt;JsUnit framework&lt;/a&gt;
+    written by 
+    &lt;a href=&quot;<A HREF="http://www.edwardh.com/">http://www.edwardh.com/</A>&quot; rel=&quot;external&quot;&gt;Edward Hieatt&lt;/a&gt;. &lt;/p&gt;
+
+    &lt;p&gt;&nbsp;&lt;/p&gt;
+    &lt;hr/&gt;
+    &lt;p class=&quot;copyright&quot;&gt;You can copy freely from this work &mdash; copyright 
+    rights relinquished under the Creative Commons  
+    &lt;a rel=&quot;license external&quot; 
+    href=&quot;<A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>&quot;&gt;Public Domain 
+    Dedication&lt;/a&gt;.&lt;/p&gt;
+
+&lt;!-- Creative Commons metadata for Public Domain License 
+
+&lt;rdf:RDF xmlns=&quot;<A HREF="http://web.resource.org/cc/">http://web.resource.org/cc/</A>&quot;
+    xmlns:dc=&quot;<A HREF="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</A>&quot;
+    xmlns:rdf=&quot;<A HREF="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</A>&quot;&gt;
+&lt;Work rdf:about=&quot;&quot;&gt;
+   &lt;dc:title&gt;openrecord.org&lt;/dc:title&gt;
+   &lt;dc:type rdf:resource=&quot;<A HREF="http://purl.org/dc/dcmitype/Text">http://purl.org/dc/dcmitype/Text</A>&quot; /&gt;
+   &lt;license rdf:resource=&quot;<A HREF="http://web.resource.org/cc/PublicDomain">http://web.resource.org/cc/PublicDomain</A>&quot; /&gt;
+&lt;/Work&gt;
+
+&lt;License rdf:about=&quot;<A HREF="http://web.resource.org/cc/PublicDomain">http://web.resource.org/cc/PublicDomain</A>&quot;&gt;
+   &lt;permits rdf:resource=&quot;<A HREF="http://web.resource.org/cc/Reproduction">http://web.resource.org/cc/Reproduction</A>&quot; /&gt;
+   &lt;permits rdf:resource=&quot;<A HREF="http://web.resource.org/cc/Distribution">http://web.resource.org/cc/Distribution</A>&quot; /&gt;
+   &lt;permits rdf:resource=&quot;<A HREF="http://web.resource.org/cc/DerivativeWorks">http://web.resource.org/cc/DerivativeWorks</A>&quot; /&gt;
+&lt;/License&gt;
+
+&lt;/rdf:RDF&gt;
+
+--&gt;
+  &lt;/body&gt;
+&lt;/html&gt;
+

Added: trunk/tests/archive/LintTest.js
===================================================================
--- trunk/tests/archive/LintTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/archive/LintTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,69 @@
+/*****************************************************************************
+ LintTest.js
+ 
+******************************************************************************
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+  
+ You can copy freely from this file.  This work may be freely reproduced, 
+ distributed, transmitted, used, modified, built upon, or otherwise exploited
+ by anyone for any purpose.
+  
+ This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
+ of any kind, either express or implied, including, without limitation, any 
+ warranties or conditions of title, non-infringement, merchantability, or 
+ fitness for a particular purpose. You are solely responsible for determining 
+ the appropriateness of using or distributing the work and assume all risks 
+ associated with use of this work, including but not limited to the risks and 
+ costs of errors, compliance with applicable laws, damage to or loss of data 
+ or equipment, and unavailability or interruption of operations.
+
+ In no event shall the authors or contributors have any liability for any 
+ direct, indirect, incidental, special, exemplary, or consequential damages,
+ however caused and on any theory of liability, whether in contract, strict 
+ liability, or tort (including negligence), arising in any way out of or in 
+ connection with the use or distribution of the work.
+*****************************************************************************/
+ 
+// -------------------------------------------------------------------
+// Dependencies, expressed in the syntax that JSLint understands:
+// 
+/*global LintTool, assertTrue, setUp, tearDown */
+// -------------------------------------------------------------------
+
+
+// -------------------------------------------------------------------
+// setUp and tearDown
+// -------------------------------------------------------------------
+
+function setUp() {
+  dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
+  dojo.hostenv.setModulePrefix(&quot;orp&quot;, &quot;../../../../source&quot;);
+  dojo.require(&quot;orp.util.LintTool&quot;);
+}
+
+function tearDown() {
+}
+
+
+// -------------------------------------------------------------------
+// Test functions
+// -------------------------------------------------------------------
+
+function testJsLintOnOpenRecordCode() {
+  var listOfSourceCodeFiles = [
+    &quot;DeltaArchive.js&quot;,
+    &quot;StubArchive.js&quot;];
+  var prefix = &quot;../../../source/archive/&quot;;
+  var errorReport = orp.util.LintTool.getErrorReportFromListOfFilesnames(listOfSourceCodeFiles, prefix);
+  var message = &quot;Lint check \n&quot; + errorReport;
+  assertTrue(message, !errorReport);
+}
+
+
+// -------------------------------------------------------------------
+// End of file
+// -------------------------------------------------------------------

Modified: trunk/tests/model/LintTest.js
===================================================================
--- trunk/tests/model/LintTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/model/LintTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -56,15 +56,11 @@
 function testJsLintOnOpenRecordCode() {
   var listOfSourceCodeFiles = [
     &quot;ContentRecord.js&quot;,
-    &quot;DeltaVirtualServer.js&quot;,
     &quot;Entry.js&quot;,
-    &quot;FileSaver.js&quot;,
-    &quot;HttpSaver.js&quot;,
     &quot;Item.js&quot;,
     &quot;Ordinal.js&quot;,
     &quot;QueryRunner.js&quot;,
     &quot;Record.js&quot;,
-    &quot;StubVirtualServer.js&quot;,
     &quot;Transaction.js&quot;,
     &quot;Vote.js&quot;,
     &quot;World.js&quot;];

Modified: trunk/tests/model/ModelTest.js
===================================================================
--- trunk/tests/model/ModelTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/model/ModelTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -33,7 +33,7 @@
 // 
 /*global Util */
 /*global World, Item, Entry */
-/*global StubVirtualServer */
+/*global StubArchive */
 /*global assertTrue, assertFalse, setUp, tearDown */
 // -------------------------------------------------------------------
 
@@ -49,14 +49,14 @@
   dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
   dojo.hostenv.setModulePrefix(&quot;orp&quot;, &quot;../../../../source&quot;);
   dojo.require(&quot;orp.model.World&quot;);
-  dojo.require(&quot;orp.model.StubVirtualServer&quot;);
+  dojo.require(&quot;orp.archive.StubArchive&quot;);
   dojo.require(&quot;orp.util.DateValue&quot;);
 
   ModelTestVars = {};
 
   var pathToTrunkDirectory = &quot;../..&quot;;
-  var stubVirtualServer = new orp.model.StubVirtualServer(pathToTrunkDirectory);
-  world = new orp.model.World(stubVirtualServer);
+  var stubArchive = new orp.archive.StubArchive(pathToTrunkDirectory);
+  world = new orp.model.World(stubArchive);
 }
 
 function tearDown() {

Modified: trunk/tests/model/RepositoryWritingTest.js
===================================================================
--- trunk/tests/model/RepositoryWritingTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/model/RepositoryWritingTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -44,15 +44,15 @@
 function setUp() {
   dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
   dojo.hostenv.setModulePrefix(&quot;orp&quot;, &quot;../../../../source&quot;);
-  dojo.require(&quot;orp.model.DeltaVirtualServer&quot;);
+  dojo.require(&quot;orp.archive.DeltaArchive&quot;);
   dojo.require(&quot;orp.model.World&quot;);
 
   utilAssertReportedError = false;
   orp.util.setErrorReportCallback(errorReporter)
 
   var isHttp = window.location.protocol == &quot;http:&quot;;
-  saver = isHttp? new orp.model.HttpSaver(fileName, pathToTrunkDirectoryFromThisDirectory) 
-                : new orp.model.FileSaver(fileName, pathToTrunkDirectoryFromThisDirectory);
+  saver = isHttp? new orp.storage.HttpStorage(fileName, pathToTrunkDirectoryFromThisDirectory) 
+                : new orp.storage.FileStorage(fileName, pathToTrunkDirectoryFromThisDirectory);
 
   // Examples of what window.location.pathname should look like:
   // for http: protocol: /openrecord/trunk/source/model/TestRepositoryWriting.html
@@ -109,14 +109,14 @@
 }
 
 function testCreateNewRepository() {
-  var virtualServer = new orp.model.DeltaVirtualServer(fileName, pathToTrunkDirectoryFromThisDirectory);
+  var virtualServer = new orp.archive.DeltaArchive(fileName, pathToTrunkDirectoryFromThisDirectory);
   var overwriteIfExists = true;
   virtualServer._createNewRepository(overwriteIfExists);
   assertTrue(&quot;Contents should be '{ \&quot;format\&quot;: \&quot;2005_JUNE_CHRONOLOGICAL_LIST\&quot;, ...'.&quot;, fileHasExpectedContents(expectedRepositoryHeader));
 }
 
 function testAppendToRepository() {
-  var virtualServer = new orp.model.DeltaVirtualServer(fileName, pathToTrunkDirectoryFromThisDirectory);
+  var virtualServer = new orp.archive.DeltaArchive(fileName, pathToTrunkDirectoryFromThisDirectory);
   var overwriteIfExists = true;
   virtualServer._createNewRepository(overwriteIfExists);
   var world = new orp.model.World(virtualServer);

Modified: trunk/tests/model/TestReorderingForSpecialCases.js
===================================================================
--- trunk/tests/model/TestReorderingForSpecialCases.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/model/TestReorderingForSpecialCases.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -35,7 +35,7 @@
 // 
 /*global Util */
 /*global World, Item, Entry */
-/*global StubVirtualServer */
+/*global StubArchive */
 /*global assertTrue, assertFalse, setUp, tearDown */
 // -------------------------------------------------------------------
 
@@ -50,16 +50,16 @@
 function setUp() {
   dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
   dojo.hostenv.setModulePrefix(&quot;orp&quot;, &quot;../../../../source&quot;);
-  dojo.require(&quot;orp.model.StubVirtualServer&quot;);
+  dojo.require(&quot;orp.archive.StubArchive&quot;);
   dojo.require(&quot;orp.model.World&quot;);
 
   var pathToTrunkDirectory = &quot;../..&quot;;
-  var virtualServer = new orp.model.StubVirtualServer(pathToTrunkDirectory);
+  var archive = new orp.archive.StubArchive(pathToTrunkDirectory);
 
-  realUuidGenerator = orp.model.StubVirtualServer.prototype._generateUuid;
-  orp.model.StubVirtualServer.prototype._generateUuid = mockUuidGenerator;
+  realUuidGenerator = orp.archive.StubArchive.prototype._generateUuid;
+  orp.archive.StubArchive.prototype._generateUuid = mockUuidGenerator;
 
-  world = new orp.model.World(virtualServer);
+  world = new orp.model.World(archive);
 
   annUuid1 = &quot;10000000-2222-1333-F444-555555555555&quot;;
   annUuid2 = &quot;10000001-2222-1333-F444-555555555555&quot;;
@@ -108,7 +108,7 @@
   var pesto = world.newItem(&quot;Pesto&quot;);
   var guava = world.newItem(&quot;Guava&quot;);
 
-  orp.model.StubVirtualServer.prototype._generateUuid = realUuidGenerator;
+  orp.archive.StubArchive.prototype._generateUuid = realUuidGenerator;
   
   assertTrue(sushi.getOrdinalNumber() == pesto.getOrdinalNumber());
   
@@ -140,11 +140,11 @@
   assertTrue('Sushi and Pesto have same timestamp', sushi.getTimestamp() == pesto.getTimestamp());
   assertTrue('Sushi and Guava have same timestamp', sushi.getTimestamp() == guava.getTimestamp());
 
-  orp.model.StubVirtualServer.prototype._generateUuid = realUuidGenerator;
+  orp.archive.StubArchive.prototype._generateUuid = realUuidGenerator;
 
   guava.reorderBetween(sushi, pesto);
 
-  orp.model.StubVirtualServer.prototype._generateUuid = mockUuidGenerator;
+  orp.archive.StubArchive.prototype._generateUuid = mockUuidGenerator;
 
   sushiLinkUuid    = &quot;60000000-2222-1333-F444-555555555555&quot;;
   mockUuidGenerator.queueOfUuids.push(sushiLinkUuid);
@@ -155,7 +155,7 @@
   guavaLinkUuid    = &quot;60000002-2222-1333-F444-555555555555&quot;;
   mockUuidGenerator.queueOfUuids.push(guavaLinkUuid);
   
-  orp.model.StubVirtualServer.prototype._generateUuid = realUuidGenerator;
+  orp.archive.StubArchive.prototype._generateUuid = realUuidGenerator;
 
   guava.assignToCategory(categoryCalledFood);
 

Modified: trunk/tests/model/TestReorderingForTypicalOrdinals.js
===================================================================
--- trunk/tests/model/TestReorderingForTypicalOrdinals.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/model/TestReorderingForTypicalOrdinals.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -35,7 +35,7 @@
 // 
 /*global Util */
 /*global World, Item, Entry */
-/*global StubVirtualServer */
+/*global StubArchive */
 /*global assertTrue, assertFalse, setUp, tearDown */
 // -------------------------------------------------------------------
 
@@ -54,23 +54,23 @@
 function setUp() {
   dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
   dojo.hostenv.setModulePrefix(&quot;orp&quot;, &quot;../../../../source&quot;);
-  dojo.require(&quot;orp.model.StubVirtualServer&quot;);
+  dojo.require(&quot;orp.archive.StubArchive&quot;);
   dojo.require(&quot;orp.model.World&quot;);
   
   ContentRecord = orp.model.ContentRecord;
 
   var pathToTrunkDirectory = &quot;../..&quot;;
-  var virtualServer = new orp.model.StubVirtualServer(pathToTrunkDirectory);
-  var realUuidGenerator = orp.model.StubVirtualServer.prototype._generateUuid;
-  orp.model.StubVirtualServer.prototype._generateUuid = mockUuidGenerator;
+  var archive = new orp.archive.StubArchive(pathToTrunkDirectory);
+  var realUuidGenerator = orp.archive.StubArchive.prototype._generateUuid;
+  orp.archive.StubArchive.prototype._generateUuid = mockUuidGenerator;
 /*
-You can use DeltaVirtualServer instead if you want to append all transactions to a file for debugging purposes.
+You can use DeltaArchive instead if you want to append all transactions to a file for debugging purposes.
 Note that the tests will run a lot slower if you do.
 
-  var virtualServer = new orp.model.DeltaVirtualServer(&quot;OrdinalsTest&quot;, pathToTrunkDirectory, {&quot;_generateUuid&quot;:mockUuidGenerator});
+  var archive = new orp.archive.DeltaArchive(&quot;OrdinalsTest&quot;, pathToTrunkDirectory, {&quot;_generateUuid&quot;:mockUuidGenerator});
 */
 
-  world = new orp.model.World(virtualServer);
+  world = new orp.model.World(archive);
 
   annUuid1 = &quot;10000000-2222-1333-F444-555555555555&quot;;
   annUuid2 = &quot;10000001-2222-1333-F444-555555555555&quot;;
@@ -130,7 +130,7 @@
   mockUuidGenerator.queueOfUuids.push(taffyLinkUuid);
   taffy.assignToCategory(categoryCalledFood);
 
-  orp.model.StubVirtualServer.prototype._generateUuid = realUuidGenerator;
+  orp.archive.StubArchive.prototype._generateUuid = realUuidGenerator;
 }
 
 function tearDown() {

Added: trunk/tests/storage/LintTest.html
===================================================================
--- trunk/tests/storage/LintTest.html	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/storage/LintTest.html	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,77 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;<A HREF="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</A>&quot;&gt;
+&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot; xml:lang=&quot;en&quot; &gt;
+
+&lt;!-- 
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+--&gt;
+
+  &lt;head&gt;
+    &lt;title&gt;Unit tests using jslint&lt;/title&gt;
+
+    &lt;script type=&quot;text/javascript&quot; src=&quot;../../third_party/jsunit/jsunit2_1/app/jsUnitCore.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;../../third_party/dojo/dojo-0.1.0/dojo.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;../../third_party/jslint/fulljslint.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;LintTest.js&quot;&gt;&lt;/script&gt;
+  &lt;/head&gt;
+  
+  &lt;body&gt;
+    &lt;h1&gt;Unit tests using jslint&lt;/h1&gt;
+
+    &lt;p&gt;This page is used to run unit tests for the JavaScript code in the 
+    OpenRecord project.&lt;/p&gt;
+    
+    &lt;p&gt;&nbsp;&lt;/p&gt;
+    &lt;hr/&gt;
+    &lt;p&gt;You should be able to run these unit tests by going to
+    &lt;a href=&quot;../../third_party/jsunit/jsunit2_1/testRunner.html?testpage=&quot; 
+    onclick=&quot;href+=window.location.href;&quot; rel=&quot;external&quot;&gt;the local testRunner 
+    page&lt;/a&gt;, and hitting the &lt;b&gt;Run&lt;/b&gt; button.&lt;/p&gt;
+
+    &lt;p&gt;To see the tests, open this .html file in a text editor. Or, within a  
+    web browser, you should be able see the source for this file by using 
+    some menu like &lt;b&gt;View&lt;/b&gt; followed by &lt;b&gt;Page Source&lt;/b&gt;. The tests 
+    may be in this file, or they may be in a separate file that has the
+    same name as this one, except with a .js extension instead of a .html
+    extension.&lt;/p&gt;
+ 
+    &lt;p&gt;The unit tests are set up to run in the
+    &lt;a href=&quot;<A HREF="http://www.edwardh.com/jsunit/">http://www.edwardh.com/jsunit/</A>&quot; rel=&quot;external&quot;&gt;JsUnit framework&lt;/a&gt;
+    written by 
+    &lt;a href=&quot;<A HREF="http://www.edwardh.com/">http://www.edwardh.com/</A>&quot; rel=&quot;external&quot;&gt;Edward Hieatt&lt;/a&gt;. &lt;/p&gt;
+
+    &lt;p&gt;&nbsp;&lt;/p&gt;
+    &lt;hr/&gt;
+    &lt;p class=&quot;copyright&quot;&gt;You can copy freely from this work &mdash; copyright 
+    rights relinquished under the Creative Commons  
+    &lt;a rel=&quot;license external&quot; 
+    href=&quot;<A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>&quot;&gt;Public Domain 
+    Dedication&lt;/a&gt;.&lt;/p&gt;
+
+&lt;!-- Creative Commons metadata for Public Domain License 
+
+&lt;rdf:RDF xmlns=&quot;<A HREF="http://web.resource.org/cc/">http://web.resource.org/cc/</A>&quot;
+    xmlns:dc=&quot;<A HREF="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</A>&quot;
+    xmlns:rdf=&quot;<A HREF="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</A>&quot;&gt;
+&lt;Work rdf:about=&quot;&quot;&gt;
+   &lt;dc:title&gt;openrecord.org&lt;/dc:title&gt;
+   &lt;dc:type rdf:resource=&quot;<A HREF="http://purl.org/dc/dcmitype/Text">http://purl.org/dc/dcmitype/Text</A>&quot; /&gt;
+   &lt;license rdf:resource=&quot;<A HREF="http://web.resource.org/cc/PublicDomain">http://web.resource.org/cc/PublicDomain</A>&quot; /&gt;
+&lt;/Work&gt;
+
+&lt;License rdf:about=&quot;<A HREF="http://web.resource.org/cc/PublicDomain">http://web.resource.org/cc/PublicDomain</A>&quot;&gt;
+   &lt;permits rdf:resource=&quot;<A HREF="http://web.resource.org/cc/Reproduction">http://web.resource.org/cc/Reproduction</A>&quot; /&gt;
+   &lt;permits rdf:resource=&quot;<A HREF="http://web.resource.org/cc/Distribution">http://web.resource.org/cc/Distribution</A>&quot; /&gt;
+   &lt;permits rdf:resource=&quot;<A HREF="http://web.resource.org/cc/DerivativeWorks">http://web.resource.org/cc/DerivativeWorks</A>&quot; /&gt;
+&lt;/License&gt;
+
+&lt;/rdf:RDF&gt;
+
+--&gt;
+  &lt;/body&gt;
+&lt;/html&gt;
+

Added: trunk/tests/storage/LintTest.js
===================================================================
--- trunk/tests/storage/LintTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/storage/LintTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -0,0 +1,69 @@
+/*****************************************************************************
+ LintTest.js
+ 
+******************************************************************************
+ Written in 2005 by Brian Douglas Skinner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openrecord-svn">brian.skinner at gumption.org</A>&gt;
+  
+ Copyright rights relinquished under the Creative Commons  
+ Public Domain Dedication:
+    <A HREF="http://creativecommons.org/licenses/publicdomain/">http://creativecommons.org/licenses/publicdomain/</A>
+  
+ You can copy freely from this file.  This work may be freely reproduced, 
+ distributed, transmitted, used, modified, built upon, or otherwise exploited
+ by anyone for any purpose.
+  
+ This work is provided on an &quot;AS IS&quot; basis, without warranties or conditions 
+ of any kind, either express or implied, including, without limitation, any 
+ warranties or conditions of title, non-infringement, merchantability, or 
+ fitness for a particular purpose. You are solely responsible for determining 
+ the appropriateness of using or distributing the work and assume all risks 
+ associated with use of this work, including but not limited to the risks and 
+ costs of errors, compliance with applicable laws, damage to or loss of data 
+ or equipment, and unavailability or interruption of operations.
+
+ In no event shall the authors or contributors have any liability for any 
+ direct, indirect, incidental, special, exemplary, or consequential damages,
+ however caused and on any theory of liability, whether in contract, strict 
+ liability, or tort (including negligence), arising in any way out of or in 
+ connection with the use or distribution of the work.
+*****************************************************************************/
+ 
+// -------------------------------------------------------------------
+// Dependencies, expressed in the syntax that JSLint understands:
+// 
+/*global LintTool, assertTrue, setUp, tearDown */
+// -------------------------------------------------------------------
+
+
+// -------------------------------------------------------------------
+// setUp and tearDown
+// -------------------------------------------------------------------
+
+function setUp() {
+  dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
+  dojo.hostenv.setModulePrefix(&quot;orp&quot;, &quot;../../../../source&quot;);
+  dojo.require(&quot;orp.util.LintTool&quot;);
+}
+
+function tearDown() {
+}
+
+
+// -------------------------------------------------------------------
+// Test functions
+// -------------------------------------------------------------------
+
+function testJsLintOnOpenRecordCode() {
+  var listOfSourceCodeFiles = [
+    &quot;FileStorage.js&quot;,
+    &quot;HttpStorage.js&quot;];
+  var prefix = &quot;../../../source/storage/&quot;;
+  var errorReport = orp.util.LintTool.getErrorReportFromListOfFilesnames(listOfSourceCodeFiles, prefix);
+  var message = &quot;Lint check \n&quot; + errorReport;
+  assertTrue(message, !errorReport);
+}
+
+
+// -------------------------------------------------------------------
+// End of file
+// -------------------------------------------------------------------

Modified: trunk/tests/util/XmlConverterMultiplePassesTest.js
===================================================================
--- trunk/tests/util/XmlConverterMultiplePassesTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/util/XmlConverterMultiplePassesTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -42,7 +42,7 @@
   dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
   dojo.require(&quot;orp.util.XmlConverter&quot;);
   dojo.require(&quot;orp.util.Util&quot;);
-  dojo.require(&quot;orp.model.StubVirtualServer&quot;);
+  dojo.require(&quot;orp.archive.StubArchive&quot;);
   dojo.require(&quot;orp.model.World&quot;);
 
   XmlTextNodeToAttributeSpecifier = orp.util.XmlTextNodeToAttributeSpecifier;
@@ -52,7 +52,7 @@
   // var pathToTrunkDirectoryFromThisFile = &quot;../../../&quot;;
   var pathToTrunkDirectoryFromThisFile = &quot;../..&quot;;
   
-  var virtualServer = new orp.model.StubVirtualServer(pathToTrunkDirectoryFromThisFile);  
+  var virtualServer = new orp.archive.StubArchive(pathToTrunkDirectoryFromThisFile);  
   world = new orp.model.World(virtualServer);
   var annsPassword = &quot;Ann's password&quot;;
   var userAnn = world.newUser(&quot;Ann Doe&quot;, annsPassword);

Modified: trunk/tests/util/XmlConverterTest.js
===================================================================
--- trunk/tests/util/XmlConverterTest.js	2005-10-04 00:32:22 UTC (rev 346)
+++ trunk/tests/util/XmlConverterTest.js	2005-10-04 01:33:56 UTC (rev 347)
@@ -40,7 +40,7 @@
   dojo.hostenv.setModulePrefix(&quot;dojo&quot;, &quot;../../../dojo/dojo-0.1.0/src&quot;);
   dojo.require(&quot;orp.util.XmlConverter&quot;);
   dojo.require(&quot;orp.util.Util&quot;);
-  dojo.require(&quot;orp.model.StubVirtualServer&quot;);
+  dojo.require(&quot;orp.archive.StubArchive&quot;);
   dojo.require(&quot;orp.model.World&quot;);
 
   XmlTextNodeToAttributeSpecifier = orp.util.XmlTextNodeToAttributeSpecifier;
@@ -50,7 +50,7 @@
   // var pathToTrunkDirectoryFromThisFile = &quot;../../../&quot;;
   pathToTrunkDirectoryFromThisFile = &quot;../..&quot;;
   
-  var virtualServer = new orp.model.StubVirtualServer(pathToTrunkDirectoryFromThisFile);  
+  var virtualServer = new orp.archive.StubArchive(pathToTrunkDirectoryFromThisFile);  
   world = new orp.model.World(virtualServer);
   var annsPassword = &quot;Ann's password&quot;;
   var userAnn = world.newUser(&quot;Ann Doe&quot;, annsPassword);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000329.html">[openrecord-svn] r346 - trunk/documentation
</A></li>
	<LI>Next message: <A HREF="000331.html">[openrecord-svn] r348 - in trunk: source/storage tests/storage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#330">[ date ]</a>
              <a href="thread.html#330">[ thread ]</a>
              <a href="subject.html#330">[ subject ]</a>
              <a href="author.html#330">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openrecord-svn">More information about the openrecord-svn
mailing list</a><br>
</body></html>
