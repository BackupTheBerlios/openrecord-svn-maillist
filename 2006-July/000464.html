<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openrecord-svn] r483 - trunk/source/plugins
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openrecord-svn/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:openrecord-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-svn%5D%20r483%20-%20trunk/source/plugins&In-Reply-To=%3C200607130948.k6D9mjXb001405%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000462.html">
   <LINK REL="Next"  HREF="000463.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openrecord-svn] r483 - trunk/source/plugins</H1>
    <B>hiran at mail.berlios.de</B> 
    <A HREF="mailto:openrecord-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-svn%5D%20r483%20-%20trunk/source/plugins&In-Reply-To=%3C200607130948.k6D9mjXb001405%40sheep.berlios.de%3E"
       TITLE="[openrecord-svn] r483 - trunk/source/plugins">hiran at mail.berlios.de
       </A><BR>
    <I>Thu Jul 13 11:48:45 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000462.html">[openrecord-svn] r482 - trunk/source/plugins
</A></li>
        <LI>Next message: <A HREF="000463.html">[openrecord-svn] r484 - trunk/source/plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#464">[ date ]</a>
              <a href="thread.html#464">[ thread ]</a>
              <a href="subject.html#464">[ subject ]</a>
              <a href="author.html#464">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hiran
Date: 2006-07-13 11:48:37 +0200 (Thu, 13 Jul 2006)
New Revision: 483

Added:
   trunk/source/plugins/BarChart.js
Log:
Creation

Added: trunk/source/plugins/BarChart.js
===================================================================
--- trunk/source/plugins/BarChart.js	2006-07-13 06:03:09 UTC (rev 482)
+++ trunk/source/plugins/BarChart.js	2006-07-13 09:48:37 UTC (rev 483)
@@ -0,0 +1,889 @@
+// BarChart.js
+// Created by Hiran Ganegedara
+
+// Dojo Package System &quot;provide&quot; and &quot;require&quot; statements
+dojo.provide(&quot;orp.plugins.BarChart&quot;);
+dojo.require(&quot;orp.view.PluginView&quot;);
+
+/**
+ * The BarChart view displays a set of content items.
+ *
+ * @scope    public instance constructor
+ * @extends  PluginView
+ * @param    superview    The View that serves as the superview for this view.
+ * @param    htmlElement    The HTMLElement to display this view in.
+ * @param    querySpec    The Query Spec item that provides the items for this PluginView to display
+ * @param    layoutItem    An item that can be used to store layout data (like table column order).
+ */
+orp.plugins.BarChart = function(superview, htmlElement, querySpec, layoutItem) {
+	orp.view.PluginView.call(this, superview, htmlElement, querySpec, layoutItem, &quot;BarChart&quot;);
+	this._arrayOfAttributeValues = new Array();
+	this._arrayOfAttributeLabels = new Array();
+	this._barHeight = 20;
+	this._maxWidth = 500;
+	this._pointerLocation = 0;
+	this._changedValue = 0;
+	this._valueIndex = 0;
+	this._attributeIndex = 0;
+	this._barObject = null;
+	this._maxValue = 0;
+	this._chartAttributes = [];
+	this._listOfContentItems = [];
+	this._colorElement = null;
+	this._barColors = [];	
+	this._hasNegativeValues = false;
+	this._fromNegativeToPositive = false;
+	this._fromPositiveToNegative = false;
+	this._tableRowObject = null;	
+	this._isEnteringOnlyOnce = true;
+};
+
+dojo.inherits(orp.plugins.BarChart, orp.view.PluginView);  // makes BarChart be a subclass of PluginView
+
+// -------------------------------------------------------------------
+// Public constants
+// -------------------------------------------------------------------
+	orp.plugins.BarChart.cssClass = {
+	TABLE: &quot;&quot;,
+	PLAIN: &quot;&quot;,
+	FRAME: &quot;&quot;,
+	BAR: &quot;&quot;,
+	POSITIVE: &quot;positive_bar&quot;,
+	NEGATIVE: &quot;negative_bar&quot;,
+	INSIDEBAR: &quot;inside_bar_text&quot;,
+	OUTSIDEBAR: &quot;outside_bar_text&quot;,
+	FIRSTBORDER: &quot;first_row_break&quot;,
+	ROWBORDER: &quot;row_break&quot;,
+	COLORTABLE: &quot;color_table&quot;,
+	COLORCELL: &quot;color_cell&quot;};
+	
+// -------------------------------------------------------------------
+// Register this plugin in the SectionView registry
+// -------------------------------------------------------------------
+orp.plugins.BarChart.UUID = &quot;a4d265d0-124f-11db-b5c2-0011111f4abe&quot;;
+orp.view.SectionView.registerPlugin(orp.plugins.BarChart);
+
+
+// -------------------------------------------------------------------
+// Public class methods
+// -------------------------------------------------------------------
+
+/**
+ * Returns the UUID of the item that represents this class of plugin.
+ *
+ * @scope    public class method
+ * @return   The UUID of the item that represents this class of plugin.
+ */
+orp.plugins.BarChart.getPluginItemUuid = function() {
+	return orp.plugins.BarChart.UUID;
+};
+
+/**
+ * Returns a list of anonymous objects representing Entries that describe the plugin.
+ *
+ * @scope    public class method
+ * @return   A list of anonymous objects representing Entries that describe the plugin.
+ */
+orp.plugins.BarChart.getEntriesForItemRepresentingPluginClass = function(pluginItem, world) {
+	return [
+		{	uuid: &quot;a4d265d1-124f-11db-b5c2-0011111f4abe&quot;,
+			item: pluginItem,
+			attribute: world.getAttributeCalledName(),
+			value: &quot;Bar Chart&quot; },
+		{	uuid: &quot;a4d265d2-124f-11db-b5c2-0011111f4abe&quot;,
+			item: pluginItem,
+			attribute: world.getAttributeCalledShortName(),
+			value: &quot;BarChart&quot; },
+		{	uuid: &quot;a4d265d3-124f-11db-b5c2-0011111f4abe&quot;,
+			item: pluginItem,
+			attribute: world.getAttributeCalledClassName(),
+			value: &quot;BarChart&quot; },
+		{	uuid: &quot;a4d265d4-124f-11db-b5c2-0011111f4abe&quot;,
+			item: pluginItem,
+			attribute: world.getAttributeCalledCategory(),
+			inverseAttribute: world.getAttributeCalledItemsInCategory(),
+			value: world.getItemFromUuid(orp.view.SectionView.UUID.CATEGORY_PLUGIN_VIEW) }
+	];
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+
+/**
+ * Returns the class of this instance.
+ *
+ * @scope    public instance method
+ * @return   A JavaScript class.
+ */
+orp.plugins.BarChart.prototype.getClass = function() {
+	return orp.plugins.BarChart;
+};
+
+/**
+ * This method is called whenever the BarChart plugin is used to
+ * display the results of a query.
+ *
+ * @scope    public instance method
+ */
+orp.plugins.BarChart.prototype.refresh = function() {
+	
+	var listOfStrings = [];
+	var contentItem = null;
+	var temporaryAttribute = null;
+	this._chartAttributes = [];
+	this._barColors = [];
+	this._arrayOfAttributeValues = new Array();
+	this._arrayOfAttributeLabels = new Array();
+	this._barObject = null;
+	this._listOfContentItems = [];
+	var listOfValues;
+	var firstValue;	
+	var attributeUuid;
+	var uniqueIdforInstance = dojo.dom.getUniqueId();
+	var hashTableOfNumericValueIncidenceKeyedByUuid = {};
+	var hashTableOfAttributesKeyedByUuid = {};
+	this._listOfContentItems = this.fetchItems();
+	if(this._listOfConentItems) {
+		this._listOfContentItems.sort(orp.plugins.BarChart.compareItemsByName);
+		if(this._hasNegativeValues) {
+			this._hasNegativeValues = false;
+			this._maxWidth = this._maxWidth * 2;
+			
+		}
+		var world = this.getWorld();
+		var createNewLayoutItemIfNecessary;
+		var layoutItem = this.getLayoutItem(createNewLayoutItemIfNecessary = true);
+		if (layoutItem) {
+			// for each attribute, count the number of items where that attribute has a numeric value
+			for (var iKey in this._listOfContentItems) {
+				contentItem = this._listOfContentItems[iKey];
+				var listOfAttributesForItem = contentItem.getAttributes();
+				for (var i in listOfAttributesForItem) {
+					temporaryAttribute = listOfAttributesForItem[i];
+					attributeUuid = temporaryAttribute.getUuid();
+					hashTableOfAttributesKeyedByUuid[attributeUuid] = temporaryAttribute;
+					listOfValues = contentItem.getValuesForAttribute(temporaryAttribute);
+					if (listOfValues.length &gt; 0) {
+						firstValue = listOfValues[0];
+						if (dojo.lang.isNumber(firstValue)) {
+							var count = hashTableOfNumericValueIncidenceKeyedByUuid[attributeUuid];
+							if (!count) {
+								count = 0;
+							}
+							count += 1;
+							hashTableOfNumericValueIncidenceKeyedByUuid[attributeUuid] = count;						
+						} 				
+					}
+				}
+			}
+			
+					// Get the value for the stored attribute for which the chart is drawn.
+			var attributeCalledSelectedAttribute = world.getItemFromUuid(orp.view.SectionView.UUID.ATTRIBUTE_SELECTED_ATTRIBUTES);
+			var listOfSelectedAttributes = layoutItem.getEntriesForAttribute(attributeCalledSelectedAttribute);
+			// If the attribute is null then decide for which attribute the chart is going to be drawn.
+			if(listOfSelectedAttributes.length === 0) {
+				
+				// find the attribute for which most of the items have a numeric value
+				var maxIncidence = 0;
+				var selectedAttribute;
+				for (attributeUuid in hashTableOfNumericValueIncidenceKeyedByUuid) {
+					var incidenceOfAttribute = hashTableOfNumericValueIncidenceKeyedByUuid[attributeUuid];
+					if (incidenceOfAttribute &gt; maxIncidence) {
+						selectedAttribute = hashTableOfAttributesKeyedByUuid[attributeUuid];
+						maxIncidence = incidenceOfAttribute;
+					}
+				}
+				if(selectedAttribute) {
+					var typeCalledItem = world.getTypeCalledItem();
+					layoutItem.addEntry({attribute: attributeCalledSelectedAttribute, value: selectedAttribute, type: this._typeCalledItem});
+					this._chartAttributes.push(selectedAttribute);
+				}
+			} else {		
+				for(var key in listOfSelectedAttributes) {	
+					this._chartAttributes.push(listOfSelectedAttributes[key].getValue());
+				}
+			}	
+		}
+		// find the maximum value for the selected attributes
+		if (this._chartAttributes[0]) {
+			this._maxValue = 0;
+			for (var jkey in this._listOfContentItems) {
+				contentItem = this._listOfContentItems[jkey];
+				for(var mKey in this._chartAttributes) {
+					listOfValues = contentItem.getValuesForAttribute(this._chartAttributes[mKey]);
+					if (listOfValues.length &gt; 0) {
+						var nextValue = listOfValues[0];
+						if (dojo.lang.isNumber(nextValue)) {					
+							if ((nextValue &lt; 0) &amp;&amp; !this._hasNegativeValues) {
+									this._hasNegativeValues = true;
+									this._maxWidth = this._maxWidth/2;
+							}
+							nextValue = Math.abs(nextValue);
+							this._maxValue = Math.abs(Math.max(this._maxValue, nextValue));
+						}
+					}
+				}
+			}
+		}
+		
+		// Set the color of the bars if there is no value, use green.
+		var attributeCalledBackgroundColor = world.getItemFromUuid(orp.view.SectionView.UUID.ATTRIBUTE_BACKGROUND_COLOR);	
+		for (var cKey in this._chartAttributes) {
+			var listOfEntries = this._chartAttributes[cKey].getEntriesForAttribute(attributeCalledBackgroundColor);
+			if (listOfEntries[0]) {
+				this._barColors.push(listOfEntries[0].getValue());
+			} else {
+				this._barColors.push(&quot;#00ff00&quot;);
+			}
+		}
+		
+		// add the table header row(s)
+		listOfStrings.push(&quot;&lt;table class=\&quot;&quot; + orp.plugins.BarChart.cssClass.TABLE + &quot;\&quot;&gt;&quot;);
+		listOfStrings.push(&quot;&lt;tr&gt;&quot;);
+		var attributeCalledName = this.getWorld().getAttributeCalledName();
+		listOfStrings.push(&quot;&lt;th&gt;&quot; + &quot;&quot; + &quot;&lt;/th&gt;&quot;); // listOfStrings.push(&quot;&lt;th&gt;&quot; + attributeCalledName.getDisplayName() + &quot;&lt;/th&gt;&quot;);
+	
+		if (this._chartAttributes[0]) {
+			listOfStrings.push(&quot;&lt;th align=left colspan=4&gt;&quot;);
+			for(var aKey in this._chartAttributes){
+				if (aKey &gt; 0) {
+					listOfStrings.push(&quot;,&quot;);
+				}
+				listOfStrings.push(&quot; &quot; + this._chartAttributes[aKey].getDisplayName());
+			}
+			listOfStrings.push(&quot;&lt;/th&gt;&quot;);
+			listOfStrings.push(&quot;&lt;tr&gt;&lt;td align=right&gt;Select the Attribute&lt;/td&gt;&lt;td&gt;&lt;form method=post action=\&quot;\&quot;&gt;&lt;select ID=&quot; + uniqueIdforInstance + &quot; size=2 multiple&gt;&quot;);
+			for (attributeUuid in hashTableOfNumericValueIncidenceKeyedByUuid) {
+				var incidence = hashTableOfNumericValueIncidenceKeyedByUuid[attributeUuid];
+				if (incidence &gt; 0) {
+					var displayableAttribute = hashTableOfAttributesKeyedByUuid[attributeUuid];
+					listOfStrings.push(&quot;&lt;option value=&quot;+attributeUuid);
+					for(var sKey in this._chartAttributes) {
+						if(attributeUuid == this._chartAttributes[sKey].getUuid()) {
+							listOfStrings.push(&quot; selected&quot;);
+							break;
+						}
+					}
+					listOfStrings.push(&quot;&gt;&quot;+displayableAttribute.getDisplayName()+&quot;&lt;/option&gt;&quot;);
+				}
+			}
+			listOfStrings.push(&quot;&lt;/select&gt;&lt;/form&gt;&lt;/td&gt;&quot;);
+		} else {
+			listOfStrings.push(&quot;&lt;th&gt;&quot; + &quot;Sorry, there are no attributes with numeric values to chart&quot; + &quot;&lt;/th&gt;&quot;);
+		}
+		listOfStrings.push(&quot;&lt;/tr&gt;&quot;);
+	
+		var staticThis = this;
+		this._listOfContentItems.sort(orp.plugins.BarChart.compareItemsByName);
+		// add all the table body rows
+		for (var kKey in this._listOfContentItems) {
+			contentItem = this._listOfContentItems[kKey];
+			this._arrayOfAttributeLabels[kKey] = contentItem.getDisplayName(&quot;{no name}&quot;);		
+			var numericValue = &quot;&nbsp;&quot;;
+			if (this._chartAttributes[0]) {
+				listOfStrings.push(&quot;&lt;tr&gt;&quot;);
+				if(kKey === 0) {
+					listOfStrings.push(&quot;&lt;td width=10% align=right rowspan=&quot; + this._chartAttributes.length + &quot; class=\&quot;&quot; + orp.plugins.BarChart.cssClass.FIRSTBORDER + &quot;\&quot;&gt;&quot; + contentItem.getDisplayName(&quot;{no name}&quot;) + &quot;&lt;/td&gt;&quot;);
+				} else {
+					listOfStrings.push(&quot;&lt;td width=10% align=right rowspan=&quot; + this._chartAttributes.length + &quot; class=\&quot;&quot; + orp.plugins.BarChart.cssClass.ROWBORDER + &quot;\&quot;&gt;&quot; + contentItem.getDisplayName(&quot;{no name}&quot;) + &quot;&lt;/td&gt;&quot;);
+				}
+				for (var index in this._chartAttributes) {
+					if(index &gt; 0) {
+						listOfStrings.push(&quot;&lt;tr&gt;&quot;);										
+					}
+					listOfValues = contentItem.getValuesForAttribute(this._chartAttributes[index]);
+					if (listOfValues.length &gt; 0) {
+						firstValue = listOfValues[0];
+						if (dojo.lang.isNumber(firstValue)) {
+							numericValue = firstValue;
+							if(this._arrayOfAttributeValues[index]) {
+								this._arrayOfAttributeValues[index].push(numericValue);
+							} else {
+								this._arrayOfAttributeValues[index] = new Array();
+								this._arrayOfAttributeValues[index].push(numericValue);
+							}
+							
+						}else {
+							numericValue = null;
+							if(this._arrayOfAttributeValues[index]) {
+								this._arrayOfAttributeValues[index].push(numericValue);
+							} else {
+								this._arrayOfAttributeValues[index] = new Array();
+								this._arrayOfAttributeValues[index].push(numericValue);
+							}
+						}			
+					}
+					else {
+						if(this._arrayOfAttributeValues[index]) {
+								this._arrayOfAttributeValues[index].push(null);
+						} else {
+							this._arrayOfAttributeValues[index] = new Array();
+							this._arrayOfAttributeValues[index].push(null);
+						}
+					}
+					var width = this._maxWidth;
+					width = Math.abs(Math.round((numericValue / this._maxValue) * this._maxWidth));
+					
+					
+	
+					var tooltip;
+					var onlyForNumericValues = null;
+					var nonNumeric = false;
+					if(this._arrayOfAttributeValues[index][kKey] !== null) {
+						if(dojo.lang.isNumber(this._arrayOfAttributeValues[index][kKey])) {
+							var cssClassName;
+							if (numericValue &gt;= 0) {
+								cssClassName = orp.plugins.BarChart.cssClass.POSITIVE;
+							} else {
+								cssClassName = orp.plugins.BarChart.cssClass.NEGATIVE;
+							}
+							onlyForNumericValues = &quot; bgcolor=&quot;+this._barColors[index]+&quot; class=\&quot;&quot; + cssClassName + &quot;\&quot; style=\&quot;border-color: &quot;+this._barColors[index]+&quot;; cursor: w-resize\&quot; cellspacing=0 cellpadding=0 &quot;;
+							toolTip =this._arrayOfAttributeLabels[kKey] +&quot; &quot;+ this._chartAttributes[index].getDisplayName()+ &quot;: &quot;+ numericValue;
+						}
+					}
+					else {
+						toolTip= &quot;Non numeric property&quot;;
+						numericValue = &quot;Non numeric value&quot;;
+						nonNumeric = true;
+					}
+					var barAlign = &quot;left&quot;;
+					var textAlign = &quot;right&quot;;
+					if((this._hasNegativeValues &amp;&amp; (numericValue &gt;= 0)) || (this._hasNegativeValues &amp;&amp; nonNumeric)) {
+						listOfStrings.push(&quot;&lt;td&gt;&lt;/td&gt;&lt;td align=right width=1%&gt;&lt;/td&gt;&quot;);
+					}
+					if(this._hasNegativeValues &amp;&amp; (numericValue &lt; 0)) {
+						barAlign = &quot;right&quot;;
+						textAlign = &quot;left&quot;;
+						listOfStrings.push(&quot;&lt;td&gt;&nbsp;&lt;/td&gt;&quot;);
+					}
+					listOfStrings.push(&quot;&lt;td align= &quot; + barAlign + &quot;&gt;&lt;table ID=\&quot;&quot;+ uniqueIdforInstance + &quot;_%_&quot; + index + &quot;_%_&quot; + kKey + &quot;\&quot;&quot;);
+					listOfStrings.push(onlyForNumericValues);
+					listOfStrings.push(&quot;width=&quot; + width + &quot;&gt;&lt;tr style=cursor:default&gt;&lt;td title=\&quot;&quot; + toolTip + &quot;\&quot; align=&quot; + textAlign +&quot;&gt;&quot; + numericValue + &quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td &gt;&nbsp;&lt;/td&gt;&quot;);
+					if(this._hasNegativeValues &amp;&amp; (numericValue &lt; 0)) {
+						listOfStrings.push(&quot;&lt;td align=left&gt;&nbsp;&lt;/td&gt;&quot;);
+					}
+					if(index &gt; 0) {
+						listOfStrings.push(&quot;&lt;/tr&gt;&quot;);
+					}
+				}
+			}
+			onlyForNumericValues = &quot;&quot;;
+		}
+		listOfStrings.push(&quot;&lt;/table&gt;&quot;);
+		// return all the new content
+		var finalString = listOfStrings.join(&quot;&quot;);
+		this.getHtmlElement().innerHTML = finalString;
+		this.getHtmlElement().align = &quot;center&quot;;
+		var dropDownObject = document.getElementById(uniqueIdforInstance);
+		dojo.event.connect(dropDownObject, &quot;onchange&quot;, this, &quot;chageSelectedAttribute&quot;);
+		for (var j in this._arrayOfAttributeValues[0]) {
+			if(this._chartAttributes[0]) {
+				for (var bKey in this._chartAttributes) {
+					var one = 1;
+					var two = 2;
+					var three = 3;
+					var four = 4;
+					if(bKey &gt; 0) {
+						one = 0;
+						two = 1;
+						three = 2;
+						four = 3;
+					}
+					var tableObject = document.getElementById(uniqueIdforInstance+ &quot;_%_&quot; + bKey + &quot;_%_&quot; + j);
+					var tableRow = tableObject.parentNode.parentNode;
+					if(dojo.lang.isNumber(this._arrayOfAttributeValues[bKey][j])) {
+						
+						dojo.event.connect(tableObject, &quot;onmousedown&quot;, this, &quot;mouseDown&quot;);
+						var spanElement = orp.view.View.newElement(&quot;span&quot;, &quot;&quot;, null, this._arrayOfAttributeValues[bKey][j].toString());
+						this.getHtmlElement().appendChild(spanElement);
+						var elementWidth = spanElement.offsetWidth;
+						this.getHtmlElement().removeChild(spanElement);
+						spanElement.className = orp.plugins.BarChart.cssClass.INSIDEBAR;	
+						var barTableRow = tableObject.rows[0];		
+						if(this._hasNegativeValues) {					
+							if((tableObject.width-5) &lt; elementWidth) {
+								spanElement.className = orp.plugins.BarChart.cssClass.OUTSIDEBAR;
+								if(this._arrayOfAttributeValues[bKey][j] &lt; 0) {							
+									barTableRow.cells[0].innerHTML = &quot;&nbsp;&quot;;					
+									tableRow.cells[one].appendChild(spanElement);
+									tableRow.cells[one].align = &quot;right&quot;;
+									tableRow.cells[three].colSpan = 2;
+									tableRow.cells[two].width = parseInt(tableObject.width) + 5;
+									tableRow.removeChild(tableRow.cells[four]);							
+								} else {	
+									barTableRow.cells[0].innerHTML = &quot;&nbsp;&quot;;					
+									tableRow.cells[four].appendChild(spanElement);
+									tableRow.cells[four].align = &quot;left&quot;;
+									tableRow.cells[two].colSpan = 2;
+									tableRow.cells[three].width = parseInt(tableObject.width) + 5;
+									tableRow.removeChild(tableRow.cells[one]);							
+								}
+							} else {
+								barTableRow.cells[0].innerHTML = &quot;&quot;;
+								barTableRow.cells[0].appendChild(spanElement);
+								tableRow.cells[three].colSpan = 2;
+								tableRow.removeChild(tableRow.cells[four]);
+								tableRow.cells[two].colSpan = 2;
+								tableRow.removeChild(tableRow.cells[one]);												
+							}
+						} else {
+							if((tableObject.width - 5) &lt; elementWidth) {
+								spanElement.className = orp.plugins.BarChart.cssClass.OUTSIDEBAR;		
+								barTableRow.cells[0].innerHTML = &quot;&nbsp;&quot;;
+								tableRow.cells[one].width = parseInt(tableObject.width) + 5;					
+								tableRow.cells[two].appendChild(spanElement);
+								tableRow.cells[two].align = &quot;left&quot;;
+								
+							} else {
+								barTableRow.cells[0].innerHTML = &quot;&quot;;
+								barTableRow.cells[0].appendChild(spanElement);
+								tableRow.cells[one].colSpan = 2;
+								tableRow.removeChild(tableRow.cells[two]);				
+							}
+						}									
+					} else {
+						if(this._hasNegativeValues) {
+							tableRow.cells[three].colSpan = 2;
+							tableRow.removeChild(tableRow.cells[four]);
+							tableRow.cells[two].colSpan = 2;
+							tableRow.removeChild(tableRow.cells[one]);
+						} else {
+							tableRow.cells[one].colSpan = 2;
+							tableRow.removeChild(tableRow.cells[two]);
+						}
+					}
+				}
+			}
+		}
+		var colorTableObject = orp.view.View.appendNewElement(this.getHtmlElement(), &quot;table&quot;, orp.plugins.BarChart.cssClass.COLORTABLE, null, null);
+		for (var colorKey in this._chartAttributes) {
+			var tableRowObject = orp.view.View.appendNewElement(colorTableObject, &quot;tr&quot;, null, null, null);
+			var attributeNameCell = orp.view.View.appendNewElement(tableRowObject, &quot;td&quot;, null, null, this._chartAttributes[colorKey].getDisplayName());
+			var colorCell = orp.view.View.appendNewElement(tableRowObject, &quot;td&quot;, orp.plugins.BarChart.cssClass.COLORCELL, null, null);
+			colorCell.id = colorKey.toString();
+			colorCell.innerHTML = &quot;&nbsp;&quot;;
+			colorCell.bgColor = this._barColors[colorKey];
+			dojo.event.connect(colorCell, &quot;onclick&quot;, this, &quot;displayColorPalette&quot;);
+		}
+	} else {
+		return;
+	}
+};
+
+/**
+ * This method the selection of the drop down list
+ *
+ * @scope    public instance method
+ */
+ 
+orp.plugins.BarChart.prototype.chageSelectedAttribute = function (evt) {
+	var world = this.getWorld();
+	var listOfSelectedAttributes = [];
+	var hashTableOfAttributesKeyedByUuid = {};
+	this._chartAttributes = [];
+	for(var j in evt.target.options) {
+		if(evt.target.options[j].selected) {
+			listOfSelectedAttributes.push(evt.target.options[j].value);
+		}
+	}
+	for (var iKey in this._listOfContentItems) {
+		contentItem = this._listOfContentItems[iKey];
+		var listOfAttributesForItem = contentItem.getAttributes();
+		for (var i in listOfAttributesForItem) {
+			temporaryAttribute = listOfAttributesForItem[i];
+			attributeUuid = temporaryAttribute.getUuid();
+			hashTableOfAttributesKeyedByUuid[attributeUuid] = temporaryAttribute;
+		}
+	}
+	var layoutItem = this.getLayoutItem();
+	var attributeCalledSelectedAttribute = world.getItemFromUuid(orp.view.SectionView.UUID.ATTRIBUTE_SELECTED_ATTRIBUTES);
+	
+	if (layoutItem) {
+		var listOfEntriesForSelectedAttribute = layoutItem.getEntriesForAttribute(attributeCalledSelectedAttribute);			
+		for (var aKey in listOfEntriesForSelectedAttribute) {
+			listOfEntriesForSelectedAttribute[aKey].voteToDelete();
+		}
+		if (listOfSelectedAttributes[0]) {
+			this._chartAttributes = [];
+			for (var index in listOfSelectedAttributes) {	
+				var newSelectedAttribute = hashTableOfAttributesKeyedByUuid[listOfSelectedAttributes[index]];
+				this._chartAttributes.push(newSelectedAttribute);					
+				var typeCalledItem = world.getTypeCalledItem();
+				layoutItem.addEntry({attribute: attributeCalledSelectedAttribute, value: newSelectedAttribute, type: typeCalledItem});
+			}
+		}
+	}
+	this.refresh();	
+};
+
+
+/**
+ * This method is called whenever the mouse is moved after executing the
+ * orp.plugins.BarChart.prototype.mouseDown function.
+ *
+ * @scope    public instance method
+ */
+orp.plugins.BarChart.prototype.mouseMove = function(evt) {	
+	var mouseX = evt.clientX;
+	var barWidth = parseInt(this._barObject.width);
+	var change = mouseX-this._pointerLocation;
+	var barChartRowHtml = [];
+	var newWidth = 0;
+	var newValue = 0;
+	var barTableRow = null;	
+	var spanElement;
+	var elementWidth;
+	var one = 1;
+	var two = 2;
+	var three = 3;
+	var four = 4;
+	if(this._attributeIndex &gt; 0) {
+		one = 0;
+		two = 1;
+		three = 2;
+		four = 3;
+	}
+	barChartRowHtml.push(&quot;&lt;tr style=\&quot;cursor:default\&quot;&gt;&lt;td bgcolor=&quot;+this._barColors[this._attributeIndex]);
+	
+	if(this._changedValue &gt; 0) {
+		newWidth = barWidth + change;
+		if(newWidth &gt; this._maxWidth) {
+			newWidth = this._maxWidth;
+		} else if(newWidth &lt;=0) {
+			newWidth = 0;
+		}		
+		newValue= Math.abs(Math.round(newWidth/this._maxWidth*this._maxValue));
+		spanElement = orp.view.View.newElement(&quot;span&quot;, &quot;&quot;, null, newValue.toString());				
+		this.getHtmlElement().appendChild(spanElement);
+		elementWidth = spanElement.offsetWidth;
+		this.getHtmlElement().removeChild(spanElement);
+		barChartRowHtml.push(&quot;  title=\&quot;&quot;+this._arrayOfAttributeLabels[this._valueIndex]+&quot;: &quot;+this._chartAttributes[this._attributeIndex].getDisplayName()+&quot; is &quot;+newValue+&quot;\&quot; align=right&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;&quot;);
+		this._barObject.innerHTML = barChartRowHtml.join(&quot;&quot;);		
+		spanElement.className = orp.plugins.BarChart.cssClass.INSIDEBAR;
+		barTableRow = this._barObject.rows[0];
+		if(this._hasNegativeValues) {
+			if((newWidth-5) &lt; elementWidth) {
+				spanElement.className = orp.plugins.BarChart.cssClass.OUTSIDEBAR;
+				if(this._tableRowObject.cells.length == three) {					
+					this._tableRowObject.cells[two].colSpan = 1;
+					this._tableRowObject.insertCell(three);
+				} else if(this._tableRowObject.cells[four]) {
+					this._tableRowObject.removeChild(this._tableRowObject.cells[four]);
+				}	
+				this._barObject.rows[0].cells[0].innerHTML = &quot;&nbsp;&quot;;
+				this._tableRowObject.cells[three].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[three].appendChild(spanElement);
+				this._tableRowObject.cells[three].align = &quot;left&quot;;
+				this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[two].appendChild(this._barObject);
+				this._tableRowObject.cells[two].width = newWidth + 5;
+				this._tableRowObject.cells[two].align = &quot;left&quot;;				
+			} else {
+				spanElement.className = orp.plugins.BarChart.cssClass.INSIDEBAR;
+				barTableRow.cells[0].innerHTML = &quot;&quot;;
+				barTableRow.cells[0].appendChild(spanElement);
+				barTableRow.cells[0].align = &quot;right&quot;;
+				this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[two].appendChild(this._barObject);
+				if(this._tableRowObject.cells[two].colSpan != 2) {
+					this._tableRowObject.removeChild(this._tableRowObject.cells[three]);
+					this._tableRowObject.cells[two].colSpan = 2;
+					this._tableRowObject.cells[two].width = null;
+				}
+			}
+			this._isEnteringOnlyOnce = true;
+			this._fromNegativeToPositive = false;
+			this._fromPositiveToNegative = true;					
+		} else {
+			if((newWidth-5) &lt; elementWidth) {
+				spanElement.className = orp.plugins.BarChart.cssClass.OUTSIDEBAR;
+				if(this._tableRowObject.cells[one].colSpan == 2) {		
+					this._barObject.rows[0].cells[0].innerHTML = &quot;&nbsp;&quot;;
+					this._tableRowObject.insertCell(two);
+					this._tableRowObject.cells[one].width = newWidth + 5;
+					this._tableRowObject.cells[one].colSpan = 1;
+					this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+					this._tableRowObject.cells[one].appendChild(this._barObject);
+					this._tableRowObject.cells[two].appendChild(spanElement);
+					this._tableRowObject.cells[two].align = &quot;left&quot;;
+				} else {
+					this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+					this._tableRowObject.cells[two].appendChild(spanElement);
+					this._tableRowObject.cells[two].align = &quot;left&quot;;
+					this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+					this._tableRowObject.cells[one].appendChild(this._barObject);
+					this._tableRowObject.cells[one].width = newWidth + 5;
+				}
+			} else {	
+				spanElement.className = orp.plugins.BarChart.cssClass.INSIDEBAR;			
+				barTableRow.cells[0].innerHTML = &quot;&quot;;
+				barTableRow.cells[0].appendChild(spanElement);
+				barTableRow.cells[0].align = &quot;right&quot;;
+				this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[one].appendChild(this._barObject);
+				if(this._tableRowObject.cells[one].colSpan != 2) {
+					this._tableRowObject.removeChild(this._tableRowObject.cells[two]);
+					this._tableRowObject.cells[one].colSpan = 2;
+					this._tableRowObject.cells[one].width = null;
+				}
+			}
+		}		
+		
+	} else if(this._changedValue &lt;0) {
+		newWidth = barWidth - change;
+		if(newWidth &gt; this._maxWidth) {
+			newWidth = this._maxWidth;
+		} else if(newWidth &lt;=0) {
+			newWidth = 0;
+		}
+		newValue= 0 - Math.round(newWidth/this._maxWidth*this._maxValue);
+		spanElement = orp.view.View.newElement(&quot;span&quot;, &quot;&quot;, null, newValue.toString());				
+		this.getHtmlElement().appendChild(spanElement);
+		elementWidth = spanElement.offsetWidth;
+		this.getHtmlElement().removeChild(spanElement);
+		barChartRowHtml.push(&quot;  title=\&quot;&quot;+this._arrayOfAttributeLabels[this._valueIndex]+&quot;: &quot;+this._chartAttributes[this._attributeIndex].getDisplayName()+&quot; is &quot;+newValue+&quot;\&quot; align=right&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;&quot;);
+		this._barObject.innerHTML = barChartRowHtml.join(&quot;&quot;);
+		spanElement.className = orp.plugins.BarChart.cssClass.INSIDEBAR;
+		barTableRow = this._barObject.rows[0];
+		if(this._hasNegativeValues) {
+			if((newWidth-5) &lt; elementWidth) {
+				spanElement.className = orp.plugins.BarChart.cssClass.OUTSIDEBAR;
+				if(this._tableRowObject.cells.length == three) {					
+					this._tableRowObject.cells[one].colSpan = 1;
+					this._tableRowObject.insertCell(one);																
+				} else if (this._tableRowObject.cells[four]){
+					this._tableRowObject.removeChild(this._tableRowObject.cells[four]);
+					this._tableRowObject.cells[three].colSpan = 2;
+					this._tableRowObject.cells[three].innerHTML = &quot;&quot;;
+				}
+				this._barObject.rows[0].cells[0].innerHTML = &quot;&nbsp;&quot;;	
+				this._tableRowObject.cells[two].width = newWidth + 5;
+				this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[two].appendChild(this._barObject);
+				this._tableRowObject.cells[two].align = &quot;right&quot;;
+				this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[one].appendChild(spanElement);
+				this._tableRowObject.cells[one].align = &quot;right&quot;;					
+			
+			} else {	
+				spanElement.className = orp.plugins.BarChart.cssClass.INSIDEBAR;							
+				barTableRow.cells[0].innerHTML = &quot;&quot;;
+				barTableRow.cells[0].appendChild(spanElement);
+				barTableRow.cells[0].align = &quot;left&quot;;
+				this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+				this._tableRowObject.cells[one].appendChild(this._barObject);
+				if(this._tableRowObject.cells[two].colSpan != 2) {
+					this._tableRowObject.removeChild(this._tableRowObject.cells[two]);
+					this._tableRowObject.cells[one].colSpan = 2;
+				}
+			}									
+		}
+		this._isEnteringOnlyOnce = true;
+		this._fromNegativeToPositive = true;
+		this._fromPositiveToNegative = false;
+	} else {
+		if(!this._isEnteringOnlyOnce) {
+			if(this._fromNegativeToPositive) {
+				this._changedValue = 0.001;
+				this._pointerLocation = mouseX;
+				dojo.event.connect(document, &quot;onmouseup&quot;, this, &quot;mouseUp&quot;);
+				dojo.event.disconnect(document, &quot;onmousedown&quot;, this, &quot;mouseDown&quot;);
+				document.ondblclick = null;
+				document.onclick = null;
+				return;
+			}
+			else if(this._fromPositiveToNegative) {
+				this._changedValue = -0.001;
+				this._pointerLocation = mouseX;
+				dojo.event.connect(document, &quot;onmouseup&quot;, this, &quot;mouseUp&quot;);
+				dojo.event.disconnect(document, &quot;onmousedown&quot;, this, &quot;mouseDown&quot;);
+				document.ondblclick = null;
+				document.onclick = null;
+				return;
+			}
+		}
+		if (this._fromNegativeToPositive &amp;&amp; this._isEnteringOnlyOnce) {
+			this._barObject.className = orp.plugins.BarChart.cssClass.POSITIVE;			
+			newWidth = barWidth + 1;	
+			newValue= Math.round(newWidth/this._maxWidth*this._maxValue);
+			barChartRowHtml.push(&quot;  title=\&quot;&quot;+this._arrayOfAttributeLabels[this._valueIndex]+&quot;: &quot;+this._chartAttributes[this._attributeIndex].getDisplayName()+&quot; is &quot;+newValue+&quot;\&quot; align=right&gt;&lt;/td&gt;&lt;/tr&gt;&quot;);
+			this._barObject.innerHTML = barChartRowHtml.join(&quot;&quot;);
+			this._barObject.rows[0].cells[0].innerHTML = &quot;&nbsp;&quot;;
+			spanElement = orp.view.View.newElement(&quot;span&quot;, &quot;&quot;, null, newValue.toString());
+			
+			
+			this._tableRowObject.cells[three].colSpan = 1;
+			this._tableRowObject.cells[three].innerHTML = &quot;&quot;;	
+			this._tableRowObject.cells[three].width = newWidth;
+			this._tableRowObject.cells[three].appendChild(this._barObject);
+			this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+			this._tableRowObject.cells[two].colSpan = 2;
+			this._tableRowObject.insertCell(four);
+			this._tableRowObject.cells[four].innerHTML = &quot;&quot;;
+			this._tableRowObject.cells[four].appendChild(spanElement);
+			this._tableRowObject.removeChild(this._tableRowObject.cells[one]);
+		} else if(this._fromPositiveToNegative &amp;&amp; this._isEnteringOnlyOnce) {
+			this._barObject.className = orp.plugins.BarChart.cssClass.NEGATIVE;
+			newWidth = barWidth + 1;
+			newValue= 0 - Math.round(newWidth/this._maxWidth*this._maxValue);
+			barChartRowHtml.push(&quot;  title=\&quot;&quot;+this._arrayOfAttributeLabels[this._valueIndex]+&quot;: &quot;+this._chartAttributes[this._attributeIndex].getDisplayName()+&quot; is &quot;+newValue+&quot;\&quot; align=right&gt;&lt;/td&gt;&lt;/tr&gt;&quot;);
+			this._barObject.innerHTML = barChartRowHtml.join(&quot;&quot;);
+			this._barObject.rows[0].cells[0].innerHTML = &quot;&nbsp;&quot;;
+			spanElement = orp.view.View.newElement(&quot;span&quot;, &quot;&quot;, null, newValue.toString());
+			
+			this._tableRowObject.cells[one].colSpan = 1;
+			this._tableRowObject.cells[one].innerHTML = &quot;&quot;;	
+			this._tableRowObject.cells[one].width = newWidth;
+			this._tableRowObject.cells[one].appendChild(this._barObject);
+			this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+			this._tableRowObject.cells[two].colSpan = 2;
+			this._tableRowObject.removeChild(this._tableRowObject.cells[three]);
+			this._tableRowObject.insertCell(1);
+			this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+			this._tableRowObject.cells[one].align = &quot;right&quot;;
+			this._tableRowObject.cells[one].appendChild(spanElement);
+		} else if(!this._hasNegativeValues) {
+			newWidth = barWidth + change;
+			newValue = Math.round(newWidth/this._maxWidth*this._maxValue);
+			barChartRowHtml.push(&quot;  title=\&quot;&quot;+this._arrayOfAttributeLabels[this._valueIndex]+&quot;: &quot;+this._chartAttributes[this._attributeIndex].getDisplayName()+&quot; is &quot;+newValue+&quot;\&quot; align=right&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;&quot;);
+			this._barObject.innerHTML = barChartRowHtml.join(&quot;&quot;);
+			this._barObject.rows[0].cells[0].innerHTML = &quot;&nbsp;&quot;;
+			spanElement = orp.view.View.newElement(&quot;span&quot;, &quot;&quot;, null, newValue.toString());				
+			this.getHtmlElement().appendChild(spanElement);
+			elementWidth = spanElement.offsetWidth;
+			this.getHtmlElement().removeChild(spanElement);
+			this._tableRowObject.cells[one].innerHTML = &quot;&quot;;
+			this._tableRowObject.cells[one].appendChild(this._barObject);
+			this._tableRowObject.cells[two].innerHTML = &quot;&quot;;
+			this._tableRowObject.cells[two].appendChild(spanElement);
+			this._fromNegativeToPositive = false;
+			this._fromPositiveToNegative = false;
+			this._hasNegativeValues = false;		
+		}
+		this._isEnteringOnlyOnce = false;	
+	}		
+	this._changedValue = newValue;
+	this._barObject.width = Math.abs(newWidth);	
+	this._pointerLocation = mouseX;
+	dojo.event.connect(document, &quot;onmouseup&quot;, this, &quot;mouseUp&quot;);
+	dojo.event.disconnect(document, &quot;onmousedown&quot;, this, &quot;mouseDown&quot;);
+	document.ondblclick = null;
+	document.onclick = null;	
+};
+
+/**
+ * This method is called whenever the left mouse button is released after executing the
+ * orp.plugins.BarChart.prototype.mouseMove function.
+ *
+ * @scope    public instance method
+ */
+orp.plugins.BarChart.prototype.mouseUp = function(evt) {
+	if(evt.which==1) {	
+		dojo.event.disconnect(document, &quot;onmousemove&quot;, this, &quot;mouseMove&quot;);
+		dojo.event.disconnect(document, &quot;onmouseup&quot;, this, &quot;mouseUp&quot;);
+		var contentItem = this._listOfContentItems[this._valueIndex];
+		var listOfEntries = contentItem.getEntriesForAttribute(this._chartAttributes[this._attributeIndex]);
+		if (listOfEntries[0]) {
+			var affectedEntry = listOfEntries[0];
+			contentItem.replaceEntry({previousEntry: affectedEntry, value: this._changedValue});
+			this._arrayOfAttributeValues[this._attributeIndex][this._valueIndex] = this._changedValue;
+		}
+		dojo.event.connect(this._barObject, &quot;onmousedown&quot;, this, &quot;mouseDown&quot;);
+		document.ondblclick = null;
+		document.onclick = null;
+		this._fromNegativeToPositive = false;
+		this._fromPositiveToNegative = false;
+		this._barObject = null;
+	}
+};
+
+/**
+ * This method is called whenever the left mouse button is pressed down 
+ * in order ot drag and resize the bars.
+ *
+ * @scope    public instance method
+ */
+orp.plugins.BarChart.prototype.mouseDown = function(evt) {
+	if(evt.target.tagName==&quot;TABLE&quot; &amp;&amp; evt.target.style.cursor ==&quot;w-resize&quot;)	{
+		if(evt.which == 1) {
+			document.onmousedown = orp.plugins.BarChart.nullfunc;
+			document.onclick = null;
+			document.ondblclick = null;
+			this._pointerLocation=evt.clientX;
+			this._barObject = evt.target;
+			var splitArray = this._barObject.id.split(&quot;_%_&quot;);
+			this._attributeIndex = parseInt(splitArray[1]);
+			this._valueIndex = parseInt(splitArray[2]);
+			var tableDataObject = this._barObject.parentNode;
+			this._tableRowObject = tableDataObject.parentNode;
+			this._isEnteringOnlyOnce = true;
+			this._changedValue = this._arrayOfAttributeValues[this._attributeIndex][this._valueIndex];
+			if(this._hasNegativeValues) {
+				if(this._changedValue &gt; 0) {
+					this._fromPositiveToNegative = true;
+					this._fromNegativeToPositive = false;
+				} else {
+					this._fromNegativeToPositive = true;
+					this._fromPositiveToNegative = false;
+				}
+			} else {
+				this._fromNegativeToPositive = false;
+				this._fromPositiveToNegative = false;
+			}
+			dojo.event.connect(document, &quot;onmousemove&quot;, this, &quot;mouseMove&quot;);
+			
+		}
+	}
+};
+
+/**
+ * This method is called in order to stop event propegation
+ *
+ * @scope    provate instance method
+ */
+orp.plugins.BarChart.nullfinc = function() {
+	return false;
+};
+
+orp.plugins.BarChart.prototype.displayColorPalette = function (evt) {
+	this._colorElement = evt.target;
+	orp.view.View.removeChildrenOfElement(this._colorElement);
+	this._colorElement.parentNode.insertCell(2);
+	var colorPicker = dojo.widget.createWidget(&quot;ColorPalette&quot;, null, this._colorElement.parentNode.cells[2], &quot;last&quot;);
+	dojo.event.connect(colorPicker, &quot;click&quot;, this, &quot;colorSelect&quot;);
+};
+
+// Sets the color of the selected attribute
+orp.plugins.BarChart.prototype.colorSelect = function (evt) {
+	
+  	this.setBackgroundColorForAttribute(evt.target.color, this._colorElement.id);
+	this._colorElement.parentNode.removeChild(this._colorElement.parentNode.cells[2]);
+};
+
+// Sets the color of any given attribute
+orp.plugins.BarChart.prototype.setBackgroundColorForAttribute = function(color, attributeIndex) {
+	var world = this.getWorld();
+	var attributeCalledBackgroundColor = world.getItemFromUuid(orp.view.SectionView.UUID.ATTRIBUTE_BACKGROUND_COLOR);	
+	var listOfEntries = this._chartAttributes[attributeIndex].getEntriesForAttribute(attributeCalledBackgroundColor);
+	if (listOfEntries[0]) {
+		var affectedEntry = listOfEntries[0];
+		this._chartAttributes[attributeIndex].addEntry({attribute: attributeCalledBackgroundColor, previousEntry: affectedEntry, value: color});		
+	} else {
+		var typeCalledText = world.getTypeCalledText();
+		this._chartAttributes[attributeIndex].addEntry({attribute: attributeCalledBackgroundColor, value: color, type: typeCalledText});
+	}
+	this.refresh();
+};			
+
+orp.plugins.BarChart.compareItemsByName = function(itemA, itemB) {
+	var strA = itemA.getDisplayName().toLowerCase();
+	var strB = itemB.getDisplayName().toLowerCase();
+	if (strA &lt; strB) {return -1;}
+	if (strA == strB) {return 0;}
+	return 1;
+};
+// End of file
+
+
+// End of file


Property changes on: trunk/source/plugins/BarChart.js
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000462.html">[openrecord-svn] r482 - trunk/source/plugins
</A></li>
	<LI>Next message: <A HREF="000463.html">[openrecord-svn] r484 - trunk/source/plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#464">[ date ]</a>
              <a href="thread.html#464">[ thread ]</a>
              <a href="subject.html#464">[ subject ]</a>
              <a href="author.html#464">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openrecord-svn">More information about the openrecord-svn
mailing list</a><br>
</body></html>
